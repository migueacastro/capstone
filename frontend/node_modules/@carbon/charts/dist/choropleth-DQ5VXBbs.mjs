import { t as go, $ as Gl, i as Hl, a0 as mo, a1 as vo, a2 as Ul, a3 as zl, a4 as Fl, a5 as Wl, a6 as Xl, a7 as yo, a8 as zr, a9 as en, g as T, p as qt, a as tn, C as Fr, aa as yt, w as wt, ab as Cn, H as Yt, E as Wr, ac as Eo, ad as ks, c as jl, ae as ye, I as yi, K as Ei, e as ee, af as mn, ag as fe, f as me, x as ge, ah as Yl, h as qe, O as ql, ai as ke, z as vt, l as jt, aj as $t, ak as Zl, M as Kl, al as So, y as _t, q as un, n as Gn, am as Us, an as Jl, ao as Ql, ap as Si, aq as Xr, A as Te, ar as jr, as as xo, at as bo } from "./color-scale-utils-Be_a2c4x.mjs";
import { y as st, $ as x, N as xt, r as Se, q as Be, L as tc, A as Jt, m as tt, s as Oe, W as Ze, S as Mt, e as Y, Z as Ge, i as Ft, f as Yr, J as zs, d as ec, F as Hn, n as Fs, H as Ws, C as Xs, p as Un, b as qr, D as js, U as nc, x as we, a0 as zn, O as Ys } from "./axis-scales-CPuwbFQf.mjs";
import { R as it } from "./a11y-ePqvrObQ.mjs";
import { t as es, s as R, c as Zr, e as Le, f as oe, h as Kr, g as Gt, i as ns, j as Ke, m as qs, k as Jr, l as kt, n as Qr, o as sc, q as ic, u as lr, D as _, v as rc, w as xi, G as ta, x as cr, y as ac, a as oc, p as bt, r as ea, b as lc } from "./angle-utils-CkmwGwzz.mjs";
import { b as To, c as lt, a as ur, s as cc } from "./array-CpuOY0Tp.mjs";
function uc(s, t, e, n) {
  for (var i = -1, r = s == null ? 0 : s.length; ++i < r; )
    e = t(e, s[i], i, s);
  return e;
}
function hc(s) {
  return function(t) {
    return s == null ? void 0 : s[t];
  };
}
var dc = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, pc = hc(dc), fc = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, gc = "\\u0300-\\u036f", mc = "\\ufe20-\\ufe2f", vc = "\\u20d0-\\u20ff", yc = gc + mc + vc, Ec = "[" + yc + "]", Sc = RegExp(Ec, "g");
function xc(s) {
  return s = go(s), s && s.replace(fc, pc).replace(Sc, "");
}
var bc = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function Tc(s) {
  return s.match(bc) || [];
}
var Oc = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function wc(s) {
  return Oc.test(s);
}
var Oo = "\\ud800-\\udfff", Lc = "\\u0300-\\u036f", Ac = "\\ufe20-\\ufe2f", Mc = "\\u20d0-\\u20ff", _c = Lc + Ac + Mc, wo = "\\u2700-\\u27bf", Lo = "a-z\\xdf-\\xf6\\xf8-\\xff", Cc = "\\xac\\xb1\\xd7\\xf7", kc = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Rc = "\\u2000-\\u206f", Ic = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Ao = "A-Z\\xc0-\\xd6\\xd8-\\xde", Dc = "\\ufe0e\\ufe0f", Mo = Cc + kc + Rc + Ic, _o = "['’]", na = "[" + Mo + "]", Pc = "[" + _c + "]", Co = "\\d+", Nc = "[" + wo + "]", ko = "[" + Lo + "]", Ro = "[^" + Oo + Mo + Co + wo + Lo + Ao + "]", $c = "\\ud83c[\\udffb-\\udfff]", Vc = "(?:" + Pc + "|" + $c + ")", Bc = "[^" + Oo + "]", Io = "(?:\\ud83c[\\udde6-\\uddff]){2}", Do = "[\\ud800-\\udbff][\\udc00-\\udfff]", Xe = "[" + Ao + "]", Gc = "\\u200d", sa = "(?:" + ko + "|" + Ro + ")", Hc = "(?:" + Xe + "|" + Ro + ")", ia = "(?:" + _o + "(?:d|ll|m|re|s|t|ve))?", ra = "(?:" + _o + "(?:D|LL|M|RE|S|T|VE))?", Po = Vc + "?", No = "[" + Dc + "]?", Uc = "(?:" + Gc + "(?:" + [Bc, Io, Do].join("|") + ")" + No + Po + ")*", zc = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Fc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Wc = No + Po + Uc, Xc = "(?:" + [Nc, Io, Do].join("|") + ")" + Wc, jc = RegExp([
  Xe + "?" + ko + "+" + ia + "(?=" + [na, Xe, "$"].join("|") + ")",
  Hc + "+" + ra + "(?=" + [na, Xe + sa, "$"].join("|") + ")",
  Xe + "?" + sa + "+" + ia,
  Xe + "+" + ra,
  Fc,
  zc,
  Co,
  Xc
].join("|"), "g");
function Yc(s) {
  return s.match(jc) || [];
}
function qc(s, t, e) {
  return s = go(s), t = t, t === void 0 ? wc(s) ? Yc(s) : Tc(s) : s.match(t) || [];
}
var Zc = "['’]", Kc = RegExp(Zc, "g");
function Jc(s) {
  return function(t) {
    return uc(qc(xc(t).replace(Kc, "")), s, "");
  };
}
function Qc(s, t, e) {
  return s === s && (e !== void 0 && (s = s <= e ? s : e), t !== void 0 && (s = s >= t ? s : t)), s;
}
function $o(s, t, e) {
  return e === void 0 && (e = t, t = void 0), e !== void 0 && (e = es(e), e = e === e ? e : 0), t !== void 0 && (t = es(t), t = t === t ? t : 0), Qc(es(s), t, e);
}
var tu = "Expected a function";
function eu(s, t, e) {
  if (typeof s != "function")
    throw new TypeError(tu);
  return setTimeout(function() {
    s.apply(void 0, e);
  }, t);
}
var nu = Gl(function(s, t, e) {
  return eu(s, es(t) || 0, e);
});
function su(s, t) {
  var e = -1, n = Hl(s) ? Array(s.length) : [];
  return To(s, function(i, r, a) {
    n[++e] = t(i, r, a);
  }), n;
}
function iu(s, t) {
  var e = vo(s) ? Ul : su;
  return e(s, mo(t));
}
var ru = 1 / 0;
function au(s, t) {
  return zl(iu(s, t), ru);
}
function Vo(s, t) {
  return Fl(s, t);
}
var He = Jc(function(s, t, e) {
  return s + (e ? "-" : "") + t.toLowerCase();
});
function ou(s, t) {
  var e;
  return To(s, function(n, i, r) {
    return e = t(n, i, r), !e;
  }), !!e;
}
function lu(s, t, e) {
  var n = vo(s) ? Wl : ou;
  return n(s, mo(t));
}
class Re {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const e = this._partials;
    let n = 0;
    for (let i = 0; i < this._n && i < 32; i++) {
      const r = e[i], a = t + r, o = Math.abs(t) < Math.abs(r) ? t - (a - r) : r - (a - t);
      o && (e[n++] = o), t = a;
    }
    return e[n] = t, this._n = n + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let e = this._n, n, i, r, a = 0;
    if (e > 0) {
      for (a = t[--e]; e > 0 && (n = a, i = t[--e], a = n + i, r = i - (a - n), !r); )
        ;
      e > 0 && (r < 0 && t[e - 1] < 0 || r > 0 && t[e - 1] > 0) && (i = r * 2, n = a + i, i == n - a && (a = n));
    }
    return a;
  }
}
function* cu(s) {
  for (const t of s)
    yield* t;
}
function Bo(s) {
  return Array.from(cu(s));
}
function uu(s) {
  return s;
}
var ss = 1, is = 2, bi = 3, vn = 4, aa = 1e-6;
function hu(s) {
  return "translate(" + s + ",0)";
}
function du(s) {
  return "translate(0," + s + ")";
}
function pu(s) {
  return (t) => +s(t);
}
function fu(s, t) {
  return t = Math.max(0, s.bandwidth() - t * 2) / 2, s.round() && (t = Math.round(t)), (e) => +s(e) + t;
}
function gu() {
  return !this.__axis;
}
function Rs(s, t) {
  var e = [], n = null, i = null, r = 6, a = 6, o = 3, c = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, l = s === ss || s === vn ? -1 : 1, h = s === vn || s === is ? "x" : "y", d = s === ss || s === bi ? hu : du;
  function u(p) {
    var f = n ?? (t.ticks ? t.ticks.apply(t, e) : t.domain()), g = i ?? (t.tickFormat ? t.tickFormat.apply(t, e) : uu), m = Math.max(r, 0) + o, E = t.range(), y = +E[0] + c, v = +E[E.length - 1] + c, S = (t.bandwidth ? fu : pu)(t.copy(), c), b = p.selection ? p.selection() : p, O = b.selectAll(".domain").data([null]), I = b.selectAll(".tick").data(f, t).order(), k = I.exit(), G = I.enter().append("g").attr("class", "tick"), C = I.select("line"), L = I.select("text");
    O = O.merge(O.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), I = I.merge(G), C = C.merge(G.append("line").attr("stroke", "currentColor").attr(h + "2", l * r)), L = L.merge(G.append("text").attr("fill", "currentColor").attr(h, l * m).attr("dy", s === ss ? "0em" : s === bi ? "0.71em" : "0.32em")), p !== b && (O = O.transition(p), I = I.transition(p), C = C.transition(p), L = L.transition(p), k = k.transition(p).attr("opacity", aa).attr("transform", function(B) {
      return isFinite(B = S(B)) ? d(B + c) : this.getAttribute("transform");
    }), G.attr("opacity", aa).attr("transform", function(B) {
      var D = this.parentNode.__axis;
      return d((D && isFinite(D = D(B)) ? D : S(B)) + c);
    })), k.remove(), O.attr("d", s === vn || s === is ? a ? "M" + l * a + "," + y + "H" + c + "V" + v + "H" + l * a : "M" + c + "," + y + "V" + v : a ? "M" + y + "," + l * a + "V" + c + "H" + v + "V" + l * a : "M" + y + "," + c + "H" + v), I.attr("opacity", 1).attr("transform", function(B) {
      return d(S(B) + c);
    }), C.attr(h + "2", l * r), L.attr(h, l * m).text(g), b.filter(gu).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", s === is ? "start" : s === vn ? "end" : "middle"), b.each(function() {
      this.__axis = S;
    });
  }
  return u.scale = function(p) {
    return arguments.length ? (t = p, u) : t;
  }, u.ticks = function() {
    return e = Array.from(arguments), u;
  }, u.tickArguments = function(p) {
    return arguments.length ? (e = p == null ? [] : Array.from(p), u) : e.slice();
  }, u.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), u) : n && n.slice();
  }, u.tickFormat = function(p) {
    return arguments.length ? (i = p, u) : i;
  }, u.tickSize = function(p) {
    return arguments.length ? (r = a = +p, u) : r;
  }, u.tickSizeInner = function(p) {
    return arguments.length ? (r = +p, u) : r;
  }, u.tickSizeOuter = function(p) {
    return arguments.length ? (a = +p, u) : a;
  }, u.tickPadding = function(p) {
    return arguments.length ? (o = +p, u) : o;
  }, u.offset = function(p) {
    return arguments.length ? (c = +p, u) : c;
  }, u;
}
function mu(s) {
  return Rs(ss, s);
}
function vu(s) {
  return Rs(is, s);
}
function hr(s) {
  return Rs(bi, s);
}
function Go(s) {
  return Rs(vn, s);
}
const Ti = { capture: !0, passive: !1 };
function Oi(s) {
  s.preventDefault(), s.stopImmediatePropagation();
}
function yu(s) {
  var t = s.document.documentElement, e = R(s).on("dragstart.drag", Oi, Ti);
  "onselectstart" in t ? e.on("selectstart.drag", Oi, Ti) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Eu(s, t) {
  var e = s.document.documentElement, n = R(s).on("dragstart.drag", null);
  t && (n.on("click.drag", Oi, Ti), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in e ? n.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect);
}
function Su(s, t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = s(n / (t - 1));
  return e;
}
const xu = (s) => +s, Zs = (s) => () => s;
function bu(s, {
  sourceEvent: t,
  target: e,
  selection: n,
  mode: i,
  dispatch: r
}) {
  Object.defineProperties(this, {
    type: { value: s, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: e, enumerable: !0, configurable: !0 },
    selection: { value: n, enumerable: !0, configurable: !0 },
    mode: { value: i, enumerable: !0, configurable: !0 },
    _: { value: r }
  });
}
function Tu(s) {
  s.stopImmediatePropagation();
}
function Ks(s) {
  s.preventDefault(), s.stopImmediatePropagation();
}
var oa = { name: "drag" }, Js = { name: "space" }, Ue = { name: "handle" }, ze = { name: "center" };
const { abs: la, max: Rt, min: It } = Math;
function ca(s) {
  return [+s[0], +s[1]];
}
function ua(s) {
  return [ca(s[0]), ca(s[1])];
}
var rs = {
  name: "x",
  handles: ["w", "e"].map(ds),
  input: function(s, t) {
    return s == null ? null : [[+s[0], t[0][1]], [+s[1], t[1][1]]];
  },
  output: function(s) {
    return s && [s[0][0], s[1][0]];
  }
}, Qs = {
  name: "y",
  handles: ["n", "s"].map(ds),
  input: function(s, t) {
    return s == null ? null : [[t[0][0], +s[0]], [t[1][0], +s[1]]];
  },
  output: function(s) {
    return s && [s[0][1], s[1][1]];
  }
}, pe = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
}, ha = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
}, da = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
}, Ou = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
}, wu = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function ds(s) {
  return { type: s };
}
function Lu(s) {
  return !s.ctrlKey && !s.button;
}
function Au() {
  var s = this.ownerSVGElement || this;
  return s.hasAttribute("viewBox") ? (s = s.viewBox.baseVal, [[s.x, s.y], [s.x + s.width, s.y + s.height]]) : [[0, 0], [s.width.baseVal.value, s.height.baseVal.value]];
}
function Mu() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function ti(s) {
  for (; !s.__brush; ) if (!(s = s.parentNode)) return;
  return s.__brush;
}
function _u(s) {
  return s[0][0] === s[1][0] || s[0][1] === s[1][1];
}
function Ho() {
  return Cu(rs);
}
function Cu(s) {
  var t = Au, e = Lu, n = Mu, i = !0, r = Xl("start", "brush", "end"), a = 6, o;
  function c(m) {
    var E = m.property("__brush", g).selectAll(".overlay").data([ds("overlay")]);
    E.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", pe.overlay).merge(E).each(function() {
      var v = ti(this).extent;
      R(this).attr("x", v[0][0]).attr("y", v[0][1]).attr("width", v[1][0] - v[0][0]).attr("height", v[1][1] - v[0][1]);
    }), m.selectAll(".selection").data([ds("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", pe.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var y = m.selectAll(".handle").data(s.handles, function(v) {
      return v.type;
    });
    y.exit().remove(), y.enter().append("rect").attr("class", function(v) {
      return "handle handle--" + v.type;
    }).attr("cursor", function(v) {
      return pe[v.type];
    }), m.each(l).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", u).filter(n).on("touchstart.brush", u).on("touchmove.brush", p).on("touchend.brush touchcancel.brush", f).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  c.move = function(m, E, y) {
    m.tween ? m.on("start.brush", function(v) {
      h(this, arguments).beforestart().start(v);
    }).on("interrupt.brush end.brush", function(v) {
      h(this, arguments).end(v);
    }).tween("brush", function() {
      var v = this, S = v.__brush, b = h(v, arguments), O = S.selection, I = s.input(typeof E == "function" ? E.apply(this, arguments) : E, S.extent), k = yo(O, I);
      function G(C) {
        S.selection = C === 1 && I === null ? null : k(C), l.call(v), b.brush();
      }
      return O !== null && I !== null ? G : G(1);
    }) : m.each(function() {
      var v = this, S = arguments, b = v.__brush, O = s.input(typeof E == "function" ? E.apply(v, S) : E, b.extent), I = h(v, S).beforestart();
      zr(v), b.selection = O === null ? null : O, l.call(v), I.start(y).brush(y).end(y);
    });
  }, c.clear = function(m, E) {
    c.move(m, null, E);
  };
  function l() {
    var m = R(this), E = ti(this).selection;
    E ? (m.selectAll(".selection").style("display", null).attr("x", E[0][0]).attr("y", E[0][1]).attr("width", E[1][0] - E[0][0]).attr("height", E[1][1] - E[0][1]), m.selectAll(".handle").style("display", null).attr("x", function(y) {
      return y.type[y.type.length - 1] === "e" ? E[1][0] - a / 2 : E[0][0] - a / 2;
    }).attr("y", function(y) {
      return y.type[0] === "s" ? E[1][1] - a / 2 : E[0][1] - a / 2;
    }).attr("width", function(y) {
      return y.type === "n" || y.type === "s" ? E[1][0] - E[0][0] + a : a;
    }).attr("height", function(y) {
      return y.type === "e" || y.type === "w" ? E[1][1] - E[0][1] + a : a;
    })) : m.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
  }
  function h(m, E, y) {
    var v = m.__brush.emitter;
    return v && (!y || !v.clean) ? v : new d(m, E, y);
  }
  function d(m, E, y) {
    this.that = m, this.args = E, this.state = m.__brush, this.active = 0, this.clean = y;
  }
  d.prototype = {
    beforestart: function() {
      return ++this.active === 1 && (this.state.emitter = this, this.starting = !0), this;
    },
    start: function(m, E) {
      return this.starting ? (this.starting = !1, this.emit("start", m, E)) : this.emit("brush", m), this;
    },
    brush: function(m, E) {
      return this.emit("brush", m, E), this;
    },
    end: function(m, E) {
      return --this.active === 0 && (delete this.state.emitter, this.emit("end", m, E)), this;
    },
    emit: function(m, E, y) {
      var v = R(this.that).datum();
      r.call(
        m,
        this.that,
        new bu(m, {
          sourceEvent: E,
          target: c,
          selection: s.output(this.state.selection),
          mode: y,
          dispatch: r
        }),
        v
      );
    }
  };
  function u(m) {
    if (o && !m.touches || !e.apply(this, arguments)) return;
    var E = this, y = m.target.__data__.type, v = (i && m.metaKey ? y = "overlay" : y) === "selection" ? oa : i && m.altKey ? ze : Ue, S = s === Qs ? null : Ou[y], b = s === rs ? null : wu[y], O = ti(E), I = O.extent, k = O.selection, G = I[0][0], C, L, B = I[0][1], D, A, w = I[1][0], V, N, P = I[1][1], $, X, F = 0, et = 0, J, ct = S && b && i && m.shiftKey, Q, j, Z = Array.from(m.touches || [m], (nt) => {
      const St = nt.identifier;
      return nt = en(nt, E), nt.point0 = nt.slice(), nt.identifier = St, nt;
    });
    zr(E);
    var ut = h(E, arguments, !0).beforestart();
    if (y === "overlay") {
      k && (J = !0);
      const nt = [Z[0], Z[1] || Z[0]];
      O.selection = k = [[
        C = s === Qs ? G : It(nt[0][0], nt[1][0]),
        D = s === rs ? B : It(nt[0][1], nt[1][1])
      ], [
        V = s === Qs ? w : Rt(nt[0][0], nt[1][0]),
        $ = s === rs ? P : Rt(nt[0][1], nt[1][1])
      ]], Z.length > 1 && U(m);
    } else
      C = k[0][0], D = k[0][1], V = k[1][0], $ = k[1][1];
    L = C, A = D, N = V, X = $;
    var ht = R(E).attr("pointer-events", "none"), Et = ht.selectAll(".overlay").attr("cursor", pe[y]);
    if (m.touches)
      ut.moved = H, ut.ended = W;
    else {
      var Ut = R(m.view).on("mousemove.brush", H, !0).on("mouseup.brush", W, !0);
      i && Ut.on("keydown.brush", zt, !0).on("keyup.brush", an, !0), yu(m.view);
    }
    l.call(E), ut.start(m, v.name);
    function H(nt) {
      for (const St of nt.changedTouches || [nt])
        for (const ie of Z)
          ie.identifier === St.identifier && (ie.cur = en(St, E));
      if (ct && !Q && !j && Z.length === 1) {
        const St = Z[0];
        la(St.cur[0] - St[0]) > la(St.cur[1] - St[1]) ? j = !0 : Q = !0;
      }
      for (const St of Z)
        St.cur && (St[0] = St.cur[0], St[1] = St.cur[1]);
      J = !0, Ks(nt), U(nt);
    }
    function U(nt) {
      const St = Z[0], ie = St.point0;
      var te;
      switch (F = St[0] - ie[0], et = St[1] - ie[1], v) {
        case Js:
        case oa: {
          S && (F = Rt(G - C, It(w - V, F)), L = C + F, N = V + F), b && (et = Rt(B - D, It(P - $, et)), A = D + et, X = $ + et);
          break;
        }
        case Ue: {
          Z[1] ? (S && (L = Rt(G, It(w, Z[0][0])), N = Rt(G, It(w, Z[1][0])), S = 1), b && (A = Rt(B, It(P, Z[0][1])), X = Rt(B, It(P, Z[1][1])), b = 1)) : (S < 0 ? (F = Rt(G - C, It(w - C, F)), L = C + F, N = V) : S > 0 && (F = Rt(G - V, It(w - V, F)), L = C, N = V + F), b < 0 ? (et = Rt(B - D, It(P - D, et)), A = D + et, X = $) : b > 0 && (et = Rt(B - $, It(P - $, et)), A = D, X = $ + et));
          break;
        }
        case ze: {
          S && (L = Rt(G, It(w, C - F * S)), N = Rt(G, It(w, V + F * S))), b && (A = Rt(B, It(P, D - et * b)), X = Rt(B, It(P, $ + et * b)));
          break;
        }
      }
      N < L && (S *= -1, te = C, C = V, V = te, te = L, L = N, N = te, y in ha && Et.attr("cursor", pe[y = ha[y]])), X < A && (b *= -1, te = D, D = $, $ = te, te = A, A = X, X = te, y in da && Et.attr("cursor", pe[y = da[y]])), O.selection && (k = O.selection), Q && (L = k[0][0], N = k[1][0]), j && (A = k[0][1], X = k[1][1]), (k[0][0] !== L || k[0][1] !== A || k[1][0] !== N || k[1][1] !== X) && (O.selection = [[L, A], [N, X]], l.call(E), ut.brush(nt, v.name));
    }
    function W(nt) {
      if (Tu(nt), nt.touches) {
        if (nt.touches.length) return;
        o && clearTimeout(o), o = setTimeout(function() {
          o = null;
        }, 500);
      } else
        Eu(nt.view, J), Ut.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      ht.attr("pointer-events", "all"), Et.attr("cursor", pe.overlay), O.selection && (k = O.selection), _u(k) && (O.selection = null, l.call(E)), ut.end(nt, v.name);
    }
    function zt(nt) {
      switch (nt.keyCode) {
        case 16: {
          ct = S && b;
          break;
        }
        case 18: {
          v === Ue && (S && (V = N - F * S, C = L + F * S), b && ($ = X - et * b, D = A + et * b), v = ze, U(nt));
          break;
        }
        case 32: {
          (v === Ue || v === ze) && (S < 0 ? V = N - F : S > 0 && (C = L - F), b < 0 ? $ = X - et : b > 0 && (D = A - et), v = Js, Et.attr("cursor", pe.selection), U(nt));
          break;
        }
        default:
          return;
      }
      Ks(nt);
    }
    function an(nt) {
      switch (nt.keyCode) {
        case 16: {
          ct && (Q = j = ct = !1, U(nt));
          break;
        }
        case 18: {
          v === ze && (S < 0 ? V = N : S > 0 && (C = L), b < 0 ? $ = X : b > 0 && (D = A), v = Ue, U(nt));
          break;
        }
        case 32: {
          v === Js && (nt.altKey ? (S && (V = N - F * S, C = L + F * S), b && ($ = X - et * b, D = A + et * b), v = ze) : (S < 0 ? V = N : S > 0 && (C = L), b < 0 ? $ = X : b > 0 && (D = A), v = Ue), Et.attr("cursor", pe[y]), U(nt));
          break;
        }
        default:
          return;
      }
      Ks(nt);
    }
  }
  function p(m) {
    h(this, arguments).moved(m);
  }
  function f(m) {
    h(this, arguments).ended(m);
  }
  function g() {
    var m = this.__brush || { selection: null };
    return m.extent = ua(t.apply(this, arguments)), m.dim = s, m;
  }
  return c.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : Zs(ua(m)), c) : t;
  }, c.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : Zs(!!m), c) : e;
  }, c.touchable = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Zs(!!m), c) : n;
  }, c.handleSize = function(m) {
    return arguments.length ? (a = +m, c) : a;
  }, c.keyModifiers = function(m) {
    return arguments.length ? (i = !!m, c) : i;
  }, c.on = function() {
    var m = r.on.apply(r, arguments);
    return m === r ? c : m;
  }, c;
}
const wi = Math.PI, Li = 2 * wi, Ae = 1e-6, ku = Li - Ae;
function Uo(s) {
  this._ += s[0];
  for (let t = 1, e = s.length; t < e; ++t)
    this._ += arguments[t] + s[t];
}
function Ru(s) {
  let t = Math.floor(s);
  if (!(t >= 0)) throw new Error(`invalid digits: ${s}`);
  if (t > 15) return Uo;
  const e = 10 ** t;
  return function(n) {
    this._ += n[0];
    for (let i = 1, r = n.length; i < r; ++i)
      this._ += Math.round(arguments[i] * e) / e + n[i];
  };
}
let dr = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Uo : Ru(t);
  }
  moveTo(t, e) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, e) {
    this._append`L${this._x1 = +t},${this._y1 = +e}`;
  }
  quadraticCurveTo(t, e, n, i) {
    this._append`Q${+t},${+e},${this._x1 = +n},${this._y1 = +i}`;
  }
  bezierCurveTo(t, e, n, i, r, a) {
    this._append`C${+t},${+e},${+n},${+i},${this._x1 = +r},${this._y1 = +a}`;
  }
  arcTo(t, e, n, i, r) {
    if (t = +t, e = +e, n = +n, i = +i, r = +r, r < 0) throw new Error(`negative radius: ${r}`);
    let a = this._x1, o = this._y1, c = n - t, l = i - e, h = a - t, d = o - e, u = h * h + d * d;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = e}`;
    else if (u > Ae) if (!(Math.abs(d * c - l * h) > Ae) || !r)
      this._append`L${this._x1 = t},${this._y1 = e}`;
    else {
      let p = n - a, f = i - o, g = c * c + l * l, m = p * p + f * f, E = Math.sqrt(g), y = Math.sqrt(u), v = r * Math.tan((wi - Math.acos((g + u - m) / (2 * E * y))) / 2), S = v / y, b = v / E;
      Math.abs(S - 1) > Ae && this._append`L${t + S * h},${e + S * d}`, this._append`A${r},${r},0,0,${+(d * p > h * f)},${this._x1 = t + b * c},${this._y1 = e + b * l}`;
    }
  }
  arc(t, e, n, i, r, a) {
    if (t = +t, e = +e, n = +n, a = !!a, n < 0) throw new Error(`negative radius: ${n}`);
    let o = n * Math.cos(i), c = n * Math.sin(i), l = t + o, h = e + c, d = 1 ^ a, u = a ? i - r : r - i;
    this._x1 === null ? this._append`M${l},${h}` : (Math.abs(this._x1 - l) > Ae || Math.abs(this._y1 - h) > Ae) && this._append`L${l},${h}`, n && (u < 0 && (u = u % Li + Li), u > ku ? this._append`A${n},${n},0,1,${d},${t - o},${e - c}A${n},${n},0,1,${d},${this._x1 = l},${this._y1 = h}` : u > Ae && this._append`A${n},${n},0,${+(u >= wi)},${d},${this._x1 = t + n * Math.cos(r)},${this._y1 = e + n * Math.sin(r)}`);
  }
  rect(t, e, n, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +e}h${n = +n}v${+i}h${-n}Z`;
  }
  toString() {
    return this._;
  }
};
function Is() {
  return new dr();
}
Is.prototype = dr.prototype;
var pt = 1e-6, zo = 1e-12, at = Math.PI, Ht = at / 2, pa = at / 4, Wt = at * 2, Nt = 180 / at, Tt = at / 180, ft = Math.abs, Fo = Math.atan, Ie = Math.atan2, gt = Math.cos, Iu = Math.exp, Du = Math.log, dt = Math.sin, be = Math.sign || function(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}, se = Math.sqrt, Pu = Math.tan;
function Nu(s) {
  return s > 1 ? 0 : s < -1 ? at : Math.acos(s);
}
function Ee(s) {
  return s > 1 ? Ht : s < -1 ? -Ht : Math.asin(s);
}
function Kt() {
}
function ps(s, t) {
  s && ga.hasOwnProperty(s.type) && ga[s.type](s, t);
}
var fa = {
  Feature: function(s, t) {
    ps(s.geometry, t);
  },
  FeatureCollection: function(s, t) {
    for (var e = s.features, n = -1, i = e.length; ++n < i; ) ps(e[n].geometry, t);
  }
}, ga = {
  Sphere: function(s, t) {
    t.sphere();
  },
  Point: function(s, t) {
    s = s.coordinates, t.point(s[0], s[1], s[2]);
  },
  MultiPoint: function(s, t) {
    for (var e = s.coordinates, n = -1, i = e.length; ++n < i; ) s = e[n], t.point(s[0], s[1], s[2]);
  },
  LineString: function(s, t) {
    Ai(s.coordinates, t, 0);
  },
  MultiLineString: function(s, t) {
    for (var e = s.coordinates, n = -1, i = e.length; ++n < i; ) Ai(e[n], t, 0);
  },
  Polygon: function(s, t) {
    ma(s.coordinates, t);
  },
  MultiPolygon: function(s, t) {
    for (var e = s.coordinates, n = -1, i = e.length; ++n < i; ) ma(e[n], t);
  },
  GeometryCollection: function(s, t) {
    for (var e = s.geometries, n = -1, i = e.length; ++n < i; ) ps(e[n], t);
  }
};
function Ai(s, t, e) {
  var n = -1, i = s.length - e, r;
  for (t.lineStart(); ++n < i; ) r = s[n], t.point(r[0], r[1], r[2]);
  t.lineEnd();
}
function ma(s, t) {
  var e = -1, n = s.length;
  for (t.polygonStart(); ++e < n; ) Ai(s[e], t, 1);
  t.polygonEnd();
}
function je(s, t) {
  s && fa.hasOwnProperty(s.type) ? fa[s.type](s, t) : ps(s, t);
}
function Mi(s) {
  return [Ie(s[1], s[0]), Ee(s[2])];
}
function nn(s) {
  var t = s[0], e = s[1], n = gt(e);
  return [n * gt(t), n * dt(t), dt(e)];
}
function Fn(s, t) {
  return s[0] * t[0] + s[1] * t[1] + s[2] * t[2];
}
function fs(s, t) {
  return [s[1] * t[2] - s[2] * t[1], s[2] * t[0] - s[0] * t[2], s[0] * t[1] - s[1] * t[0]];
}
function ei(s, t) {
  s[0] += t[0], s[1] += t[1], s[2] += t[2];
}
function Wn(s, t) {
  return [s[0] * t, s[1] * t, s[2] * t];
}
function _i(s) {
  var t = se(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
  s[0] /= t, s[1] /= t, s[2] /= t;
}
function Ci(s, t) {
  function e(n, i) {
    return n = s(n, i), t(n[0], n[1]);
  }
  return s.invert && t.invert && (e.invert = function(n, i) {
    return n = t.invert(n, i), n && s.invert(n[0], n[1]);
  }), e;
}
function ki(s, t) {
  return ft(s) > at && (s -= Math.round(s / Wt) * Wt), [s, t];
}
ki.invert = ki;
function Wo(s, t, e) {
  return (s %= Wt) ? t || e ? Ci(ya(s), Ea(t, e)) : ya(s) : t || e ? Ea(t, e) : ki;
}
function va(s) {
  return function(t, e) {
    return t += s, ft(t) > at && (t -= Math.round(t / Wt) * Wt), [t, e];
  };
}
function ya(s) {
  var t = va(s);
  return t.invert = va(-s), t;
}
function Ea(s, t) {
  var e = gt(s), n = dt(s), i = gt(t), r = dt(t);
  function a(o, c) {
    var l = gt(c), h = gt(o) * l, d = dt(o) * l, u = dt(c), p = u * e + h * n;
    return [
      Ie(d * i - p * r, h * e - u * n),
      Ee(p * i + d * r)
    ];
  }
  return a.invert = function(o, c) {
    var l = gt(c), h = gt(o) * l, d = dt(o) * l, u = dt(c), p = u * i - d * r;
    return [
      Ie(d * i + u * r, h * e + p * n),
      Ee(p * e - h * n)
    ];
  }, a;
}
function $u(s) {
  s = Wo(s[0] * Tt, s[1] * Tt, s.length > 2 ? s[2] * Tt : 0);
  function t(e) {
    return e = s(e[0] * Tt, e[1] * Tt), e[0] *= Nt, e[1] *= Nt, e;
  }
  return t.invert = function(e) {
    return e = s.invert(e[0] * Tt, e[1] * Tt), e[0] *= Nt, e[1] *= Nt, e;
  }, t;
}
function Vu(s, t, e, n, i, r) {
  if (e) {
    var a = gt(t), o = dt(t), c = n * e;
    i == null ? (i = t + n * Wt, r = t - c / 2) : (i = Sa(a, i), r = Sa(a, r), (n > 0 ? i < r : i > r) && (i += n * Wt));
    for (var l, h = i; n > 0 ? h > r : h < r; h -= c)
      l = Mi([a, -o * gt(h), -o * dt(h)]), s.point(l[0], l[1]);
  }
}
function Sa(s, t) {
  t = nn(t), t[0] -= s, _i(t);
  var e = Nu(-t[1]);
  return ((-t[2] < 0 ? -e : e) + Wt - pt) % Wt;
}
function Xo() {
  var s = [], t;
  return {
    point: function(e, n, i) {
      t.push([e, n, i]);
    },
    lineStart: function() {
      s.push(t = []);
    },
    lineEnd: Kt,
    rejoin: function() {
      s.length > 1 && s.push(s.pop().concat(s.shift()));
    },
    result: function() {
      var e = s;
      return s = [], t = null, e;
    }
  };
}
function as(s, t) {
  return ft(s[0] - t[0]) < pt && ft(s[1] - t[1]) < pt;
}
function Xn(s, t, e, n) {
  this.x = s, this.z = t, this.o = e, this.e = n, this.v = !1, this.n = this.p = null;
}
function jo(s, t, e, n, i) {
  var r = [], a = [], o, c;
  if (s.forEach(function(f) {
    if (!((g = f.length - 1) <= 0)) {
      var g, m = f[0], E = f[g], y;
      if (as(m, E)) {
        if (!m[2] && !E[2]) {
          for (i.lineStart(), o = 0; o < g; ++o) i.point((m = f[o])[0], m[1]);
          i.lineEnd();
          return;
        }
        E[0] += 2 * pt;
      }
      r.push(y = new Xn(m, f, null, !0)), a.push(y.o = new Xn(m, null, y, !1)), r.push(y = new Xn(E, f, null, !1)), a.push(y.o = new Xn(E, null, y, !0));
    }
  }), !!r.length) {
    for (a.sort(t), xa(r), xa(a), o = 0, c = a.length; o < c; ++o)
      a[o].e = e = !e;
    for (var l = r[0], h, d; ; ) {
      for (var u = l, p = !0; u.v; ) if ((u = u.n) === l) return;
      h = u.z, i.lineStart();
      do {
        if (u.v = u.o.v = !0, u.e) {
          if (p)
            for (o = 0, c = h.length; o < c; ++o) i.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.n.x, 1, i);
          u = u.n;
        } else {
          if (p)
            for (h = u.p.z, o = h.length - 1; o >= 0; --o) i.point((d = h[o])[0], d[1]);
          else
            n(u.x, u.p.x, -1, i);
          u = u.p;
        }
        u = u.o, h = u.z, p = !p;
      } while (!u.v);
      i.lineEnd();
    }
  }
}
function xa(s) {
  if (t = s.length) {
    for (var t, e = 0, n = s[0], i; ++e < t; )
      n.n = i = s[e], i.p = n, n = i;
    n.n = i = s[0], i.p = n;
  }
}
function ni(s) {
  return ft(s[0]) <= at ? s[0] : be(s[0]) * ((ft(s[0]) + at) % Wt - at);
}
function Bu(s, t) {
  var e = ni(t), n = t[1], i = dt(n), r = [dt(e), -gt(e), 0], a = 0, o = 0, c = new Re();
  i === 1 ? n = Ht + pt : i === -1 && (n = -Ht - pt);
  for (var l = 0, h = s.length; l < h; ++l)
    if (u = (d = s[l]).length)
      for (var d, u, p = d[u - 1], f = ni(p), g = p[1] / 2 + pa, m = dt(g), E = gt(g), y = 0; y < u; ++y, f = S, m = O, E = I, p = v) {
        var v = d[y], S = ni(v), b = v[1] / 2 + pa, O = dt(b), I = gt(b), k = S - f, G = k >= 0 ? 1 : -1, C = G * k, L = C > at, B = m * O;
        if (c.add(Ie(B * G * dt(C), E * I + B * gt(C))), a += L ? k + G * Wt : k, L ^ f >= e ^ S >= e) {
          var D = fs(nn(p), nn(v));
          _i(D);
          var A = fs(r, D);
          _i(A);
          var w = (L ^ k >= 0 ? -1 : 1) * Ee(A[2]);
          (n > w || n === w && (D[0] || D[1])) && (o += L ^ k >= 0 ? 1 : -1);
        }
      }
  return (a < -pt || a < pt && c < -zo) ^ o & 1;
}
function Yo(s, t, e, n) {
  return function(i) {
    var r = t(i), a = Xo(), o = t(a), c = !1, l, h, d, u = {
      point: p,
      lineStart: g,
      lineEnd: m,
      polygonStart: function() {
        u.point = E, u.lineStart = y, u.lineEnd = v, h = [], l = [];
      },
      polygonEnd: function() {
        u.point = p, u.lineStart = g, u.lineEnd = m, h = Bo(h);
        var S = Bu(l, n);
        h.length ? (c || (i.polygonStart(), c = !0), jo(h, Hu, S, e, i)) : S && (c || (i.polygonStart(), c = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), c && (i.polygonEnd(), c = !1), h = l = null;
      },
      sphere: function() {
        i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd();
      }
    };
    function p(S, b) {
      s(S, b) && i.point(S, b);
    }
    function f(S, b) {
      r.point(S, b);
    }
    function g() {
      u.point = f, r.lineStart();
    }
    function m() {
      u.point = p, r.lineEnd();
    }
    function E(S, b) {
      d.push([S, b]), o.point(S, b);
    }
    function y() {
      o.lineStart(), d = [];
    }
    function v() {
      E(d[0][0], d[0][1]), o.lineEnd();
      var S = o.clean(), b = a.result(), O, I = b.length, k, G, C;
      if (d.pop(), l.push(d), d = null, !!I) {
        if (S & 1) {
          if (G = b[0], (k = G.length - 1) > 0) {
            for (c || (i.polygonStart(), c = !0), i.lineStart(), O = 0; O < k; ++O) i.point((C = G[O])[0], C[1]);
            i.lineEnd();
          }
          return;
        }
        I > 1 && S & 2 && b.push(b.pop().concat(b.shift())), h.push(b.filter(Gu));
      }
    }
    return u;
  };
}
function Gu(s) {
  return s.length > 1;
}
function Hu(s, t) {
  return ((s = s.x)[0] < 0 ? s[1] - Ht - pt : Ht - s[1]) - ((t = t.x)[0] < 0 ? t[1] - Ht - pt : Ht - t[1]);
}
const ba = Yo(
  function() {
    return !0;
  },
  Uu,
  Fu,
  [-at, -Ht]
);
function Uu(s) {
  var t = NaN, e = NaN, n = NaN, i;
  return {
    lineStart: function() {
      s.lineStart(), i = 1;
    },
    point: function(r, a) {
      var o = r > 0 ? at : -at, c = ft(r - t);
      ft(c - at) < pt ? (s.point(t, e = (e + a) / 2 > 0 ? Ht : -Ht), s.point(n, e), s.lineEnd(), s.lineStart(), s.point(o, e), s.point(r, e), i = 0) : n !== o && c >= at && (ft(t - n) < pt && (t -= n * pt), ft(r - o) < pt && (r -= o * pt), e = zu(t, e, r, a), s.point(n, e), s.lineEnd(), s.lineStart(), s.point(o, e), i = 0), s.point(t = r, e = a), n = o;
    },
    lineEnd: function() {
      s.lineEnd(), t = e = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function zu(s, t, e, n) {
  var i, r, a = dt(s - e);
  return ft(a) > pt ? Fo((dt(t) * (r = gt(n)) * dt(e) - dt(n) * (i = gt(t)) * dt(s)) / (i * r * a)) : (t + n) / 2;
}
function Fu(s, t, e, n) {
  var i;
  if (s == null)
    i = e * Ht, n.point(-at, i), n.point(0, i), n.point(at, i), n.point(at, 0), n.point(at, -i), n.point(0, -i), n.point(-at, -i), n.point(-at, 0), n.point(-at, i);
  else if (ft(s[0] - t[0]) > pt) {
    var r = s[0] < t[0] ? at : -at;
    i = e * r / 2, n.point(-r, i), n.point(0, i), n.point(r, i);
  } else
    n.point(t[0], t[1]);
}
function Wu(s) {
  var t = gt(s), e = 2 * Tt, n = t > 0, i = ft(t) > pt;
  function r(h, d, u, p) {
    Vu(p, s, e, u, h, d);
  }
  function a(h, d) {
    return gt(h) * gt(d) > t;
  }
  function o(h) {
    var d, u, p, f, g;
    return {
      lineStart: function() {
        f = p = !1, g = 1;
      },
      point: function(m, E) {
        var y = [m, E], v, S = a(m, E), b = n ? S ? 0 : l(m, E) : S ? l(m + (m < 0 ? at : -at), E) : 0;
        if (!d && (f = p = S) && h.lineStart(), S !== p && (v = c(d, y), (!v || as(d, v) || as(y, v)) && (y[2] = 1)), S !== p)
          g = 0, S ? (h.lineStart(), v = c(y, d), h.point(v[0], v[1])) : (v = c(d, y), h.point(v[0], v[1], 2), h.lineEnd()), d = v;
        else if (i && d && n ^ S) {
          var O;
          !(b & u) && (O = c(y, d, !0)) && (g = 0, n ? (h.lineStart(), h.point(O[0][0], O[0][1]), h.point(O[1][0], O[1][1]), h.lineEnd()) : (h.point(O[1][0], O[1][1]), h.lineEnd(), h.lineStart(), h.point(O[0][0], O[0][1], 3)));
        }
        S && (!d || !as(d, y)) && h.point(y[0], y[1]), d = y, p = S, u = b;
      },
      lineEnd: function() {
        p && h.lineEnd(), d = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return g | (f && p) << 1;
      }
    };
  }
  function c(h, d, u) {
    var p = nn(h), f = nn(d), g = [1, 0, 0], m = fs(p, f), E = Fn(m, m), y = m[0], v = E - y * y;
    if (!v) return !u && h;
    var S = t * E / v, b = -t * y / v, O = fs(g, m), I = Wn(g, S), k = Wn(m, b);
    ei(I, k);
    var G = O, C = Fn(I, G), L = Fn(G, G), B = C * C - L * (Fn(I, I) - 1);
    if (!(B < 0)) {
      var D = se(B), A = Wn(G, (-C - D) / L);
      if (ei(A, I), A = Mi(A), !u) return A;
      var w = h[0], V = d[0], N = h[1], P = d[1], $;
      V < w && ($ = w, w = V, V = $);
      var X = V - w, F = ft(X - at) < pt, et = F || X < pt;
      if (!F && P < N && ($ = N, N = P, P = $), et ? F ? N + P > 0 ^ A[1] < (ft(A[0] - w) < pt ? N : P) : N <= A[1] && A[1] <= P : X > at ^ (w <= A[0] && A[0] <= V)) {
        var J = Wn(G, (-C + D) / L);
        return ei(J, I), [A, Mi(J)];
      }
    }
  }
  function l(h, d) {
    var u = n ? s : at - s, p = 0;
    return h < -u ? p |= 1 : h > u && (p |= 2), d < -u ? p |= 4 : d > u && (p |= 8), p;
  }
  return Yo(a, o, r, n ? [0, -s] : [-at, s - at]);
}
function Xu(s, t, e, n, i, r) {
  var a = s[0], o = s[1], c = t[0], l = t[1], h = 0, d = 1, u = c - a, p = l - o, f;
  if (f = e - a, !(!u && f > 0)) {
    if (f /= u, u < 0) {
      if (f < h) return;
      f < d && (d = f);
    } else if (u > 0) {
      if (f > d) return;
      f > h && (h = f);
    }
    if (f = i - a, !(!u && f < 0)) {
      if (f /= u, u < 0) {
        if (f > d) return;
        f > h && (h = f);
      } else if (u > 0) {
        if (f < h) return;
        f < d && (d = f);
      }
      if (f = n - o, !(!p && f > 0)) {
        if (f /= p, p < 0) {
          if (f < h) return;
          f < d && (d = f);
        } else if (p > 0) {
          if (f > d) return;
          f > h && (h = f);
        }
        if (f = r - o, !(!p && f < 0)) {
          if (f /= p, p < 0) {
            if (f > d) return;
            f > h && (h = f);
          } else if (p > 0) {
            if (f < h) return;
            f < d && (d = f);
          }
          return h > 0 && (s[0] = a + h * u, s[1] = o + h * p), d < 1 && (t[0] = a + d * u, t[1] = o + d * p), !0;
        }
      }
    }
  }
}
var yn = 1e9, jn = -yn;
function ju(s, t, e, n) {
  function i(l, h) {
    return s <= l && l <= e && t <= h && h <= n;
  }
  function r(l, h, d, u) {
    var p = 0, f = 0;
    if (l == null || (p = a(l, d)) !== (f = a(h, d)) || c(l, h) < 0 ^ d > 0)
      do
        u.point(p === 0 || p === 3 ? s : e, p > 1 ? n : t);
      while ((p = (p + d + 4) % 4) !== f);
    else
      u.point(h[0], h[1]);
  }
  function a(l, h) {
    return ft(l[0] - s) < pt ? h > 0 ? 0 : 3 : ft(l[0] - e) < pt ? h > 0 ? 2 : 1 : ft(l[1] - t) < pt ? h > 0 ? 1 : 0 : h > 0 ? 3 : 2;
  }
  function o(l, h) {
    return c(l.x, h.x);
  }
  function c(l, h) {
    var d = a(l, 1), u = a(h, 1);
    return d !== u ? d - u : d === 0 ? h[1] - l[1] : d === 1 ? l[0] - h[0] : d === 2 ? l[1] - h[1] : h[0] - l[0];
  }
  return function(l) {
    var h = l, d = Xo(), u, p, f, g, m, E, y, v, S, b, O, I = {
      point: k,
      lineStart: B,
      lineEnd: D,
      polygonStart: C,
      polygonEnd: L
    };
    function k(w, V) {
      i(w, V) && h.point(w, V);
    }
    function G() {
      for (var w = 0, V = 0, N = p.length; V < N; ++V)
        for (var P = p[V], $ = 1, X = P.length, F = P[0], et, J, ct = F[0], Q = F[1]; $ < X; ++$)
          et = ct, J = Q, F = P[$], ct = F[0], Q = F[1], J <= n ? Q > n && (ct - et) * (n - J) > (Q - J) * (s - et) && ++w : Q <= n && (ct - et) * (n - J) < (Q - J) * (s - et) && --w;
      return w;
    }
    function C() {
      h = d, u = [], p = [], O = !0;
    }
    function L() {
      var w = G(), V = O && w, N = (u = Bo(u)).length;
      (V || N) && (l.polygonStart(), V && (l.lineStart(), r(null, null, 1, l), l.lineEnd()), N && jo(u, o, w, r, l), l.polygonEnd()), h = l, u = p = f = null;
    }
    function B() {
      I.point = A, p && p.push(f = []), b = !0, S = !1, y = v = NaN;
    }
    function D() {
      u && (A(g, m), E && S && d.rejoin(), u.push(d.result())), I.point = k, S && h.lineEnd();
    }
    function A(w, V) {
      var N = i(w, V);
      if (p && f.push([w, V]), b)
        g = w, m = V, E = N, b = !1, N && (h.lineStart(), h.point(w, V));
      else if (N && S) h.point(w, V);
      else {
        var P = [y = Math.max(jn, Math.min(yn, y)), v = Math.max(jn, Math.min(yn, v))], $ = [w = Math.max(jn, Math.min(yn, w)), V = Math.max(jn, Math.min(yn, V))];
        Xu(P, $, s, t, e, n) ? (S || (h.lineStart(), h.point(P[0], P[1])), h.point($[0], $[1]), N || h.lineEnd(), O = !1) : N && (h.lineStart(), h.point(w, V), O = !1);
      }
      y = w, v = V, S = N;
    }
    return I;
  };
}
const Ri = (s) => s;
var si = new Re(), Ii = new Re(), qo, Zo, Di, Pi, ve = {
  point: Kt,
  lineStart: Kt,
  lineEnd: Kt,
  polygonStart: function() {
    ve.lineStart = Yu, ve.lineEnd = Zu;
  },
  polygonEnd: function() {
    ve.lineStart = ve.lineEnd = ve.point = Kt, si.add(ft(Ii)), Ii = new Re();
  },
  result: function() {
    var s = si / 2;
    return si = new Re(), s;
  }
};
function Yu() {
  ve.point = qu;
}
function qu(s, t) {
  ve.point = Ko, qo = Di = s, Zo = Pi = t;
}
function Ko(s, t) {
  Ii.add(Pi * s - Di * t), Di = s, Pi = t;
}
function Zu() {
  Ko(qo, Zo);
}
var sn = 1 / 0, gs = sn, kn = -sn, ms = kn, vs = {
  point: Ku,
  lineStart: Kt,
  lineEnd: Kt,
  polygonStart: Kt,
  polygonEnd: Kt,
  result: function() {
    var s = [[sn, gs], [kn, ms]];
    return kn = ms = -(gs = sn = 1 / 0), s;
  }
};
function Ku(s, t) {
  s < sn && (sn = s), s > kn && (kn = s), t < gs && (gs = t), t > ms && (ms = t);
}
var Ni = 0, $i = 0, En = 0, ys = 0, Es = 0, Je = 0, Vi = 0, Bi = 0, Sn = 0, Jo, Qo, le, ce, Zt = {
  point: De,
  lineStart: Ta,
  lineEnd: Oa,
  polygonStart: function() {
    Zt.lineStart = th, Zt.lineEnd = eh;
  },
  polygonEnd: function() {
    Zt.point = De, Zt.lineStart = Ta, Zt.lineEnd = Oa;
  },
  result: function() {
    var s = Sn ? [Vi / Sn, Bi / Sn] : Je ? [ys / Je, Es / Je] : En ? [Ni / En, $i / En] : [NaN, NaN];
    return Ni = $i = En = ys = Es = Je = Vi = Bi = Sn = 0, s;
  }
};
function De(s, t) {
  Ni += s, $i += t, ++En;
}
function Ta() {
  Zt.point = Ju;
}
function Ju(s, t) {
  Zt.point = Qu, De(le = s, ce = t);
}
function Qu(s, t) {
  var e = s - le, n = t - ce, i = se(e * e + n * n);
  ys += i * (le + s) / 2, Es += i * (ce + t) / 2, Je += i, De(le = s, ce = t);
}
function Oa() {
  Zt.point = De;
}
function th() {
  Zt.point = nh;
}
function eh() {
  tl(Jo, Qo);
}
function nh(s, t) {
  Zt.point = tl, De(Jo = le = s, Qo = ce = t);
}
function tl(s, t) {
  var e = s - le, n = t - ce, i = se(e * e + n * n);
  ys += i * (le + s) / 2, Es += i * (ce + t) / 2, Je += i, i = ce * s - le * t, Vi += i * (le + s), Bi += i * (ce + t), Sn += i * 3, De(le = s, ce = t);
}
function el(s) {
  this._context = s;
}
el.prototype = {
  _radius: 4.5,
  pointRadius: function(s) {
    return this._radius = s, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(s, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(s, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(s, t);
        break;
      }
      default: {
        this._context.moveTo(s + this._radius, t), this._context.arc(s, t, this._radius, 0, Wt);
        break;
      }
    }
  },
  result: Kt
};
var Gi = new Re(), ii, nl, sl, xn, bn, Rn = {
  point: Kt,
  lineStart: function() {
    Rn.point = sh;
  },
  lineEnd: function() {
    ii && il(nl, sl), Rn.point = Kt;
  },
  polygonStart: function() {
    ii = !0;
  },
  polygonEnd: function() {
    ii = null;
  },
  result: function() {
    var s = +Gi;
    return Gi = new Re(), s;
  }
};
function sh(s, t) {
  Rn.point = il, nl = xn = s, sl = bn = t;
}
function il(s, t) {
  xn -= s, bn -= t, Gi.add(se(xn * xn + bn * bn)), xn = s, bn = t;
}
let wa, Ss, La, Aa;
class Ma {
  constructor(t) {
    this._append = t == null ? rl : ih(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, e) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${e}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${e}`;
        break;
      }
      default: {
        if (this._append`M${t},${e}`, this._radius !== La || this._append !== Ss) {
          const n = this._radius, i = this._;
          this._ = "", this._append`m0,${n}a${n},${n} 0 1,1 0,${-2 * n}a${n},${n} 0 1,1 0,${2 * n}z`, La = n, Ss = this._append, Aa = this._, this._ = i;
        }
        this._ += Aa;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function rl(s) {
  let t = 1;
  this._ += s[0];
  for (const e = s.length; t < e; ++t)
    this._ += arguments[t] + s[t];
}
function ih(s) {
  const t = Math.floor(s);
  if (!(t >= 0)) throw new RangeError(`invalid digits: ${s}`);
  if (t > 15) return rl;
  if (t !== wa) {
    const e = 10 ** t;
    wa = t, Ss = function(i) {
      let r = 1;
      this._ += i[0];
      for (const a = i.length; r < a; ++r)
        this._ += Math.round(arguments[r] * e) / e + i[r];
    };
  }
  return Ss;
}
function rh(s, t) {
  let e = 3, n = 4.5, i, r;
  function a(o) {
    return o && (typeof n == "function" && r.pointRadius(+n.apply(this, arguments)), je(o, i(r))), r.result();
  }
  return a.area = function(o) {
    return je(o, i(ve)), ve.result();
  }, a.measure = function(o) {
    return je(o, i(Rn)), Rn.result();
  }, a.bounds = function(o) {
    return je(o, i(vs)), vs.result();
  }, a.centroid = function(o) {
    return je(o, i(Zt)), Zt.result();
  }, a.projection = function(o) {
    return arguments.length ? (i = o == null ? (s = null, Ri) : (s = o).stream, a) : s;
  }, a.context = function(o) {
    return arguments.length ? (r = o == null ? (t = null, new Ma(e)) : new el(t = o), typeof n != "function" && r.pointRadius(n), a) : t;
  }, a.pointRadius = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : (r.pointRadius(+o), +o), a) : n;
  }, a.digits = function(o) {
    if (!arguments.length) return e;
    if (o == null) e = null;
    else {
      const c = Math.floor(o);
      if (!(c >= 0)) throw new RangeError(`invalid digits: ${o}`);
      e = c;
    }
    return t === null && (r = new Ma(e)), a;
  }, a.projection(s).digits(e).context(t);
}
function pr(s) {
  return function(t) {
    var e = new Hi();
    for (var n in s) e[n] = s[n];
    return e.stream = t, e;
  };
}
function Hi() {
}
Hi.prototype = {
  constructor: Hi,
  point: function(s, t) {
    this.stream.point(s, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fr(s, t, e) {
  var n = s.clipExtent && s.clipExtent();
  return s.scale(150).translate([0, 0]), n != null && s.clipExtent(null), je(e, s.stream(vs)), t(vs.result()), n != null && s.clipExtent(n), s;
}
function al(s, t, e) {
  return fr(s, function(n) {
    var i = t[1][0] - t[0][0], r = t[1][1] - t[0][1], a = Math.min(i / (n[1][0] - n[0][0]), r / (n[1][1] - n[0][1])), o = +t[0][0] + (i - a * (n[1][0] + n[0][0])) / 2, c = +t[0][1] + (r - a * (n[1][1] + n[0][1])) / 2;
    s.scale(150 * a).translate([o, c]);
  }, e);
}
function ah(s, t, e) {
  return al(s, [[0, 0], t], e);
}
function oh(s, t, e) {
  return fr(s, function(n) {
    var i = +t, r = i / (n[1][0] - n[0][0]), a = (i - r * (n[1][0] + n[0][0])) / 2, o = -r * n[0][1];
    s.scale(150 * r).translate([a, o]);
  }, e);
}
function lh(s, t, e) {
  return fr(s, function(n) {
    var i = +t, r = i / (n[1][1] - n[0][1]), a = -r * n[0][0], o = (i - r * (n[1][1] + n[0][1])) / 2;
    s.scale(150 * r).translate([a, o]);
  }, e);
}
var _a = 16, ch = gt(30 * Tt);
function Ca(s, t) {
  return +t ? hh(s, t) : uh(s);
}
function uh(s) {
  return pr({
    point: function(t, e) {
      t = s(t, e), this.stream.point(t[0], t[1]);
    }
  });
}
function hh(s, t) {
  function e(n, i, r, a, o, c, l, h, d, u, p, f, g, m) {
    var E = l - n, y = h - i, v = E * E + y * y;
    if (v > 4 * t && g--) {
      var S = a + u, b = o + p, O = c + f, I = se(S * S + b * b + O * O), k = Ee(O /= I), G = ft(ft(O) - 1) < pt || ft(r - d) < pt ? (r + d) / 2 : Ie(b, S), C = s(G, k), L = C[0], B = C[1], D = L - n, A = B - i, w = y * D - E * A;
      (w * w / v > t || ft((E * D + y * A) / v - 0.5) > 0.3 || a * u + o * p + c * f < ch) && (e(n, i, r, a, o, c, L, B, G, S /= I, b /= I, O, g, m), m.point(L, B), e(L, B, G, S, b, O, l, h, d, u, p, f, g, m));
    }
  }
  return function(n) {
    var i, r, a, o, c, l, h, d, u, p, f, g, m = {
      point: E,
      lineStart: y,
      lineEnd: S,
      polygonStart: function() {
        n.polygonStart(), m.lineStart = b;
      },
      polygonEnd: function() {
        n.polygonEnd(), m.lineStart = y;
      }
    };
    function E(k, G) {
      k = s(k, G), n.point(k[0], k[1]);
    }
    function y() {
      d = NaN, m.point = v, n.lineStart();
    }
    function v(k, G) {
      var C = nn([k, G]), L = s(k, G);
      e(d, u, h, p, f, g, d = L[0], u = L[1], h = k, p = C[0], f = C[1], g = C[2], _a, n), n.point(d, u);
    }
    function S() {
      m.point = E, n.lineEnd();
    }
    function b() {
      y(), m.point = O, m.lineEnd = I;
    }
    function O(k, G) {
      v(i = k, G), r = d, a = u, o = p, c = f, l = g, m.point = v;
    }
    function I() {
      e(d, u, h, p, f, g, r, a, i, o, c, l, _a, n), m.lineEnd = S, S();
    }
    return m;
  };
}
var dh = pr({
  point: function(s, t) {
    this.stream.point(s * Tt, t * Tt);
  }
});
function ph(s) {
  return pr({
    point: function(t, e) {
      var n = s(t, e);
      return this.stream.point(n[0], n[1]);
    }
  });
}
function fh(s, t, e, n, i) {
  function r(a, o) {
    return a *= n, o *= i, [t + s * a, e - s * o];
  }
  return r.invert = function(a, o) {
    return [(a - t) / s * n, (e - o) / s * i];
  }, r;
}
function ka(s, t, e, n, i, r) {
  if (!r) return fh(s, t, e, n, i);
  var a = gt(r), o = dt(r), c = a * s, l = o * s, h = a / s, d = o / s, u = (o * e - a * t) / s, p = (o * t + a * e) / s;
  function f(g, m) {
    return g *= n, m *= i, [c * g - l * m + t, e - l * g - c * m];
  }
  return f.invert = function(g, m) {
    return [n * (h * g - d * m + u), i * (p - d * g - h * m)];
  }, f;
}
function Ds(s) {
  return ol(function() {
    return s;
  })();
}
function ol(s) {
  var t, e = 150, n = 480, i = 250, r = 0, a = 0, o = 0, c = 0, l = 0, h, d = 0, u = 1, p = 1, f = null, g = ba, m = null, E, y, v, S = Ri, b = 0.5, O, I, k, G, C;
  function L(w) {
    return k(w[0] * Tt, w[1] * Tt);
  }
  function B(w) {
    return w = k.invert(w[0], w[1]), w && [w[0] * Nt, w[1] * Nt];
  }
  L.stream = function(w) {
    return G && C === w ? G : G = dh(ph(h)(g(O(S(C = w)))));
  }, L.preclip = function(w) {
    return arguments.length ? (g = w, f = void 0, A()) : g;
  }, L.postclip = function(w) {
    return arguments.length ? (S = w, m = E = y = v = null, A()) : S;
  }, L.clipAngle = function(w) {
    return arguments.length ? (g = +w ? Wu(f = w * Tt) : (f = null, ba), A()) : f * Nt;
  }, L.clipExtent = function(w) {
    return arguments.length ? (S = w == null ? (m = E = y = v = null, Ri) : ju(m = +w[0][0], E = +w[0][1], y = +w[1][0], v = +w[1][1]), A()) : m == null ? null : [[m, E], [y, v]];
  }, L.scale = function(w) {
    return arguments.length ? (e = +w, D()) : e;
  }, L.translate = function(w) {
    return arguments.length ? (n = +w[0], i = +w[1], D()) : [n, i];
  }, L.center = function(w) {
    return arguments.length ? (r = w[0] % 360 * Tt, a = w[1] % 360 * Tt, D()) : [r * Nt, a * Nt];
  }, L.rotate = function(w) {
    return arguments.length ? (o = w[0] % 360 * Tt, c = w[1] % 360 * Tt, l = w.length > 2 ? w[2] % 360 * Tt : 0, D()) : [o * Nt, c * Nt, l * Nt];
  }, L.angle = function(w) {
    return arguments.length ? (d = w % 360 * Tt, D()) : d * Nt;
  }, L.reflectX = function(w) {
    return arguments.length ? (u = w ? -1 : 1, D()) : u < 0;
  }, L.reflectY = function(w) {
    return arguments.length ? (p = w ? -1 : 1, D()) : p < 0;
  }, L.precision = function(w) {
    return arguments.length ? (O = Ca(I, b = w * w), A()) : se(b);
  }, L.fitExtent = function(w, V) {
    return al(L, w, V);
  }, L.fitSize = function(w, V) {
    return ah(L, w, V);
  }, L.fitWidth = function(w, V) {
    return oh(L, w, V);
  }, L.fitHeight = function(w, V) {
    return lh(L, w, V);
  };
  function D() {
    var w = ka(e, 0, 0, u, p, d).apply(null, t(r, a)), V = ka(e, n - w[0], i - w[1], u, p, d);
    return h = Wo(o, c, l), I = Ci(t, V), k = Ci(h, I), O = Ca(I, b), A();
  }
  function A() {
    return G = C = null, L;
  }
  return function() {
    return t = s.apply(this, arguments), L.invert = t.invert && B, D();
  };
}
function ll(s) {
  var t = 0, e = at / 3, n = ol(s), i = n(t, e);
  return i.parallels = function(r) {
    return arguments.length ? n(t = r[0] * Tt, e = r[1] * Tt) : [t * Nt, e * Nt];
  }, i;
}
function gh(s) {
  var t = gt(s);
  function e(n, i) {
    return [n * t, dt(i) / t];
  }
  return e.invert = function(n, i) {
    return [n / t, Ee(i * t)];
  }, e;
}
function mh(s, t) {
  var e = dt(s), n = (e + dt(t)) / 2;
  if (ft(n) < pt) return gh(s);
  var i = 1 + e * (2 * n - e), r = se(i) / n;
  function a(o, c) {
    var l = se(i - 2 * n * dt(c)) / n;
    return [l * dt(o *= n), r - l * gt(o)];
  }
  return a.invert = function(o, c) {
    var l = r - c, h = Ie(o, ft(l)) * be(l);
    return l * n < 0 && (h -= at * be(o) * be(l)), [h / n, Ee((i - (o * o + l * l) * n * n) / (2 * n))];
  }, a;
}
function cl() {
  return ll(mh).scale(155.424).center([0, 33.6442]);
}
function vh() {
  return cl().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function gr(s, t) {
  return [s, Du(Pu((Ht + t) / 2))];
}
gr.invert = function(s, t) {
  return [s, 2 * Fo(Iu(t)) - Ht];
};
function yh() {
  return Eh(gr).scale(961 / Wt);
}
function Eh(s) {
  var t = Ds(s), e = t.center, n = t.scale, i = t.translate, r = t.clipExtent, a = null, o, c, l;
  t.scale = function(d) {
    return arguments.length ? (n(d), h()) : n();
  }, t.translate = function(d) {
    return arguments.length ? (i(d), h()) : i();
  }, t.center = function(d) {
    return arguments.length ? (e(d), h()) : e();
  }, t.clipExtent = function(d) {
    return arguments.length ? (d == null ? a = o = c = l = null : (a = +d[0][0], o = +d[0][1], c = +d[1][0], l = +d[1][1]), h()) : a == null ? null : [[a, o], [c, l]];
  };
  function h() {
    var d = at * n(), u = t($u(t.rotate()).invert([0, 0]));
    return r(a == null ? [[u[0] - d, u[1] - d], [u[0] + d, u[1] + d]] : s === gr ? [[Math.max(u[0] - d, a), o], [Math.min(u[0] + d, c), l]] : [[a, Math.max(u[1] - d, o)], [c, Math.min(u[1] + d, l)]]);
  }
  return h();
}
function xs(s, t) {
  return [s, t];
}
xs.invert = xs;
function Sh() {
  return Ds(xs).scale(152.63);
}
function xh(s, t) {
  var e = gt(s), n = s === t ? dt(s) : (e - gt(t)) / (t - s), i = e / n + s;
  if (ft(n) < pt) return xs;
  function r(a, o) {
    var c = i - o, l = n * a;
    return [c * dt(l), i - c * gt(l)];
  }
  return r.invert = function(a, o) {
    var c = i - o, l = Ie(a, ft(c)) * be(c);
    return c * n < 0 && (l -= at * be(a) * be(c)), [l / n, i - be(n) * se(a * a + c * c)];
  }, r;
}
function bh() {
  return ll(xh).scale(131.154).center([0, 13.9389]);
}
var Ln = 1.340264, An = -0.081106, Mn = 893e-6, _n = 3796e-6, bs = se(3) / 2, Th = 12;
function ul(s, t) {
  var e = Ee(bs * dt(t)), n = e * e, i = n * n * n;
  return [
    s * gt(e) / (bs * (Ln + 3 * An * n + i * (7 * Mn + 9 * _n * n))),
    e * (Ln + An * n + i * (Mn + _n * n))
  ];
}
ul.invert = function(s, t) {
  for (var e = t, n = e * e, i = n * n * n, r = 0, a, o, c; r < Th && (o = e * (Ln + An * n + i * (Mn + _n * n)) - t, c = Ln + 3 * An * n + i * (7 * Mn + 9 * _n * n), e -= a = o / c, n = e * e, i = n * n * n, !(ft(a) < zo)); ++r)
    ;
  return [
    bs * s * (Ln + 3 * An * n + i * (7 * Mn + 9 * _n * n)) / gt(e),
    Ee(dt(e) / bs)
  ];
};
function Oh() {
  return Ds(ul).scale(177.158);
}
function hl(s, t) {
  var e = t * t, n = e * e;
  return [
    s * (0.8707 - 0.131979 * e + n * (-0.013791 + n * (3971e-6 * e - 1529e-6 * n))),
    t * (1.007226 + e * (0.015085 + n * (-0.044475 + 0.028874 * e - 5916e-6 * n)))
  ];
}
hl.invert = function(s, t) {
  var e = t, n = 25, i;
  do {
    var r = e * e, a = r * r;
    e -= i = (e * (1.007226 + r * (0.015085 + a * (-0.044475 + 0.028874 * r - 5916e-6 * a))) - t) / (1.007226 + r * (0.015085 * 3 + a * (-0.044475 * 7 + 0.028874 * 9 * r - 5916e-6 * 11 * a)));
  } while (ft(i) > pt && --n > 0);
  return [
    s / (0.8707 + (r = e * e) * (-0.131979 + r * (-0.013791 + r * r * r * (3971e-6 - 1529e-6 * r)))),
    e
  ];
};
function wh() {
  return Ds(hl).scale(175.295);
}
function Lh(s, t) {
  return s.parent === t.parent ? 1 : 2;
}
function Ah(s) {
  return s.reduce(Mh, 0) / s.length;
}
function Mh(s, t) {
  return s + t.x;
}
function _h(s) {
  return 1 + s.reduce(Ch, 0);
}
function Ch(s, t) {
  return Math.max(s, t.y);
}
function kh(s) {
  for (var t; t = s.children; ) s = t[0];
  return s;
}
function Rh(s) {
  for (var t; t = s.children; ) s = t[t.length - 1];
  return s;
}
function Ih() {
  var s = Lh, t = 1, e = 1, n = !1;
  function i(r) {
    var a, o = 0;
    r.eachAfter(function(u) {
      var p = u.children;
      p ? (u.x = Ah(p), u.y = _h(p)) : (u.x = a ? o += s(u, a) : 0, u.y = 0, a = u);
    });
    var c = kh(r), l = Rh(r), h = c.x - s(c, l) / 2, d = l.x + s(l, c) / 2;
    return r.eachAfter(n ? function(u) {
      u.x = (u.x - r.x) * t, u.y = (r.y - u.y) * e;
    } : function(u) {
      u.x = (u.x - h) / (d - h) * t, u.y = (1 - (r.y ? u.y / r.y : 1)) * e;
    });
  }
  return i.separation = function(r) {
    return arguments.length ? (s = r, i) : s;
  }, i.size = function(r) {
    return arguments.length ? (n = !1, t = +r[0], e = +r[1], i) : n ? null : [t, e];
  }, i.nodeSize = function(r) {
    return arguments.length ? (n = !0, t = +r[0], e = +r[1], i) : n ? [t, e] : null;
  }, i;
}
function Dh(s) {
  var t = 0, e = s.children, n = e && e.length;
  if (!n) t = 1;
  else for (; --n >= 0; ) t += e[n].value;
  s.value = t;
}
function Ph() {
  return this.eachAfter(Dh);
}
function Nh(s, t) {
  let e = -1;
  for (const n of this)
    s.call(t, n, ++e, this);
  return this;
}
function $h(s, t) {
  for (var e = this, n = [e], i, r, a = -1; e = n.pop(); )
    if (s.call(t, e, ++a, this), i = e.children)
      for (r = i.length - 1; r >= 0; --r)
        n.push(i[r]);
  return this;
}
function Vh(s, t) {
  for (var e = this, n = [e], i = [], r, a, o, c = -1; e = n.pop(); )
    if (i.push(e), r = e.children)
      for (a = 0, o = r.length; a < o; ++a)
        n.push(r[a]);
  for (; e = i.pop(); )
    s.call(t, e, ++c, this);
  return this;
}
function Bh(s, t) {
  let e = -1;
  for (const n of this)
    if (s.call(t, n, ++e, this))
      return n;
}
function Gh(s) {
  return this.eachAfter(function(t) {
    for (var e = +s(t.data) || 0, n = t.children, i = n && n.length; --i >= 0; ) e += n[i].value;
    t.value = e;
  });
}
function Hh(s) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(s);
  });
}
function Uh(s) {
  for (var t = this, e = zh(t, s), n = [t]; t !== e; )
    t = t.parent, n.push(t);
  for (var i = n.length; s !== e; )
    n.splice(i, 0, s), s = s.parent;
  return n;
}
function zh(s, t) {
  if (s === t) return s;
  var e = s.ancestors(), n = t.ancestors(), i = null;
  for (s = e.pop(), t = n.pop(); s === t; )
    i = s, s = e.pop(), t = n.pop();
  return i;
}
function Fh() {
  for (var s = this, t = [s]; s = s.parent; )
    t.push(s);
  return t;
}
function Wh() {
  return Array.from(this);
}
function Xh() {
  var s = [];
  return this.eachBefore(function(t) {
    t.children || s.push(t);
  }), s;
}
function jh() {
  var s = this, t = [];
  return s.each(function(e) {
    e !== s && t.push({ source: e.parent, target: e });
  }), t;
}
function* Yh() {
  var s = this, t, e = [s], n, i, r;
  do
    for (t = e.reverse(), e = []; s = t.pop(); )
      if (yield s, n = s.children)
        for (i = 0, r = n.length; i < r; ++i)
          e.push(n[i]);
  while (e.length);
}
function Pn(s, t) {
  s instanceof Map ? (s = [void 0, s], t === void 0 && (t = Kh)) : t === void 0 && (t = Zh);
  for (var e = new In(s), n, i = [e], r, a, o, c; n = i.pop(); )
    if ((a = t(n.data)) && (c = (a = Array.from(a)).length))
      for (n.children = a, o = c - 1; o >= 0; --o)
        i.push(r = a[o] = new In(a[o])), r.parent = n, r.depth = n.depth + 1;
  return e.eachBefore(Qh);
}
function qh() {
  return Pn(this).eachBefore(Jh);
}
function Zh(s) {
  return s.children;
}
function Kh(s) {
  return Array.isArray(s) ? s[1] : null;
}
function Jh(s) {
  s.data.value !== void 0 && (s.value = s.data.value), s.data = s.data.data;
}
function Qh(s) {
  var t = 0;
  do
    s.height = t;
  while ((s = s.parent) && s.height < ++t);
}
function In(s) {
  this.data = s, this.depth = this.height = 0, this.parent = null;
}
In.prototype = Pn.prototype = {
  constructor: In,
  count: Ph,
  each: Nh,
  eachAfter: Vh,
  eachBefore: $h,
  find: Bh,
  sum: Gh,
  sort: Hh,
  path: Uh,
  ancestors: Fh,
  descendants: Wh,
  leaves: Xh,
  links: jh,
  copy: qh,
  [Symbol.iterator]: Yh
};
function td(s) {
  return s == null ? null : dl(s);
}
function dl(s) {
  if (typeof s != "function") throw new Error();
  return s;
}
function Ce() {
  return 0;
}
function Ye(s) {
  return function() {
    return s;
  };
}
const ed = 1664525, nd = 1013904223, Ra = 4294967296;
function sd() {
  let s = 1;
  return () => (s = (ed * s + nd) % Ra) / Ra;
}
function id(s) {
  return typeof s == "object" && "length" in s ? s : Array.from(s);
}
function rd(s, t) {
  let e = s.length, n, i;
  for (; e; )
    i = t() * e-- | 0, n = s[e], s[e] = s[i], s[i] = n;
  return s;
}
function ad(s, t) {
  for (var e = 0, n = (s = rd(Array.from(s), t)).length, i = [], r, a; e < n; )
    r = s[e], a && pl(a, r) ? ++e : (a = ld(i = od(i, r)), e = 0);
  return a;
}
function od(s, t) {
  var e, n;
  if (ri(t, s)) return [t];
  for (e = 0; e < s.length; ++e)
    if (Yn(t, s[e]) && ri(Tn(s[e], t), s))
      return [s[e], t];
  for (e = 0; e < s.length - 1; ++e)
    for (n = e + 1; n < s.length; ++n)
      if (Yn(Tn(s[e], s[n]), t) && Yn(Tn(s[e], t), s[n]) && Yn(Tn(s[n], t), s[e]) && ri(fl(s[e], s[n], t), s))
        return [s[e], s[n], t];
  throw new Error();
}
function Yn(s, t) {
  var e = s.r - t.r, n = t.x - s.x, i = t.y - s.y;
  return e < 0 || e * e < n * n + i * i;
}
function pl(s, t) {
  var e = s.r - t.r + Math.max(s.r, t.r, 1) * 1e-9, n = t.x - s.x, i = t.y - s.y;
  return e > 0 && e * e > n * n + i * i;
}
function ri(s, t) {
  for (var e = 0; e < t.length; ++e)
    if (!pl(s, t[e]))
      return !1;
  return !0;
}
function ld(s) {
  switch (s.length) {
    case 1:
      return cd(s[0]);
    case 2:
      return Tn(s[0], s[1]);
    case 3:
      return fl(s[0], s[1], s[2]);
  }
}
function cd(s) {
  return {
    x: s.x,
    y: s.y,
    r: s.r
  };
}
function Tn(s, t) {
  var e = s.x, n = s.y, i = s.r, r = t.x, a = t.y, o = t.r, c = r - e, l = a - n, h = o - i, d = Math.sqrt(c * c + l * l);
  return {
    x: (e + r + c / d * h) / 2,
    y: (n + a + l / d * h) / 2,
    r: (d + i + o) / 2
  };
}
function fl(s, t, e) {
  var n = s.x, i = s.y, r = s.r, a = t.x, o = t.y, c = t.r, l = e.x, h = e.y, d = e.r, u = n - a, p = n - l, f = i - o, g = i - h, m = c - r, E = d - r, y = n * n + i * i - r * r, v = y - a * a - o * o + c * c, S = y - l * l - h * h + d * d, b = p * f - u * g, O = (f * S - g * v) / (b * 2) - n, I = (g * m - f * E) / b, k = (p * v - u * S) / (b * 2) - i, G = (u * E - p * m) / b, C = I * I + G * G - 1, L = 2 * (r + O * I + k * G), B = O * O + k * k - r * r, D = -(Math.abs(C) > 1e-6 ? (L + Math.sqrt(L * L - 4 * C * B)) / (2 * C) : B / L);
  return {
    x: n + O + I * D,
    y: i + k + G * D,
    r: D
  };
}
function Ia(s, t, e) {
  var n = s.x - t.x, i, r, a = s.y - t.y, o, c, l = n * n + a * a;
  l ? (r = t.r + e.r, r *= r, c = s.r + e.r, c *= c, r > c ? (i = (l + c - r) / (2 * l), o = Math.sqrt(Math.max(0, c / l - i * i)), e.x = s.x - i * n - o * a, e.y = s.y - i * a + o * n) : (i = (l + r - c) / (2 * l), o = Math.sqrt(Math.max(0, r / l - i * i)), e.x = t.x + i * n - o * a, e.y = t.y + i * a + o * n)) : (e.x = t.x + e.r, e.y = t.y);
}
function Da(s, t) {
  var e = s.r + t.r - 1e-6, n = t.x - s.x, i = t.y - s.y;
  return e > 0 && e * e > n * n + i * i;
}
function Pa(s) {
  var t = s._, e = s.next._, n = t.r + e.r, i = (t.x * e.r + e.x * t.r) / n, r = (t.y * e.r + e.y * t.r) / n;
  return i * i + r * r;
}
function qn(s) {
  this._ = s, this.next = null, this.previous = null;
}
function ud(s, t) {
  if (!(r = (s = id(s)).length)) return 0;
  var e, n, i, r, a, o, c, l, h, d, u;
  if (e = s[0], e.x = 0, e.y = 0, !(r > 1)) return e.r;
  if (n = s[1], e.x = -n.r, n.x = e.r, n.y = 0, !(r > 2)) return e.r + n.r;
  Ia(n, e, i = s[2]), e = new qn(e), n = new qn(n), i = new qn(i), e.next = i.previous = n, n.next = e.previous = i, i.next = n.previous = e;
  t: for (c = 3; c < r; ++c) {
    Ia(e._, n._, i = s[c]), i = new qn(i), l = n.next, h = e.previous, d = n._.r, u = e._.r;
    do
      if (d <= u) {
        if (Da(l._, i._)) {
          n = l, e.next = n, n.previous = e, --c;
          continue t;
        }
        d += l._.r, l = l.next;
      } else {
        if (Da(h._, i._)) {
          e = h, e.next = n, n.previous = e, --c;
          continue t;
        }
        u += h._.r, h = h.previous;
      }
    while (l !== h.next);
    for (i.previous = e, i.next = n, e.next = n.previous = n = i, a = Pa(e); (i = i.next) !== n; )
      (o = Pa(i)) < a && (e = i, a = o);
    n = e.next;
  }
  for (e = [n._], i = n; (i = i.next) !== n; ) e.push(i._);
  for (i = ad(e, t), c = 0; c < r; ++c) e = s[c], e.x -= i.x, e.y -= i.y;
  return i.r;
}
function hd(s) {
  return Math.sqrt(s.value);
}
function dd() {
  var s = null, t = 1, e = 1, n = Ce;
  function i(r) {
    const a = sd();
    return r.x = t / 2, r.y = e / 2, s ? r.eachBefore(Na(s)).eachAfter(ai(n, 0.5, a)).eachBefore($a(1)) : r.eachBefore(Na(hd)).eachAfter(ai(Ce, 1, a)).eachAfter(ai(n, r.r / Math.min(t, e), a)).eachBefore($a(Math.min(t, e) / (2 * r.r))), r;
  }
  return i.radius = function(r) {
    return arguments.length ? (s = td(r), i) : s;
  }, i.size = function(r) {
    return arguments.length ? (t = +r[0], e = +r[1], i) : [t, e];
  }, i.padding = function(r) {
    return arguments.length ? (n = typeof r == "function" ? r : Ye(+r), i) : n;
  }, i;
}
function Na(s) {
  return function(t) {
    t.children || (t.r = Math.max(0, +s(t) || 0));
  };
}
function ai(s, t, e) {
  return function(n) {
    if (i = n.children) {
      var i, r, a = i.length, o = s(n) * t || 0, c;
      if (o) for (r = 0; r < a; ++r) i[r].r += o;
      if (c = ud(i, e), o) for (r = 0; r < a; ++r) i[r].r -= o;
      n.r = c + o;
    }
  };
}
function $a(s) {
  return function(t) {
    var e = t.parent;
    t.r *= s, e && (t.x = e.x + s * t.x, t.y = e.y + s * t.y);
  };
}
function pd(s) {
  s.x0 = Math.round(s.x0), s.y0 = Math.round(s.y0), s.x1 = Math.round(s.x1), s.y1 = Math.round(s.y1);
}
function fd(s, t, e, n, i) {
  for (var r = s.children, a, o = -1, c = r.length, l = s.value && (n - t) / s.value; ++o < c; )
    a = r[o], a.y0 = e, a.y1 = i, a.x0 = t, a.x1 = t += a.value * l;
}
function gd(s, t) {
  return s.parent === t.parent ? 1 : 2;
}
function oi(s) {
  var t = s.children;
  return t ? t[0] : s.t;
}
function li(s) {
  var t = s.children;
  return t ? t[t.length - 1] : s.t;
}
function md(s, t, e) {
  var n = e / (t.i - s.i);
  t.c -= n, t.s += e, s.c += n, t.z += e, t.m += e;
}
function vd(s) {
  for (var t = 0, e = 0, n = s.children, i = n.length, r; --i >= 0; )
    r = n[i], r.z += t, r.m += t, t += r.s + (e += r.c);
}
function yd(s, t, e) {
  return s.a.parent === t.parent ? s.a : e;
}
function os(s, t) {
  this._ = s, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
os.prototype = Object.create(In.prototype);
function Ed(s) {
  for (var t = new os(s, 0), e, n = [t], i, r, a, o; e = n.pop(); )
    if (r = e._.children)
      for (e.children = new Array(o = r.length), a = o - 1; a >= 0; --a)
        n.push(i = e.children[a] = new os(r[a], a)), i.parent = e;
  return (t.parent = new os(null, 0)).children = [t], t;
}
function Sd() {
  var s = gd, t = 1, e = 1, n = null;
  function i(l) {
    var h = Ed(l);
    if (h.eachAfter(r), h.parent.m = -h.z, h.eachBefore(a), n) l.eachBefore(c);
    else {
      var d = l, u = l, p = l;
      l.eachBefore(function(y) {
        y.x < d.x && (d = y), y.x > u.x && (u = y), y.depth > p.depth && (p = y);
      });
      var f = d === u ? 1 : s(d, u) / 2, g = f - d.x, m = t / (u.x + f + g), E = e / (p.depth || 1);
      l.eachBefore(function(y) {
        y.x = (y.x + g) * m, y.y = y.depth * E;
      });
    }
    return l;
  }
  function r(l) {
    var h = l.children, d = l.parent.children, u = l.i ? d[l.i - 1] : null;
    if (h) {
      vd(l);
      var p = (h[0].z + h[h.length - 1].z) / 2;
      u ? (l.z = u.z + s(l._, u._), l.m = l.z - p) : l.z = p;
    } else u && (l.z = u.z + s(l._, u._));
    l.parent.A = o(l, u, l.parent.A || d[0]);
  }
  function a(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function o(l, h, d) {
    if (h) {
      for (var u = l, p = l, f = h, g = u.parent.children[0], m = u.m, E = p.m, y = f.m, v = g.m, S; f = li(f), u = oi(u), f && u; )
        g = oi(g), p = li(p), p.a = l, S = f.z + y - u.z - m + s(f._, u._), S > 0 && (md(yd(f, l, d), l, S), m += S, E += S), y += f.m, m += u.m, v += g.m, E += p.m;
      f && !li(p) && (p.t = f, p.m += y - E), u && !oi(g) && (g.t = u, g.m += m - v, d = l);
    }
    return d;
  }
  function c(l) {
    l.x *= t, l.y = l.depth * e;
  }
  return i.separation = function(l) {
    return arguments.length ? (s = l, i) : s;
  }, i.size = function(l) {
    return arguments.length ? (n = !1, t = +l[0], e = +l[1], i) : n ? null : [t, e];
  }, i.nodeSize = function(l) {
    return arguments.length ? (n = !0, t = +l[0], e = +l[1], i) : n ? [t, e] : null;
  }, i;
}
function xd(s, t, e, n, i) {
  for (var r = s.children, a, o = -1, c = r.length, l = s.value && (i - e) / s.value; ++o < c; )
    a = r[o], a.x0 = t, a.x1 = n, a.y0 = e, a.y1 = e += a.value * l;
}
var bd = (1 + Math.sqrt(5)) / 2;
function Td(s, t, e, n, i, r) {
  for (var a = [], o = t.children, c, l, h = 0, d = 0, u = o.length, p, f, g = t.value, m, E, y, v, S, b, O; h < u; ) {
    p = i - e, f = r - n;
    do
      m = o[d++].value;
    while (!m && d < u);
    for (E = y = m, b = Math.max(f / p, p / f) / (g * s), O = m * m * b, S = Math.max(y / O, O / E); d < u; ++d) {
      if (m += l = o[d].value, l < E && (E = l), l > y && (y = l), O = m * m * b, v = Math.max(y / O, O / E), v > S) {
        m -= l;
        break;
      }
      S = v;
    }
    a.push(c = { value: m, dice: p < f, children: o.slice(h, d) }), c.dice ? fd(c, e, n, i, g ? n += f * m / g : r) : xd(c, e, n, g ? e += p * m / g : i, r), g -= m, h = d;
  }
  return a;
}
const Od = function s(t) {
  function e(n, i, r, a, o) {
    Td(t, n, i, r, a, o);
  }
  return e.ratio = function(n) {
    return s((n = +n) > 1 ? n : 1);
  }, e;
}(bd);
function wd() {
  var s = Od, t = !1, e = 1, n = 1, i = [0], r = Ce, a = Ce, o = Ce, c = Ce, l = Ce;
  function h(u) {
    return u.x0 = u.y0 = 0, u.x1 = e, u.y1 = n, u.eachBefore(d), i = [0], t && u.eachBefore(pd), u;
  }
  function d(u) {
    var p = i[u.depth], f = u.x0 + p, g = u.y0 + p, m = u.x1 - p, E = u.y1 - p;
    m < f && (f = m = (f + m) / 2), E < g && (g = E = (g + E) / 2), u.x0 = f, u.y0 = g, u.x1 = m, u.y1 = E, u.children && (p = i[u.depth + 1] = r(u) / 2, f += l(u) - p, g += a(u) - p, m -= o(u) - p, E -= c(u) - p, m < f && (f = m = (f + m) / 2), E < g && (g = E = (g + E) / 2), s(u, f, g, m, E));
  }
  return h.round = function(u) {
    return arguments.length ? (t = !!u, h) : t;
  }, h.size = function(u) {
    return arguments.length ? (e = +u[0], n = +u[1], h) : [e, n];
  }, h.tile = function(u) {
    return arguments.length ? (s = dl(u), h) : s;
  }, h.padding = function(u) {
    return arguments.length ? h.paddingInner(u).paddingOuter(u) : h.paddingInner();
  }, h.paddingInner = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ye(+u), h) : r;
  }, h.paddingOuter = function(u) {
    return arguments.length ? h.paddingTop(u).paddingRight(u).paddingBottom(u).paddingLeft(u) : h.paddingTop();
  }, h.paddingTop = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Ye(+u), h) : a;
  }, h.paddingRight = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : Ye(+u), h) : o;
  }, h.paddingBottom = function(u) {
    return arguments.length ? (c = typeof u == "function" ? u : Ye(+u), h) : c;
  }, h.paddingLeft = function(u) {
    return arguments.length ? (l = typeof u == "function" ? u : Ye(+u), h) : l;
  }, h;
}
function Ps(s) {
  let t = 3;
  return s.digits = function(e) {
    if (!arguments.length) return t;
    if (e == null)
      t = null;
    else {
      const n = Math.floor(e);
      if (!(n >= 0)) throw new RangeError(`invalid digits: ${e}`);
      t = n;
    }
    return s;
  }, () => new dr(t);
}
function Ld(s) {
  return s.innerRadius;
}
function Ad(s) {
  return s.outerRadius;
}
function Md(s) {
  return s.startAngle;
}
function _d(s) {
  return s.endAngle;
}
function Cd(s) {
  return s && s.padAngle;
}
function kd(s, t, e, n, i, r, a, o) {
  var c = e - s, l = n - t, h = a - i, d = o - r, u = d * c - h * l;
  if (!(u * u < Gt))
    return u = (h * (t - r) - d * (s - i)) / u, [s + u * c, t + u * l];
}
function Zn(s, t, e, n, i, r, a) {
  var o = s - e, c = t - n, l = (a ? r : -r) / Ke(o * o + c * c), h = l * c, d = -l * o, u = s + h, p = t + d, f = e + h, g = n + d, m = (u + f) / 2, E = (p + g) / 2, y = f - u, v = g - p, S = y * y + v * v, b = i - r, O = u * g - f * p, I = (v < 0 ? -1 : 1) * Ke(ic(0, b * b * S - O * O)), k = (O * v - y * I) / S, G = (-O * y - v * I) / S, C = (O * v + y * I) / S, L = (-O * y + v * I) / S, B = k - m, D = G - E, A = C - m, w = L - E;
  return B * B + D * D > A * A + w * w && (k = C, G = L), {
    cx: k,
    cy: G,
    x01: -h,
    y01: -d,
    x11: k * (i / b - 1),
    y11: G * (i / b - 1)
  };
}
function Dn() {
  var s = Ld, t = Ad, e = lt(0), n = null, i = Md, r = _d, a = Cd, o = null, c = Ps(l);
  function l() {
    var h, d, u = +s.apply(this, arguments), p = +t.apply(this, arguments), f = i.apply(this, arguments) - Kr, g = r.apply(this, arguments) - Kr, m = Jr(g - f), E = g > f;
    if (o || (o = h = c()), p < u && (d = p, p = u, u = d), !(p > Gt)) o.moveTo(0, 0);
    else if (m > ns - Gt)
      o.moveTo(p * Le(f), p * oe(f)), o.arc(0, 0, p, f, g, !E), u > Gt && (o.moveTo(u * Le(g), u * oe(g)), o.arc(0, 0, u, g, f, E));
    else {
      var y = f, v = g, S = f, b = g, O = m, I = m, k = a.apply(this, arguments) / 2, G = k > Gt && (n ? +n.apply(this, arguments) : Ke(u * u + p * p)), C = qs(Jr(p - u) / 2, +e.apply(this, arguments)), L = C, B = C, D, A;
      if (G > Gt) {
        var w = Qr(G / u * oe(k)), V = Qr(G / p * oe(k));
        (O -= w * 2) > Gt ? (w *= E ? 1 : -1, S += w, b -= w) : (O = 0, S = b = (f + g) / 2), (I -= V * 2) > Gt ? (V *= E ? 1 : -1, y += V, v -= V) : (I = 0, y = v = (f + g) / 2);
      }
      var N = p * Le(y), P = p * oe(y), $ = u * Le(b), X = u * oe(b);
      if (C > Gt) {
        var F = p * Le(v), et = p * oe(v), J = u * Le(S), ct = u * oe(S), Q;
        if (m < Zr)
          if (Q = kd(N, P, J, ct, F, et, $, X)) {
            var j = N - Q[0], Z = P - Q[1], ut = F - Q[0], ht = et - Q[1], Et = 1 / oe(sc((j * ut + Z * ht) / (Ke(j * j + Z * Z) * Ke(ut * ut + ht * ht))) / 2), Ut = Ke(Q[0] * Q[0] + Q[1] * Q[1]);
            L = qs(C, (u - Ut) / (Et - 1)), B = qs(C, (p - Ut) / (Et + 1));
          } else
            L = B = 0;
      }
      I > Gt ? B > Gt ? (D = Zn(J, ct, N, P, p, B, E), A = Zn(F, et, $, X, p, B, E), o.moveTo(D.cx + D.x01, D.cy + D.y01), B < C ? o.arc(D.cx, D.cy, B, kt(D.y01, D.x01), kt(A.y01, A.x01), !E) : (o.arc(D.cx, D.cy, B, kt(D.y01, D.x01), kt(D.y11, D.x11), !E), o.arc(0, 0, p, kt(D.cy + D.y11, D.cx + D.x11), kt(A.cy + A.y11, A.cx + A.x11), !E), o.arc(A.cx, A.cy, B, kt(A.y11, A.x11), kt(A.y01, A.x01), !E))) : (o.moveTo(N, P), o.arc(0, 0, p, y, v, !E)) : o.moveTo(N, P), !(u > Gt) || !(O > Gt) ? o.lineTo($, X) : L > Gt ? (D = Zn($, X, F, et, u, -L, E), A = Zn(N, P, J, ct, u, -L, E), o.lineTo(D.cx + D.x01, D.cy + D.y01), L < C ? o.arc(D.cx, D.cy, L, kt(D.y01, D.x01), kt(A.y01, A.x01), !E) : (o.arc(D.cx, D.cy, L, kt(D.y01, D.x01), kt(D.y11, D.x11), !E), o.arc(0, 0, u, kt(D.cy + D.y11, D.cx + D.x11), kt(A.cy + A.y11, A.cx + A.x11), E), o.arc(A.cx, A.cy, L, kt(A.y11, A.x11), kt(A.y01, A.x01), !E))) : o.arc(0, 0, u, b, S, E);
    }
    if (o.closePath(), h) return o = null, h + "" || null;
  }
  return l.centroid = function() {
    var h = (+s.apply(this, arguments) + +t.apply(this, arguments)) / 2, d = (+i.apply(this, arguments) + +r.apply(this, arguments)) / 2 - Zr / 2;
    return [Le(d) * h, oe(d) * h];
  }, l.innerRadius = function(h) {
    return arguments.length ? (s = typeof h == "function" ? h : lt(+h), l) : s;
  }, l.outerRadius = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : lt(+h), l) : t;
  }, l.cornerRadius = function(h) {
    return arguments.length ? (e = typeof h == "function" ? h : lt(+h), l) : e;
  }, l.padRadius = function(h) {
    return arguments.length ? (n = h == null ? null : typeof h == "function" ? h : lt(+h), l) : n;
  }, l.startAngle = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : lt(+h), l) : i;
  }, l.endAngle = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : lt(+h), l) : r;
  }, l.padAngle = function(h) {
    return arguments.length ? (a = typeof h == "function" ? h : lt(+h), l) : a;
  }, l.context = function(h) {
    return arguments.length ? (o = h ?? null, l) : o;
  }, l;
}
function mr(s) {
  return s[0];
}
function vr(s) {
  return s[1];
}
function Nn(s, t) {
  var e = lt(!0), n = null, i = lr, r = null, a = Ps(o);
  s = typeof s == "function" ? s : s === void 0 ? mr : lt(s), t = typeof t == "function" ? t : t === void 0 ? vr : lt(t);
  function o(c) {
    var l, h = (c = ur(c)).length, d, u = !1, p;
    for (n == null && (r = i(p = a())), l = 0; l <= h; ++l)
      !(l < h && e(d = c[l], l, c)) === u && ((u = !u) ? r.lineStart() : r.lineEnd()), u && r.point(+s(d, l, c), +t(d, l, c));
    if (p) return r = null, p + "" || null;
  }
  return o.x = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : lt(+c), o) : s;
  }, o.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : lt(+c), o) : t;
  }, o.defined = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : lt(!!c), o) : e;
  }, o.curve = function(c) {
    return arguments.length ? (i = c, n != null && (r = i(n)), o) : i;
  }, o.context = function(c) {
    return arguments.length ? (c == null ? n = r = null : r = i(n = c), o) : n;
  }, o;
}
function yr(s, t, e) {
  var n = null, i = lt(!0), r = null, a = lr, o = null, c = Ps(l);
  s = typeof s == "function" ? s : s === void 0 ? mr : lt(+s), t = typeof t == "function" ? t : t === void 0 ? lt(0) : lt(+t), e = typeof e == "function" ? e : e === void 0 ? vr : lt(+e);
  function l(d) {
    var u, p, f, g = (d = ur(d)).length, m, E = !1, y, v = new Array(g), S = new Array(g);
    for (r == null && (o = a(y = c())), u = 0; u <= g; ++u) {
      if (!(u < g && i(m = d[u], u, d)) === E)
        if (E = !E)
          p = u, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = u - 1; f >= p; --f)
            o.point(v[f], S[f]);
          o.lineEnd(), o.areaEnd();
        }
      E && (v[u] = +s(m, u, d), S[u] = +t(m, u, d), o.point(n ? +n(m, u, d) : v[u], e ? +e(m, u, d) : S[u]));
    }
    if (y) return o = null, y + "" || null;
  }
  function h() {
    return Nn().defined(i).curve(a).context(r);
  }
  return l.x = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : lt(+d), n = null, l) : s;
  }, l.x0 = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : lt(+d), l) : s;
  }, l.x1 = function(d) {
    return arguments.length ? (n = d == null ? null : typeof d == "function" ? d : lt(+d), l) : n;
  }, l.y = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : lt(+d), e = null, l) : t;
  }, l.y0 = function(d) {
    return arguments.length ? (t = typeof d == "function" ? d : lt(+d), l) : t;
  }, l.y1 = function(d) {
    return arguments.length ? (e = d == null ? null : typeof d == "function" ? d : lt(+d), l) : e;
  }, l.lineX0 = l.lineY0 = function() {
    return h().x(s).y(t);
  }, l.lineY1 = function() {
    return h().x(s).y(e);
  }, l.lineX1 = function() {
    return h().x(n).y(t);
  }, l.defined = function(d) {
    return arguments.length ? (i = typeof d == "function" ? d : lt(!!d), l) : i;
  }, l.curve = function(d) {
    return arguments.length ? (a = d, r != null && (o = a(r)), l) : a;
  }, l.context = function(d) {
    return arguments.length ? (d == null ? r = o = null : o = a(r = d), l) : r;
  }, l;
}
function Rd(s, t) {
  return t < s ? -1 : t > s ? 1 : t >= s ? 0 : NaN;
}
function Id(s) {
  return s;
}
function Dd() {
  var s = Id, t = Rd, e = null, n = lt(0), i = lt(ns), r = lt(0);
  function a(o) {
    var c, l = (o = ur(o)).length, h, d, u = 0, p = new Array(l), f = new Array(l), g = +n.apply(this, arguments), m = Math.min(ns, Math.max(-ns, i.apply(this, arguments) - g)), E, y = Math.min(Math.abs(m) / l, r.apply(this, arguments)), v = y * (m < 0 ? -1 : 1), S;
    for (c = 0; c < l; ++c)
      (S = f[p[c] = c] = +s(o[c], c, o)) > 0 && (u += S);
    for (t != null ? p.sort(function(b, O) {
      return t(f[b], f[O]);
    }) : e != null && p.sort(function(b, O) {
      return e(o[b], o[O]);
    }), c = 0, d = u ? (m - l * v) / u : 0; c < l; ++c, g = E)
      h = p[c], S = f[h], E = g + (S > 0 ? S * d : 0) + v, f[h] = {
        data: o[h],
        index: c,
        value: S,
        startAngle: g,
        endAngle: E,
        padAngle: y
      };
    return f;
  }
  return a.value = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : lt(+o), a) : s;
  }, a.sortValues = function(o) {
    return arguments.length ? (t = o, e = null, a) : t;
  }, a.sort = function(o) {
    return arguments.length ? (e = o, t = null, a) : e;
  }, a.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : lt(+o), a) : n;
  }, a.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : lt(+o), a) : i;
  }, a.padAngle = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : lt(+o), a) : r;
  }, a;
}
var Pd = ml(lr);
function gl(s) {
  this._curve = s;
}
gl.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(s, t) {
    this._curve.point(t * Math.sin(s), t * -Math.cos(s));
  }
};
function ml(s) {
  function t(e) {
    return new gl(s(e));
  }
  return t._curve = s, t;
}
function Nd(s) {
  var t = s.curve;
  return s.angle = s.x, delete s.x, s.radius = s.y, delete s.y, s.curve = function(e) {
    return arguments.length ? t(ml(e)) : t()._curve;
  }, s;
}
function $d() {
  return Nd(Nn().curve(Pd));
}
class Vd {
  constructor(t, e) {
    this._context = t, this._x = e;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, e, t, e) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + e) / 2, t, this._y0, t, e);
        break;
      }
    }
    this._x0 = t, this._y0 = e;
  }
}
function Bd(s) {
  return new Vd(s, !0);
}
function Gd(s) {
  return s.source;
}
function Hd(s) {
  return s.target;
}
function Ud(s) {
  let t = Gd, e = Hd, n = mr, i = vr, r = null, a = null, o = Ps(c);
  function c() {
    let l;
    const h = cc.call(arguments), d = t.apply(this, h), u = e.apply(this, h);
    if (r == null && (a = s(l = o())), a.lineStart(), h[0] = d, a.point(+n.apply(this, h), +i.apply(this, h)), h[0] = u, a.point(+n.apply(this, h), +i.apply(this, h)), a.lineEnd(), l) return a = null, l + "" || null;
  }
  return c.source = function(l) {
    return arguments.length ? (t = l, c) : t;
  }, c.target = function(l) {
    return arguments.length ? (e = l, c) : e;
  }, c.x = function(l) {
    return arguments.length ? (n = typeof l == "function" ? l : lt(+l), c) : n;
  }, c.y = function(l) {
    return arguments.length ? (i = typeof l == "function" ? l : lt(+l), c) : i;
  }, c.context = function(l) {
    return arguments.length ? (l == null ? r = a = null : a = s(r = l), c) : r;
  }, c;
}
function zd() {
  return Ud(Bd);
}
class ot {
  constructor(t, e, n) {
    if (this.type = "", this.renderType = st.HTML, this.id = "", this.parent = void 0, this.configs = {}, this.model = t, this.services = e, n && (this.configs = n, this.configs.id)) {
      const i = T(this.model.getOptions(), "style", "prefix");
      this.id = `${i}--${this.configs.id}`;
    }
    this.parent || this.setParent(
      R(
        this.services.domUtils.getMainContainer()
      )
    );
  }
  init() {
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    console.error("Error: Component did not provide the required render function.");
  }
  destroy() {
  }
  // Used to pass down information to the components
  setModel(t) {
    this.model = t;
  }
  // Used to pass down information to the components
  setServices(t) {
    this.services = t;
  }
  setParent(t) {
    var n;
    const e = this.parent;
    if (this.parent = t, !(e && e.node() === t.node()) && this.type) {
      const i = T(this.model.getOptions(), "style", "prefix");
      (n = this.parent) == null || n.classed(`${qt}--${i}--${this.type}`, !0), e && e.classed(`${qt}--${i}--${this.type}`, !1);
    }
  }
  getParent() {
    return this.parent;
  }
  getComponentContainer(t = { withinChartClip: !1 }) {
    if (this.type) {
      const e = T(this.model.getOptions(), "style", "prefix"), n = this.id ? `#${this.id}` : "", i = _.appendOrSelect(
        this.parent,
        `${this.renderType === st.SVG ? "svg" : "div"}${n}.${qt}--${e}--${this.type}`
      );
      if (t.withinChartClip) {
        const r = this.model.get("chartClipId");
        if (r) {
          const o = R(`#${r}`).select("rect");
          o.size() !== 0 && parseFloat(o.attr("height")) > 0 && i.attr("clip-path", `url(#${r})`);
        }
      }
      return i.attr("width", "100%").attr("height", "100%");
    }
    return this.parent;
  }
  /**
   * graphs used in combo charts share a model with global options but can receive their own local options.
   * this function retrieves the global options and merges it with any options passed into this
   * component's config.options object.
   */
  getOptions() {
    return this.configs.options ? tn({}, this.model.getOptions(), this.configs.options) : this.model.getOptions();
  }
}
/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */
const {
  entries: vl,
  setPrototypeOf: Va,
  isFrozen: Fd,
  getPrototypeOf: Wd,
  getOwnPropertyDescriptor: Xd
} = Object;
let {
  freeze: Vt,
  seal: Qt,
  create: yl
} = Object, {
  apply: Ui,
  construct: zi
} = typeof Reflect < "u" && Reflect;
Vt || (Vt = function(t) {
  return t;
});
Qt || (Qt = function(t) {
  return t;
});
Ui || (Ui = function(t, e, n) {
  return t.apply(e, n);
});
zi || (zi = function(t, e) {
  return new t(...e);
});
const Kn = Xt(Array.prototype.forEach), Ba = Xt(Array.prototype.pop), hn = Xt(Array.prototype.push), ls = Xt(String.prototype.toLowerCase), ci = Xt(String.prototype.toString), Ga = Xt(String.prototype.match), dn = Xt(String.prototype.replace), jd = Xt(String.prototype.indexOf), Yd = Xt(String.prototype.trim), ne = Xt(Object.prototype.hasOwnProperty), Pt = Xt(RegExp.prototype.test), pn = qd(TypeError);
function Xt(s) {
  return function(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
      n[i - 1] = arguments[i];
    return Ui(s, t, n);
  };
}
function qd(s) {
  return function() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return zi(s, e);
  };
}
function rt(s, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ls;
  Va && Va(s, null);
  let n = t.length;
  for (; n--; ) {
    let i = t[n];
    if (typeof i == "string") {
      const r = e(i);
      r !== i && (Fd(t) || (t[n] = r), i = r);
    }
    s[i] = !0;
  }
  return s;
}
function Zd(s) {
  for (let t = 0; t < s.length; t++)
    ne(s, t) || (s[t] = null);
  return s;
}
function Me(s) {
  const t = yl(null);
  for (const [e, n] of vl(s))
    ne(s, e) && (Array.isArray(n) ? t[e] = Zd(n) : n && typeof n == "object" && n.constructor === Object ? t[e] = Me(n) : t[e] = n);
  return t;
}
function fn(s, t) {
  for (; s !== null; ) {
    const n = Xd(s, t);
    if (n) {
      if (n.get)
        return Xt(n.get);
      if (typeof n.value == "function")
        return Xt(n.value);
    }
    s = Wd(s);
  }
  function e() {
    return null;
  }
  return e;
}
const Ha = Vt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), ui = Vt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), hi = Vt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Kd = Vt(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), di = Vt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Jd = Vt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Ua = Vt(["#text"]), za = Vt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), pi = Vt(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Fa = Vt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Jn = Vt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Qd = Qt(/\{\{[\w\W]*|[\w\W]*\}\}/gm), tp = Qt(/<%[\w\W]*|[\w\W]*%>/gm), ep = Qt(/\${[\w\W]*}/gm), np = Qt(/^data-[\-\w.\u00B7-\uFFFF]/), sp = Qt(/^aria-[\-\w]+$/), El = Qt(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), ip = Qt(/^(?:\w+script|data):/i), rp = Qt(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Sl = Qt(/^html$/i), ap = Qt(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Wa = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: Qd,
  ERB_EXPR: tp,
  TMPLIT_EXPR: ep,
  DATA_ATTR: np,
  ARIA_ATTR: sp,
  IS_ALLOWED_URI: El,
  IS_SCRIPT_OR_DATA: ip,
  ATTR_WHITESPACE: rp,
  DOCTYPE_NAME: Sl,
  CUSTOM_ELEMENT: ap
});
const gn = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
}, op = function() {
  return typeof window > "u" ? null : window;
}, lp = function(t, e) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let n = null;
  const i = "data-tt-policy-suffix";
  e && e.hasAttribute(i) && (n = e.getAttribute(i));
  const r = "dompurify" + (n ? "#" + n : "");
  try {
    return t.createPolicy(r, {
      createHTML(a) {
        return a;
      },
      createScriptURL(a) {
        return a;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + r + " could not be created."), null;
  }
};
function xl() {
  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : op();
  const t = (K) => xl(K);
  if (t.version = "3.1.6", t.removed = [], !s || !s.document || s.document.nodeType !== gn.document)
    return t.isSupported = !1, t;
  let {
    document: e
  } = s;
  const n = e, i = n.currentScript, {
    DocumentFragment: r,
    HTMLTemplateElement: a,
    Node: o,
    Element: c,
    NodeFilter: l,
    NamedNodeMap: h = s.NamedNodeMap || s.MozNamedAttrMap,
    HTMLFormElement: d,
    DOMParser: u,
    trustedTypes: p
  } = s, f = c.prototype, g = fn(f, "cloneNode"), m = fn(f, "remove"), E = fn(f, "nextSibling"), y = fn(f, "childNodes"), v = fn(f, "parentNode");
  if (typeof a == "function") {
    const K = e.createElement("template");
    K.content && K.content.ownerDocument && (e = K.content.ownerDocument);
  }
  let S, b = "";
  const {
    implementation: O,
    createNodeIterator: I,
    createDocumentFragment: k,
    getElementsByTagName: G
  } = e, {
    importNode: C
  } = n;
  let L = {};
  t.isSupported = typeof vl == "function" && typeof v == "function" && O && O.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: B,
    ERB_EXPR: D,
    TMPLIT_EXPR: A,
    DATA_ATTR: w,
    ARIA_ATTR: V,
    IS_SCRIPT_OR_DATA: N,
    ATTR_WHITESPACE: P,
    CUSTOM_ELEMENT: $
  } = Wa;
  let {
    IS_ALLOWED_URI: X
  } = Wa, F = null;
  const et = rt({}, [...Ha, ...ui, ...hi, ...di, ...Ua]);
  let J = null;
  const ct = rt({}, [...za, ...pi, ...Fa, ...Jn]);
  let Q = Object.seal(yl(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), j = null, Z = null, ut = !0, ht = !0, Et = !1, Ut = !0, H = !1, U = !0, W = !1, zt = !1, an = !1, nt = !1, St = !1, ie = !1, te = !0, Tr = !1;
  const Rl = "user-content-";
  let $s = !0, on = !1, Pe = {}, Ne = null;
  const Or = rt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let wr = null;
  const Lr = rt({}, ["audio", "video", "img", "source", "image", "track"]);
  let Vs = null;
  const Ar = rt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), $n = "http://www.w3.org/1998/Math/MathML", Vn = "http://www.w3.org/2000/svg", he = "http://www.w3.org/1999/xhtml";
  let $e = he, Bs = !1, Gs = null;
  const Il = rt({}, [$n, Vn, he], ci);
  let ln = null;
  const Dl = ["application/xhtml+xml", "text/html"], Pl = "text/html";
  let Lt = null, Ve = null;
  const Nl = e.createElement("form"), Mr = function(M) {
    return M instanceof RegExp || M instanceof Function;
  }, Hs = function() {
    let M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ve && Ve === M)) {
      if ((!M || typeof M != "object") && (M = {}), M = Me(M), ln = // eslint-disable-next-line unicorn/prefer-includes
      Dl.indexOf(M.PARSER_MEDIA_TYPE) === -1 ? Pl : M.PARSER_MEDIA_TYPE, Lt = ln === "application/xhtml+xml" ? ci : ls, F = ne(M, "ALLOWED_TAGS") ? rt({}, M.ALLOWED_TAGS, Lt) : et, J = ne(M, "ALLOWED_ATTR") ? rt({}, M.ALLOWED_ATTR, Lt) : ct, Gs = ne(M, "ALLOWED_NAMESPACES") ? rt({}, M.ALLOWED_NAMESPACES, ci) : Il, Vs = ne(M, "ADD_URI_SAFE_ATTR") ? rt(
        Me(Ar),
        // eslint-disable-line indent
        M.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Lt
        // eslint-disable-line indent
      ) : Ar, wr = ne(M, "ADD_DATA_URI_TAGS") ? rt(
        Me(Lr),
        // eslint-disable-line indent
        M.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Lt
        // eslint-disable-line indent
      ) : Lr, Ne = ne(M, "FORBID_CONTENTS") ? rt({}, M.FORBID_CONTENTS, Lt) : Or, j = ne(M, "FORBID_TAGS") ? rt({}, M.FORBID_TAGS, Lt) : {}, Z = ne(M, "FORBID_ATTR") ? rt({}, M.FORBID_ATTR, Lt) : {}, Pe = ne(M, "USE_PROFILES") ? M.USE_PROFILES : !1, ut = M.ALLOW_ARIA_ATTR !== !1, ht = M.ALLOW_DATA_ATTR !== !1, Et = M.ALLOW_UNKNOWN_PROTOCOLS || !1, Ut = M.ALLOW_SELF_CLOSE_IN_ATTR !== !1, H = M.SAFE_FOR_TEMPLATES || !1, U = M.SAFE_FOR_XML !== !1, W = M.WHOLE_DOCUMENT || !1, nt = M.RETURN_DOM || !1, St = M.RETURN_DOM_FRAGMENT || !1, ie = M.RETURN_TRUSTED_TYPE || !1, an = M.FORCE_BODY || !1, te = M.SANITIZE_DOM !== !1, Tr = M.SANITIZE_NAMED_PROPS || !1, $s = M.KEEP_CONTENT !== !1, on = M.IN_PLACE || !1, X = M.ALLOWED_URI_REGEXP || El, $e = M.NAMESPACE || he, Q = M.CUSTOM_ELEMENT_HANDLING || {}, M.CUSTOM_ELEMENT_HANDLING && Mr(M.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Q.tagNameCheck = M.CUSTOM_ELEMENT_HANDLING.tagNameCheck), M.CUSTOM_ELEMENT_HANDLING && Mr(M.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Q.attributeNameCheck = M.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), M.CUSTOM_ELEMENT_HANDLING && typeof M.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Q.allowCustomizedBuiltInElements = M.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), H && (ht = !1), St && (nt = !0), Pe && (F = rt({}, Ua), J = [], Pe.html === !0 && (rt(F, Ha), rt(J, za)), Pe.svg === !0 && (rt(F, ui), rt(J, pi), rt(J, Jn)), Pe.svgFilters === !0 && (rt(F, hi), rt(J, pi), rt(J, Jn)), Pe.mathMl === !0 && (rt(F, di), rt(J, Fa), rt(J, Jn))), M.ADD_TAGS && (F === et && (F = Me(F)), rt(F, M.ADD_TAGS, Lt)), M.ADD_ATTR && (J === ct && (J = Me(J)), rt(J, M.ADD_ATTR, Lt)), M.ADD_URI_SAFE_ATTR && rt(Vs, M.ADD_URI_SAFE_ATTR, Lt), M.FORBID_CONTENTS && (Ne === Or && (Ne = Me(Ne)), rt(Ne, M.FORBID_CONTENTS, Lt)), $s && (F["#text"] = !0), W && rt(F, ["html", "head", "body"]), F.table && (rt(F, ["tbody"]), delete j.tbody), M.TRUSTED_TYPES_POLICY) {
        if (typeof M.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw pn('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof M.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw pn('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        S = M.TRUSTED_TYPES_POLICY, b = S.createHTML("");
      } else
        S === void 0 && (S = lp(p, i)), S !== null && typeof b == "string" && (b = S.createHTML(""));
      Vt && Vt(M), Ve = M;
    }
  }, _r = rt({}, ["mi", "mo", "mn", "ms", "mtext"]), Cr = rt({}, ["foreignobject", "annotation-xml"]), $l = rt({}, ["title", "style", "font", "a", "script"]), kr = rt({}, [...ui, ...hi, ...Kd]), Rr = rt({}, [...di, ...Jd]), Vl = function(M) {
    let z = v(M);
    (!z || !z.tagName) && (z = {
      namespaceURI: $e,
      tagName: "template"
    });
    const q = ls(M.tagName), mt = ls(z.tagName);
    return Gs[M.namespaceURI] ? M.namespaceURI === Vn ? z.namespaceURI === he ? q === "svg" : z.namespaceURI === $n ? q === "svg" && (mt === "annotation-xml" || _r[mt]) : !!kr[q] : M.namespaceURI === $n ? z.namespaceURI === he ? q === "math" : z.namespaceURI === Vn ? q === "math" && Cr[mt] : !!Rr[q] : M.namespaceURI === he ? z.namespaceURI === Vn && !Cr[mt] || z.namespaceURI === $n && !_r[mt] ? !1 : !Rr[q] && ($l[q] || !kr[q]) : !!(ln === "application/xhtml+xml" && Gs[M.namespaceURI]) : !1;
  }, re = function(M) {
    hn(t.removed, {
      element: M
    });
    try {
      v(M).removeChild(M);
    } catch {
      m(M);
    }
  }, Bn = function(M, z) {
    try {
      hn(t.removed, {
        attribute: z.getAttributeNode(M),
        from: z
      });
    } catch {
      hn(t.removed, {
        attribute: null,
        from: z
      });
    }
    if (z.removeAttribute(M), M === "is" && !J[M])
      if (nt || St)
        try {
          re(z);
        } catch {
        }
      else
        try {
          z.setAttribute(M, "");
        } catch {
        }
  }, Ir = function(M) {
    let z = null, q = null;
    if (an)
      M = "<remove></remove>" + M;
    else {
      const At = Ga(M, /^[\r\n\t ]+/);
      q = At && At[0];
    }
    ln === "application/xhtml+xml" && $e === he && (M = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + M + "</body></html>");
    const mt = S ? S.createHTML(M) : M;
    if ($e === he)
      try {
        z = new u().parseFromString(mt, ln);
      } catch {
      }
    if (!z || !z.documentElement) {
      z = O.createDocument($e, "template", null);
      try {
        z.documentElement.innerHTML = Bs ? b : mt;
      } catch {
      }
    }
    const Ct = z.body || z.documentElement;
    return M && q && Ct.insertBefore(e.createTextNode(q), Ct.childNodes[0] || null), $e === he ? G.call(z, W ? "html" : "body")[0] : W ? z.documentElement : Ct;
  }, Dr = function(M) {
    return I.call(
      M.ownerDocument || M,
      M,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION,
      null
    );
  }, Pr = function(M) {
    return M instanceof d && (typeof M.nodeName != "string" || typeof M.textContent != "string" || typeof M.removeChild != "function" || !(M.attributes instanceof h) || typeof M.removeAttribute != "function" || typeof M.setAttribute != "function" || typeof M.namespaceURI != "string" || typeof M.insertBefore != "function" || typeof M.hasChildNodes != "function");
  }, Nr = function(M) {
    return typeof o == "function" && M instanceof o;
  }, de = function(M, z, q) {
    L[M] && Kn(L[M], (mt) => {
      mt.call(t, z, q, Ve);
    });
  }, $r = function(M) {
    let z = null;
    if (de("beforeSanitizeElements", M, null), Pr(M))
      return re(M), !0;
    const q = Lt(M.nodeName);
    if (de("uponSanitizeElement", M, {
      tagName: q,
      allowedTags: F
    }), M.hasChildNodes() && !Nr(M.firstElementChild) && Pt(/<[/\w]/g, M.innerHTML) && Pt(/<[/\w]/g, M.textContent) || M.nodeType === gn.progressingInstruction || U && M.nodeType === gn.comment && Pt(/<[/\w]/g, M.data))
      return re(M), !0;
    if (!F[q] || j[q]) {
      if (!j[q] && Br(q) && (Q.tagNameCheck instanceof RegExp && Pt(Q.tagNameCheck, q) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(q)))
        return !1;
      if ($s && !Ne[q]) {
        const mt = v(M) || M.parentNode, Ct = y(M) || M.childNodes;
        if (Ct && mt) {
          const At = Ct.length;
          for (let Bt = At - 1; Bt >= 0; --Bt) {
            const ae = g(Ct[Bt], !0);
            ae.__removalCount = (M.__removalCount || 0) + 1, mt.insertBefore(ae, E(M));
          }
        }
      }
      return re(M), !0;
    }
    return M instanceof c && !Vl(M) || (q === "noscript" || q === "noembed" || q === "noframes") && Pt(/<\/no(script|embed|frames)/i, M.innerHTML) ? (re(M), !0) : (H && M.nodeType === gn.text && (z = M.textContent, Kn([B, D, A], (mt) => {
      z = dn(z, mt, " ");
    }), M.textContent !== z && (hn(t.removed, {
      element: M.cloneNode()
    }), M.textContent = z)), de("afterSanitizeElements", M, null), !1);
  }, Vr = function(M, z, q) {
    if (te && (z === "id" || z === "name") && (q in e || q in Nl))
      return !1;
    if (!(ht && !Z[z] && Pt(w, z))) {
      if (!(ut && Pt(V, z))) {
        if (!J[z] || Z[z]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Br(M) && (Q.tagNameCheck instanceof RegExp && Pt(Q.tagNameCheck, M) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(M)) && (Q.attributeNameCheck instanceof RegExp && Pt(Q.attributeNameCheck, z) || Q.attributeNameCheck instanceof Function && Q.attributeNameCheck(z)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            z === "is" && Q.allowCustomizedBuiltInElements && (Q.tagNameCheck instanceof RegExp && Pt(Q.tagNameCheck, q) || Q.tagNameCheck instanceof Function && Q.tagNameCheck(q)))
          ) return !1;
        } else if (!Vs[z]) {
          if (!Pt(X, dn(q, P, ""))) {
            if (!((z === "src" || z === "xlink:href" || z === "href") && M !== "script" && jd(q, "data:") === 0 && wr[M])) {
              if (!(Et && !Pt(N, dn(q, P, "")))) {
                if (q)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Br = function(M) {
    return M !== "annotation-xml" && Ga(M, $);
  }, Gr = function(M) {
    de("beforeSanitizeAttributes", M, null);
    const {
      attributes: z
    } = M;
    if (!z)
      return;
    const q = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: J
    };
    let mt = z.length;
    for (; mt--; ) {
      const Ct = z[mt], {
        name: At,
        namespaceURI: Bt,
        value: ae
      } = Ct, cn = Lt(At);
      let Dt = At === "value" ? ae : Yd(ae);
      if (q.attrName = cn, q.attrValue = Dt, q.keepAttr = !0, q.forceKeepAttr = void 0, de("uponSanitizeAttribute", M, q), Dt = q.attrValue, U && Pt(/((--!?|])>)|<\/(style|title)/i, Dt)) {
        Bn(At, M);
        continue;
      }
      if (q.forceKeepAttr || (Bn(At, M), !q.keepAttr))
        continue;
      if (!Ut && Pt(/\/>/i, Dt)) {
        Bn(At, M);
        continue;
      }
      H && Kn([B, D, A], (Ur) => {
        Dt = dn(Dt, Ur, " ");
      });
      const Hr = Lt(M.nodeName);
      if (Vr(Hr, cn, Dt)) {
        if (Tr && (cn === "id" || cn === "name") && (Bn(At, M), Dt = Rl + Dt), S && typeof p == "object" && typeof p.getAttributeType == "function" && !Bt)
          switch (p.getAttributeType(Hr, cn)) {
            case "TrustedHTML": {
              Dt = S.createHTML(Dt);
              break;
            }
            case "TrustedScriptURL": {
              Dt = S.createScriptURL(Dt);
              break;
            }
          }
        try {
          Bt ? M.setAttributeNS(Bt, At, Dt) : M.setAttribute(At, Dt), Pr(M) ? re(M) : Ba(t.removed);
        } catch {
        }
      }
    }
    de("afterSanitizeAttributes", M, null);
  }, Bl = function K(M) {
    let z = null;
    const q = Dr(M);
    for (de("beforeSanitizeShadowDOM", M, null); z = q.nextNode(); )
      de("uponSanitizeShadowNode", z, null), !$r(z) && (z.content instanceof r && K(z.content), Gr(z));
    de("afterSanitizeShadowDOM", M, null);
  };
  return t.sanitize = function(K) {
    let M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, z = null, q = null, mt = null, Ct = null;
    if (Bs = !K, Bs && (K = "<!-->"), typeof K != "string" && !Nr(K))
      if (typeof K.toString == "function") {
        if (K = K.toString(), typeof K != "string")
          throw pn("dirty is not a string, aborting");
      } else
        throw pn("toString is not a function");
    if (!t.isSupported)
      return K;
    if (zt || Hs(M), t.removed = [], typeof K == "string" && (on = !1), on) {
      if (K.nodeName) {
        const ae = Lt(K.nodeName);
        if (!F[ae] || j[ae])
          throw pn("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (K instanceof o)
      z = Ir("<!---->"), q = z.ownerDocument.importNode(K, !0), q.nodeType === gn.element && q.nodeName === "BODY" || q.nodeName === "HTML" ? z = q : z.appendChild(q);
    else {
      if (!nt && !H && !W && // eslint-disable-next-line unicorn/prefer-includes
      K.indexOf("<") === -1)
        return S && ie ? S.createHTML(K) : K;
      if (z = Ir(K), !z)
        return nt ? null : ie ? b : "";
    }
    z && an && re(z.firstChild);
    const At = Dr(on ? K : z);
    for (; mt = At.nextNode(); )
      $r(mt) || (mt.content instanceof r && Bl(mt.content), Gr(mt));
    if (on)
      return K;
    if (nt) {
      if (St)
        for (Ct = k.call(z.ownerDocument); z.firstChild; )
          Ct.appendChild(z.firstChild);
      else
        Ct = z;
      return (J.shadowroot || J.shadowrootmode) && (Ct = C.call(n, Ct, !0)), Ct;
    }
    let Bt = W ? z.outerHTML : z.innerHTML;
    return W && F["!doctype"] && z.ownerDocument && z.ownerDocument.doctype && z.ownerDocument.doctype.name && Pt(Sl, z.ownerDocument.doctype.name) && (Bt = "<!DOCTYPE " + z.ownerDocument.doctype.name + `>
` + Bt), H && Kn([B, D, A], (ae) => {
      Bt = dn(Bt, ae, " ");
    }), S && ie ? S.createHTML(Bt) : Bt;
  }, t.setConfig = function() {
    let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Hs(K), zt = !0;
  }, t.clearConfig = function() {
    Ve = null, zt = !1;
  }, t.isValidAttribute = function(K, M, z) {
    Ve || Hs({});
    const q = Lt(K), mt = Lt(M);
    return Vr(q, mt, z);
  }, t.addHook = function(K, M) {
    typeof M == "function" && (L[K] = L[K] || [], hn(L[K], M));
  }, t.removeHook = function(K) {
    if (L[K])
      return Ba(L[K]);
  }, t.removeHooks = function(K) {
    L[K] && (L[K] = []);
  }, t.removeAllHooks = function() {
    L = {};
  }, t;
}
var Er = xl();
const Qn = (s) => Er.sanitize(s, {
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), cp = (s) => Er.sanitize(s, {
  NAMESPACE: "http://www.w3.org/2000/svg",
  USE_PROFILES: {
    html: !0,
    svg: !0,
    svgFilters: !0
  }
}), ue = (s) => Er.sanitize(s, { ALLOWED_TAGS: [] }), _s = class _s extends ot {
  constructor() {
    super(...arguments), this.type = "toolbar", this.renderType = st.HTML;
  }
  init() {
    const t = () => this.updateOverflowMenu(!1);
    this.services.events.addEventListener(x.Toolbar.SHOW_OVERFLOW_MENU, () => {
      this.renderOverflowMenu(), document.body.addEventListener("click", t);
    }), this.services.events.addEventListener(x.Toolbar.HIDE_OVERFLOW_MENU, () => {
      document.body.removeEventListener("click", t);
    });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer().attr("role", "toolbar");
    if (T(this.getOptions(), "data", "loading"))
      e.html(""), this.overflowMenu = null;
    else {
      this.overflowMenu || (this.overflowMenu = e.append("div").attr(
        "class",
        "cds--overflow-menu-options cds--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip"
      ).attr("tabindex", -1).html("<ul role='menu'></ul>"));
      const { buttonList: i, overflowMenuItemList: r } = this.getControlConfigs();
      r && i.push(this.getOverflowButtonConfig());
      const a = e.selectAll("div.toolbar-control").data(i, (l) => l.id);
      a.exit().remove();
      const o = a.enter().append("div").attr("class", "toolbar-control cds--overflow-menu cds--overflow-menu"), c = this;
      o.merge(a).classed("disabled", (l) => l.shouldBeDisabled()).attr("role", "button").attr("aria-disabled", (l) => l.shouldBeDisabled()).attr("aria-label", (l) => l.title).html((l) => `
			<button
				class="cds--overflow-menu__trigger cds--overflow-menu__trigger"
				aria-haspopup="true" aria-expanded="false" id="${this.services.domUtils.generateElementIDString(
        `control-${ue(l.id)}`
      )}" aria-label="${ue(l.title)}">
				<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" class="cds--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">
					${cp(l.iconSVG.content)}
				</svg>
			</button>`).each(function(l, h) {
        R(this).select("svg").style("pointer-events", "none").style("will-change", "transform").style("width", l.iconSVG.width !== void 0 ? l.iconSVG.width : "20px").style("height", l.iconSVG.height !== void 0 ? l.iconSVG.height : "20px"), R(this).select("button").on("mouseover focus", function(d) {
          const u = R(this);
          u.classed("hovered", !0), c.services.events.dispatchEvent(x.Toolbar.SHOW_TOOLTIP, {
            event: d,
            hoveredElement: u,
            content: l.title,
            noWrap: !0,
            placements: ["top", "bottom"]
          });
        }).on("mouseout blur", function() {
          c.services.events.dispatchEvent(x.Toolbar.HIDE_TOOLTIP);
        }).on("click", (d) => {
          l.shouldBeDisabled() || c.triggerFunctionAndEvent(l, d, this);
        }).on("keydown", (d) => {
          d.key && d.key === "Enter" || d.key === " " ? (d.preventDefault(), c.triggerFunctionAndEvent(l, d, this)) : d.key && d.key === "ArrowLeft" ? c.focusOnPreviousEnabledToolbarItem(h) : d.key && d.key === "ArrowRight" && c.focusOnNextEnabledToolbarItem(h);
        });
      }), this.overflowButton = this.getComponentContainer().select(
        `button.cds--overflow-menu__trigger#${this.services.domUtils.generateElementIDString(
          "control-toolbar-overflow-menu"
        )}`
      );
    }
  }
  renderOverflowMenu() {
    const { overflowMenuItemList: t } = this.getControlConfigs(), e = this.overflowMenu.select("ul").selectAll("li.cds--overflow-menu-options__option").data(t, (i) => T(i, "id"));
    e.exit().remove();
    const n = e.enter().append("li").attr("id", (i) => this.services.domUtils.generateElementIDString(`control-${i.id}`)).attr("class", "cds--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem").attr("tabindex", 1);
    n.append("button").attr("class", "cds--overflow-menu-options__btn cds--overflow-menu-options__btn"), n.merge(e).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).classed("cds--overflow-menu-options__option--disabled", (i) => i.shouldBeDisabled()).attr("aria-disabled", (i) => i.shouldBeDisabled()).selectAll("button").text((i) => i.title);
  }
  isOverflowMenuOpen() {
    return this.overflowMenu.classed("is-open");
  }
  // show/hide overflow menu
  updateOverflowMenu(t) {
    this.overflowMenu && (this.overflowMenu.classed("is-open", t), this.overflowButton && (this.overflowButton.attr("aria-expanded", t), R(this.overflowButton.node().parentNode).classed("cds--overflow-menu--open", t).classed("cds--overflow-menu--open", t)), t ? this.services.events.dispatchEvent(x.Toolbar.SHOW_OVERFLOW_MENU) : this.services.events.dispatchEvent(x.Toolbar.HIDE_OVERFLOW_MENU));
  }
  // Toolbar controllers
  focusOnPreviousEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = e.length;
    for (let i = t - 1; i >= 0; i--)
      if (!e[i].shouldBeDisabled()) {
        n = i;
        break;
      }
    if (n < e.length) {
      const i = R(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledToolbarItem(t) {
    const e = this.getToolbarButtonItems();
    let n = -1;
    for (let i = t + 1; i < e.length; i++)
      if (!e[i].shouldBeDisabled()) {
        n = i;
        break;
      }
    if (n > -1) {
      const i = R(
        `button#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )}`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnPreviousEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = e.length;
    for (let i = t - 1; i >= 0; i--)
      if (!e[i].shouldBeDisabled()) {
        n = i;
        break;
      }
    if (n < e.length) {
      const i = R(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  focusOnNextEnabledMenuItem(t) {
    const e = this.getOverflowMenuItems();
    let n = -1;
    for (let i = t + 1; i < e.length; i++)
      if (!e[i].shouldBeDisabled()) {
        n = i;
        break;
      }
    if (n > -1) {
      const i = R(
        `#${this.services.domUtils.generateElementIDString(
          `control-${e[n].id}`
        )} button`
      ).node();
      "focus" in i && i.focus();
    }
  }
  toggleOverflowMenu(t) {
    if (this.isOverflowMenuOpen())
      this.updateOverflowMenu(!1);
    else {
      this.updateOverflowMenu(!0);
      const e = this;
      this.getOverflowMenuItems().forEach((i, r) => {
        const a = R(
          `#${this.services.domUtils.generateElementIDString(`control-${i.id}`)}`
        );
        a !== null && (a.on("click", () => {
          e.triggerFunctionAndEvent(i, t, a.node()), e.updateOverflowMenu(!1);
        }), a.on("keydown", (o) => {
          o && o.key === "Enter" ? e.triggerFunctionAndEvent(i, t, a.node()) : o && o.key === "ArrowUp" ? e.focusOnPreviousEnabledMenuItem(r) : o && o.key === "ArrowDown" ? e.focusOnNextEnabledMenuItem(r) : o && o.key === "Escape" && e.updateOverflowMenu(!1), o.preventDefault();
        }));
      }), e.focusOnNextEnabledMenuItem(-1);
    }
    t && t.stopImmediatePropagation();
  }
  // Calls passed function && dispatches event
  triggerFunctionAndEvent(t, e, n) {
    typeof t.shouldBeDisabled == "function" && t.shouldBeDisabled() || (typeof t.clickFunction == "function" && t.clickFunction(e), this.services.events.dispatchEvent(x.Toolbar.BUTTON_CLICK, {
      control: t,
      event: e,
      element: n
    }));
  }
  getControlConfigs() {
    const t = T(this.getOptions(), "toolbar", "numberOfIcons") - 1, e = T(this.getOptions(), "toolbar", "controls"), n = [], i = [], r = [];
    return e.forEach((a) => {
      let o = null;
      if (a.type === xt.CUSTOM)
        T(a, "id") === null && (a.id = `toolbar-button-${_s.buttonID++}`), T(a, "shouldBeDisabled") === null && (a.shouldBeDisabled = () => !1), o = a;
      else {
        const c = this.services.domUtils.isFullScreenMode();
        a.type === xt.MAKE_FULLSCREEN && c ? a.type = xt.EXIT_FULLSCREEN : a.type === xt.EXIT_FULLSCREEN && !c && (a.type = xt.MAKE_FULLSCREEN), o = this.getControlConfigByType(a.type);
      }
      o && (o.text = a.text ? a.text : a.type, o.id.indexOf("toolbar-export") !== -1 ? n.push(o) : i.length < t ? T(o, "iconSVG", "content") === null ? r.push(o) : i.push(o) : r.push(o));
    }), r.push(...n), r.length ? {
      buttonList: i,
      overflowMenuItemList: r
    } : {
      buttonList: i
    };
  }
  getToolbarButtonItems() {
    const { buttonList: t, overflowMenuItemList: e } = this.getControlConfigs();
    return e && t.push(this.getOverflowButtonConfig()), t || [];
  }
  getOverflowMenuItems() {
    const { overflowMenuItemList: t } = this.getControlConfigs();
    return t || [];
  }
  // special button config for overflow button
  getOverflowButtonConfig() {
    const { moreOptions: t } = T(
      this.model.getOptions(),
      "locale",
      "translations",
      "toolbar"
    );
    return {
      id: "toolbar-overflow-menu",
      title: t,
      shouldBeDisabled: () => !1,
      iconSVG: {
        content: `<circle cx="16" cy="8" r="2"></circle>
				<circle cx="16" cy="16" r="2"></circle>
				<circle cx="16" cy="24" r="2"></circle>`
      },
      clickFunction: (e) => this.toggleOverflowMenu(e)
    };
  }
  getControlConfigByType(t) {
    const e = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState(), n = this.model.getDisplayData(), i = this.model.getOptions(), {
      exportAsCSV: r,
      exportAsJPG: a,
      exportAsPNG: o,
      zoomIn: c,
      zoomOut: l,
      resetZoom: h,
      makeFullScreen: d,
      exitFullScreen: u,
      showAsTable: p
    } = T(i, "locale", "translations", "toolbar");
    let f;
    switch (t) {
      case xt.ZOOM_IN:
        e && (f = {
          id: "toolbar-zoomIn",
          title: c,
          shouldBeDisabled: () => this.services.zoom.isMinZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomIn()
        });
        break;
      case xt.ZOOM_OUT:
        e && (f = {
          id: "toolbar-zoomOut",
          title: l,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.zoomOut()
        });
        break;
      case xt.RESET_ZOOM:
        e && (f = {
          id: "toolbar-resetZoom",
          title: h,
          shouldBeDisabled: () => this.services.zoom.isMaxZoomDomain(),
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.zoom.resetZoomDomain()
        });
        break;
      case xt.MAKE_FULLSCREEN:
        f = {
          id: "toolbar-makefullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: d,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case xt.EXIT_FULLSCREEN:
        f = {
          id: "toolbar-exitfullscreen",
          iconSVG: {
            content: this.getControlIconByType(t),
            width: "15px",
            height: "15px"
          },
          title: u,
          shouldBeDisabled: () => !1,
          clickFunction: () => {
            this.services.domUtils.toggleFullscreen();
          }
        };
        break;
      case xt.SHOW_AS_DATATABLE:
        f = {
          id: "toolbar-showasdatatable",
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          title: p,
          shouldBeDisabled: () => n.length === 0,
          clickFunction: () => this.services.events.dispatchEvent(x.Modal.SHOW)
        };
        break;
      case xt.EXPORT_CSV:
        f = {
          id: "toolbar-export-CSV",
          title: r,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.model.exportToCSV()
        };
        break;
      case xt.EXPORT_PNG:
        f = {
          id: "toolbar-export-PNG",
          title: o,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToPNG()
        };
        break;
      case xt.EXPORT_JPG:
        f = {
          id: "toolbar-export-JPG",
          title: a,
          shouldBeDisabled: () => !1,
          iconSVG: {
            content: this.getControlIconByType(t)
          },
          clickFunction: () => this.services.domUtils.exportToJPG()
        };
        break;
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
    return f;
  }
  getControlIconByType(t) {
    switch (t) {
      case xt.ZOOM_IN:
        return `<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case xt.ZOOM_OUT:
        return `<rect x="9" y="13" width="10" height="2"/>
						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>`;
      case xt.RESET_ZOOM:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case xt.MAKE_FULLSCREEN:
        return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
      case xt.EXIT_FULLSCREEN:
        return '<polygon points="4 18 4 20 10.586 20 2 28.582 3.414 30 12 21.414 12 28 14 28 14 18 4 18"/><polygon points="30 3.416 28.592 2 20 10.586 20 4 18 4 18 14 28 14 28 12 21.414 12 30 3.416"/>';
      case xt.SHOW_AS_DATATABLE:
        return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
      case xt.EXPORT_CSV:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case xt.EXPORT_JPG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      case xt.EXPORT_PNG:
        return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
      default:
        throw Error("Not supported toolbar control type: " + t);
    }
  }
};
_s.buttonID = 0;
let Xa = _s;
const Cs = class Cs extends ot {
  constructor(t, e, n, i) {
    super(t, e, i), this.type = "layout", this.configs = i, this.children = n, this._instanceID = Cs.instanceID++, this.init();
  }
  init() {
    this.children.forEach((t) => {
      t.components.forEach((e) => {
        e.init();
      });
    });
  }
  getPreferedAndFixedSizeSum() {
    const t = this.parent;
    let e = 0;
    return t.selectAll(`div.layout-child-${this._instanceID}`).filter((n) => {
      const i = T(n, "growth");
      return i === Se.PREFERRED || i === Se.FIXED;
    }).each(function(n) {
      e += n.size;
    }), e;
  }
  getNumOfStretchChildren() {
    return this.parent.selectAll(`div.layout-child-${this._instanceID}`).filter((e) => T(e, "growth") === Se.STRETCH).size();
  }
  render(t = !0) {
    const e = this.parent, { width: n, height: i } = _.getHTMLElementSize(e.node()), r = this.configs.direction === Be.ROW || this.configs.direction === Be.ROW_REVERSE, a = T(this.model.getOptions(), "style", "prefix"), o = e.classed(
      `${qt}--${a}--layout-row`,
      this.configs.direction === Be.ROW
    ).classed(
      `${qt}--${a}--layout-row-reverse`,
      this.configs.direction === Be.ROW_REVERSE
    ).classed(
      `${qt}--${a}--layout-column`,
      this.configs.direction === Be.COLUMN
    ).classed(
      `${qt}--${a}--layout-column-reverse`,
      this.configs.direction === Be.COLUMN_REVERSE
    ).classed(
      `${qt}--${a}--layout-alignitems-center`,
      this.configs.alignItems === tc.CENTER
    ).selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (h) => h.id);
    o.enter().append("div").merge(e.selectAll(`div.layout-child-${this._instanceID}`)).attr("class", (h) => `layout-child layout-child-${this._instanceID} ${h.id}`).each(function(h) {
      h.components.forEach((d) => {
        const u = R(this), f = T(h, "renderType") === st.SVG;
        d.setParent(
          f ? _.appendOrSelect(u, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : u
        );
        const g = T(h, "growth");
        (g === Se.PREFERRED || g === Se.FIXED) && d.render(t);
      });
    }), e.selectAll(`div.layout-child-${this._instanceID}`).style("height", null).style("width", null).each(function(h) {
      const d = T(h, "growth"), p = T(h, "renderType") === st.SVG ? _.getSVGElementSize(R(this).select("svg.layout-svg-wrapper"), {
        useBBox: !0
      }) : _.getHTMLElementSize(this);
      if (d === Se.PREFERRED) {
        const f = r ? p.width : p.height, g = r ? n : i;
        h.size = f / g * 100;
      }
    }), o.exit().remove(), this.children.filter((h) => T(h, "growth") === Se.STRETCH).forEach((h) => {
      h.size = (100 - +this.getPreferedAndFixedSizeSum()) / +this.getNumOfStretchChildren();
    });
    const l = e.selectAll(`div.layout-child-${this._instanceID}`).data(this.children, (h) => h.id);
    r ? l.style("width", (h) => `${h.size / 100 * n}px`).style("height", "100%") : l.style("height", (h) => `${h.size / 100 * i}px`).style("width", "100%"), l.each(function(h) {
      h.components.forEach((d) => {
        T(h, "growth") === Se.STRETCH && d.render(t);
      });
    });
  }
  // Pass on model to children as well
  setModel(t) {
    super.setModel(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setModel(t));
    });
  }
  // Pass on essentials to children as well
  setServices(t) {
    super.setServices(t), this.children.forEach((e) => {
      e.components.forEach((n) => n.setServices(t));
    });
  }
  destroy() {
    this.children.forEach((t) => {
      t.components.forEach((e) => e.destroy());
    });
  }
};
Cs.instanceID = Math.floor(Math.random() * 99999999999);
let ja = Cs;
class h0 extends ot {
  constructor() {
    super(...arguments), this.type = "spacer";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    this.getComponentContainer().style("width", `${this.configs.size || Fr.default.size}px`).style("height", `${this.configs.size || Fr.default.size}px`).attr("opacity", 0);
  }
}
var up = {
  prefix: "bx",
  selectorTabbable: `
    a[href], area[href], input:not([disabled]):not([tabindex='-1']),
    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
    textarea:not([disabled]):not([tabindex='-1']),
    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]
  `,
  selectorFocusable: `
    a[href], area[href], input:not([disabled]),
    button:not([disabled]),select:not([disabled]),
    textarea:not([disabled]),
    iframe, object, embed, *[tabindex], *[contenteditable=true]
  `
}, fi = up;
function hp(s, t, e) {
  return Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function dp(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pp(s) {
  return vp(s) || mp(s) || gp(s) || fp();
}
function fp() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function gp(s, t) {
  if (s) {
    if (typeof s == "string") return Fi(s, t);
    var e = Object.prototype.toString.call(s).slice(8, -1);
    if (e === "Object" && s.constructor && (e = s.constructor.name), e === "Map" || e === "Set") return Array.from(s);
    if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return Fi(s, t);
  }
}
function mp(s) {
  if (typeof Symbol < "u" && s[Symbol.iterator] != null || s["@@iterator"] != null) return Array.from(s);
}
function vp(s) {
  if (Array.isArray(s)) return Fi(s);
}
function Fi(s, t) {
  (t == null || t > s.length) && (t = s.length);
  for (var e = 0, n = new Array(t); e < t; e++)
    n[e] = s[e];
  return n;
}
function bl(s) {
  return s.reduce(function(t, e) {
    return Array.isArray(e) ? t.push.apply(t, pp(bl(e))) : t.push(e), t;
  }, []);
}
function yp() {
  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)
    t[e] = arguments[e];
  return bl(t).reduce(function(n, i) {
    return i(n);
  }, /* @__PURE__ */ function() {
    function n() {
      dp(this, n);
    }
    return hp(n);
  }());
}
function Wi(s) {
  "@babel/helpers - typeof";
  return Wi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wi(s);
}
function Ep(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ya(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function Sp(s, t, e) {
  return t && Ya(s.prototype, t), e && Ya(s, e), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function xp(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && Xi(s, t);
}
function Xi(s, t) {
  return Xi = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, Xi(s, t);
}
function bp(s) {
  var t = Op();
  return function() {
    var n = Ts(s), i;
    if (t) {
      var r = Ts(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return Tp(this, i);
  };
}
function Tp(s, t) {
  if (t && (Wi(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Tl(s);
}
function Tl(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function Op() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ts(s) {
  return Ts = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Ts(s);
}
function wp(s) {
  var t = /* @__PURE__ */ function(e) {
    xp(i, e);
    var n = bp(i);
    function i(r) {
      var a, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (Ep(this, i), a = n.call(this, r, o), a.children = [], !r || r.nodeType !== Node.ELEMENT_NODE)
        throw new TypeError("DOM element should be given to initialize this widget.");
      return a.element = r, a.options = Object.assign(Object.create(a.constructor.options), o), a.constructor.components.set(a.element, Tl(a)), a;
    }
    return Sp(i, [{
      key: "release",
      value: (
        /**
         * Releases this component's instance from the associated element.
         */
        function() {
          for (var a = this.children.pop(); a; a = this.children.pop())
            a.release();
          return this.constructor.components.delete(this.element), null;
        }
      )
    }], [{
      key: "create",
      value: function(a, o) {
        return this.components.get(a) || new this(a, o);
      }
    }]), i;
  }(s);
  return t;
}
function ji(s) {
  "@babel/helpers - typeof";
  return ji = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ji(s);
}
function Lp(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ap(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function Mp(s, t, e) {
  return t && Ap(s.prototype, t), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function cs() {
  return typeof Reflect < "u" && Reflect.get ? cs = Reflect.get : cs = function(t, e, n) {
    var i = _p(t, e);
    if (i) {
      var r = Object.getOwnPropertyDescriptor(i, e);
      return r.get ? r.get.call(arguments.length < 3 ? t : n) : r.value;
    }
  }, cs.apply(this, arguments);
}
function _p(s, t) {
  for (; !Object.prototype.hasOwnProperty.call(s, t) && (s = rn(s), s !== null); )
    ;
  return s;
}
function Cp(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && Yi(s, t);
}
function Yi(s, t) {
  return Yi = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, Yi(s, t);
}
function kp(s) {
  var t = Dp();
  return function() {
    var n = rn(s), i;
    if (t) {
      var r = rn(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return Rp(this, i);
  };
}
function Rp(s, t) {
  if (t && (ji(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Ip(s);
}
function Ip(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function Dp() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function rn(s) {
  return rn = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, rn(s);
}
function Pp(s) {
  var t = /* @__PURE__ */ function(e) {
    Cp(i, e);
    var n = kp(i);
    function i() {
      var r;
      Lp(this, i);
      for (var a = arguments.length, o = new Array(a), c = 0; c < a; c++)
        o[c] = arguments[c];
      return r = n.call.apply(n, [this].concat(o)), r.handles = /* @__PURE__ */ new Set(), r;
    }
    return Mp(i, [{
      key: "manage",
      value: (
        /**
         * Manages the given handle.
         * @param {Handle} handle The handle to manage.
         * @returns {Handle} The given handle.
         */
        function(a) {
          return this.handles.add(a), a;
        }
      )
      /**
       * Stop managing the given handle.
       * @param {Handle} handle The handle to stop managing.
       * @returns {Handle} The given handle.
       */
    }, {
      key: "unmanage",
      value: function(a) {
        return this.handles.delete(a), a;
      }
    }, {
      key: "release",
      value: function() {
        var a = this;
        return this.handles.forEach(function(o) {
          o.release(), a.handles.delete(o);
        }), cs(rn(i.prototype), "release", this).call(this);
      }
    }]), i;
  }(s);
  return t;
}
function On(s) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    e[n - 1] = arguments[n];
  return s.addEventListener.apply(s, e), {
    release: function() {
      return s.removeEventListener.apply(s, e), null;
    }
  };
}
function qi(s) {
  "@babel/helpers - typeof";
  return qi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qi(s);
}
function Np(s) {
  return Gp(s) || Bp(s) || Vp(s) || $p();
}
function $p() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Vp(s, t) {
  if (s) {
    if (typeof s == "string") return Zi(s, t);
    var e = Object.prototype.toString.call(s).slice(8, -1);
    if (e === "Object" && s.constructor && (e = s.constructor.name), e === "Map" || e === "Set") return Array.from(s);
    if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return Zi(s, t);
  }
}
function Bp(s) {
  if (typeof Symbol < "u" && s[Symbol.iterator] != null || s["@@iterator"] != null) return Array.from(s);
}
function Gp(s) {
  if (Array.isArray(s)) return Zi(s);
}
function Zi(s, t) {
  (t == null || t > s.length) && (t = s.length);
  for (var e = 0, n = new Array(t); e < t; e++)
    n[e] = s[e];
  return n;
}
function Hp(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Up(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function zp(s, t, e) {
  return t && Up(s.prototype, t), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function Fp(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && Ki(s, t);
}
function Ki(s, t) {
  return Ki = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, Ki(s, t);
}
function Wp(s) {
  var t = Yp();
  return function() {
    var n = Os(s), i;
    if (t) {
      var r = Os(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return Xp(this, i);
  };
}
function Xp(s, t) {
  if (t && (qi(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return jp(s);
}
function jp(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function Yp() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Os(s) {
  return Os = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Os(s);
}
function qp(s) {
  var t = /* @__PURE__ */ function(e) {
    Fp(i, e);
    var n = Wp(i);
    function i() {
      return Hp(this, i), n.apply(this, arguments);
    }
    return zp(i, [{
      key: "_changeState",
      value: (
        /* eslint-disable jsdoc/check-param-names */
        /**
         * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
         * @param {string} [state] The new state. Can be an omitted, which means toggling.
         * @param {object} [detail]
         *   The object that should be put to event details that is fired before/after changing state.
         *   Can have a `group` property, which specifies what state to be changed.
         * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
         * @private
         */
        function() {
          throw new Error("_changeState() should be overridden to perform actual change in state.");
        }
      )
      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */
    }, {
      key: "changeState",
      value: function() {
        for (var a = this, o = arguments.length, c = new Array(o), l = 0; l < o; l++)
          c[l] = arguments[l];
        var h = typeof c[0] == "string" ? c.shift() : void 0, d = Object(c[0]) === c[0] && typeof c[0] != "function" ? c.shift() : void 0, u = typeof c[0] == "function" ? c.shift() : void 0;
        if (typeof this.shouldStateBeChanged == "function" && !this.shouldStateBeChanged(h, d)) {
          u && u(null, !0);
          return;
        }
        var p = {
          group: d && d.group,
          state: h
        }, f = [p.group, h].filter(Boolean).join("-").split("-").map(function(S) {
          return S[0].toUpperCase() + S.substr(1);
        }).join(""), g = new CustomEvent(this.options["eventBefore".concat(f)], {
          bubbles: !0,
          cancelable: !0,
          detail: d
        }), m = d && d.delegatorNode || this.element, E = !m.dispatchEvent(g);
        if (E) {
          if (u) {
            var y = new Error("Changing state (".concat(JSON.stringify(p), ") has been canceled."));
            y.canceled = !0, u(y);
          }
        } else {
          var v = [h, d].filter(Boolean);
          this._changeState.apply(this, Np(v).concat([function() {
            m.dispatchEvent(new CustomEvent(a.options["eventAfter".concat(f)], {
              bubbles: !0,
              cancelable: !0,
              detail: d
            })), u && u();
          }]));
        }
      }
      /* eslint-enable jsdoc/check-param-names */
      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */
    }]), i;
  }(s);
  return t;
}
function Ji(s, t) {
  var e = s.target, n = s.currentTarget;
  if (typeof e.matches == "function") {
    if (e.matches(t))
      return e;
    if (e.matches("".concat(t, " *"))) {
      var i = e.closest(t);
      if ((n.nodeType === Node.DOCUMENT_NODE ? n.documentElement : n).contains(i))
        return i;
    }
  }
}
function qa(s) {
  if (!s || typeof s == "function")
    return {
      launchingElement: null,
      launchingEvent: null
    };
  var t = s.delegateTarget || s.currentTarget || s, e = s.currentTarget && s;
  if (t && !t.nodeType)
    throw new TypeError("DOM Node should be given for launching element.");
  if (e && !e.type)
    throw new TypeError("DOM event should be given for launching event.");
  return {
    launchingElement: t,
    launchingEvent: e
  };
}
function Qi(s) {
  "@babel/helpers - typeof";
  return Qi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qi(s);
}
function Zp(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kp(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function Jp(s, t, e) {
  return t && Kp(s.prototype, t), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function Qp(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && tr(s, t);
}
function tr(s, t) {
  return tr = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, tr(s, t);
}
function tf(s) {
  var t = sf();
  return function() {
    var n = ws(s), i;
    if (t) {
      var r = ws(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return ef(this, i);
  };
}
function ef(s, t) {
  if (t && (Qi(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return nf(s);
}
function nf(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function sf() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ws(s) {
  return ws = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, ws(s);
}
function rf(s) {
  var t = /* @__PURE__ */ function(e) {
    Qp(i, e);
    var n = tf(i);
    function i() {
      return Zp(this, i), n.apply(this, arguments);
    }
    return Jp(i, [{
      key: "show",
      value: (
        /**
         */
        /**
         * Switch to 'shown' state.
         * @param [evtOrElem] The launching event or element.
         * @param {EventedState~changeStateCallback} [callback] The callback.
         */
        function(a, o) {
          (!a || typeof a == "function") && (o = a), this.changeState("shown", qa(a), o);
        }
      )
      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
    }, {
      key: "hide",
      value: function(a, o) {
        (!a || typeof a == "function") && (o = a), this.changeState("hidden", qa(a), o);
      }
    }]), i;
  }(s);
  return t;
}
var af = [qp, rf];
function Ol(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function of(s) {
  if (s.__esModule) return s;
  var t = s.default;
  if (typeof t == "function") {
    var e = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(s).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(s, n);
    Object.defineProperty(e, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return s[n];
      }
    });
  }), e;
}
var wl = function() {
};
process.env.NODE_ENV !== "production" && (wl = function(s, t, e) {
  var n = arguments.length;
  e = new Array(n > 2 ? n - 2 : 0);
  for (var i = 2; i < n; i++)
    e[i - 2] = arguments[i];
  if (t === void 0)
    throw new Error(
      "`warning(condition, format, ...args)` requires a warning message argument"
    );
  if (t.length < 10 || /^[s\W]*$/.test(t))
    throw new Error(
      "The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + t
    );
  if (!s) {
    var r = 0, a = "Warning: " + t.replace(/%s/g, function() {
      return e[r++];
    });
    typeof console < "u" && console.error(a);
    try {
      throw new Error(a);
    } catch {
    }
  }
});
var lf = wl;
const cf = /* @__PURE__ */ Ol(lf);
function er(s) {
  "@babel/helpers - typeof";
  return er = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, er(s);
}
function uf(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hf(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function df(s, t, e) {
  return e && hf(s, e), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function pf(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && nr(s, t);
}
function nr(s, t) {
  return nr = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, nr(s, t);
}
function ff(s) {
  var t = vf();
  return function() {
    var n = Ls(s), i;
    if (t) {
      var r = Ls(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return gf(this, i);
  };
}
function gf(s, t) {
  if (t && (er(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return mf(s);
}
function mf(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function vf() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ls(s) {
  return Ls = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Ls(s);
}
function yf(s) {
  var t = /* @__PURE__ */ function(e) {
    pf(i, e);
    var n = ff(i);
    function i() {
      return uf(this, i), n.apply(this, arguments);
    }
    return df(i, null, [{
      key: "init",
      value: (
        /**
         * `true` suggests that this component is lazily initialized upon an action/event, etc.
         * @type {boolean}
         */
        /**
         * Instantiates this component in the given element.
         * If the given element indicates that it's an component of this class, instantiates it.
         * Otherwise, instantiates this component by clicking on launcher buttons
         * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
         * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
         * @param {object} [options] The component options.
         * @param {string} [options.selectorInit] The CSS selector to find this component.
         * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
         * @returns {Handle} The handle to remove the event listener to handle clicking.
         */
        function() {
          var a = this, o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = Object.assign(Object.create(this.options), c);
          if (!o || o.nodeType !== Node.ELEMENT_NODE && o.nodeType !== Node.DOCUMENT_NODE)
            throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
          if (o.nodeType === Node.ELEMENT_NODE && o.matches(l.selectorInit))
            this.create(o, c);
          else {
            var h = l.initEventNames.map(function(d) {
              return On(o, d, function(u) {
                var p = Ji(u, "[".concat(l.attribInitTarget, "]"));
                if (p) {
                  u.delegateTarget = p;
                  var f = p.ownerDocument.querySelectorAll(p.getAttribute(l.attribInitTarget));
                  if (f.length > 1)
                    throw new Error("Target widget must be unique.");
                  if (f.length === 1) {
                    p.tagName === "A" && u.preventDefault();
                    var g = a.create(f[0], c);
                    typeof g.createdByLauncher == "function" && g.createdByLauncher(u);
                  }
                }
              });
            });
            return {
              release: function() {
                for (var u = h.pop(); u; u = h.pop())
                  u.release();
              }
            };
          }
          return "";
        }
      )
    }]), i.forLazyInit = !0, i;
  }(s);
  return t;
}
function sr(s) {
  "@babel/helpers - typeof";
  return sr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sr(s);
}
function Ef(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Za(s, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function Sf(s, t, e) {
  return t && Za(s.prototype, t), e && Za(s, e), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function xf(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), t && ir(s, t);
}
function ir(s, t) {
  return ir = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, ir(s, t);
}
function bf(s) {
  var t = wf();
  return function() {
    var n = As(s), i;
    if (t) {
      var r = As(this).constructor;
      i = Reflect.construct(n, arguments, r);
    } else
      i = n.apply(this, arguments);
    return Tf(this, i);
  };
}
function Tf(s, t) {
  if (t && (sr(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Of(s);
}
function Of(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function wf() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function As(s) {
  return As = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, As(s);
}
var Lf = /* @__PURE__ */ function(s) {
  xf(e, s);
  var t = bf(e);
  function e(n, i) {
    var r;
    return Ef(this, e), r = t.call(this, n, i), r._handleFocusinListener = void 0, r._handleKeydownListener = void 0, r._handleFocusin = function(a) {
      var o = r.element.querySelector(r.options.selectorModalContainer) || r.element;
      r.element.classList.contains(r.options.classVisible) && !o.contains(a.target) && r.options.selectorsFloatingMenus.every(function(c) {
        return !Ji(a, c);
      }) && r.element.querySelector(fi.selectorTabbable).focus();
    }, r._hookCloseActions(), r;
  }
  return Sf(e, [{
    key: "createdByLauncher",
    value: (
      /**
       * A method that runs when `.init()` is called from `initComponentByLauncher`.
       * @param {Event} evt The event fired on the launcher button.
       */
      function(i) {
        this.show(i);
      }
    )
    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */
  }, {
    key: "shouldStateBeChanged",
    value: function(i) {
      return i === "shown" ? !this.element.classList.contains(this.options.classVisible) : this.element.classList.contains(this.options.classVisible);
    }
    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {object} detail The detail data to be included in the event that will be fired.
     * @param {Function} callback Callback called when change in state completes.
     */
  }, {
    key: "_changeState",
    value: function(i, r, a) {
      var o = this, c, l = function() {
        if (c && (c = o.unmanage(c).release()), i === "shown" && o.element.offsetWidth > 0 && o.element.offsetHeight > 0) {
          o.previouslyFocusedNode = o.element.ownerDocument.activeElement;
          var p = o.element.querySelector(o.options.selectorPrimaryFocus) || o.element.querySelector(fi.selectorTabbable);
          p.focus(), process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && cf(p, "Modals need to contain a focusable element by either using " + "`".concat(o.options.selectorPrimaryFocus, "` or settings.selectorTabbable."));
        }
        a();
      };
      if (this._handleFocusinListener && (this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release()), i === "shown") {
        var h = "onfocusin" in this.element.ownerDocument.defaultView, d = h ? "focusin" : "focus";
        this._handleFocusinListener = this.manage(On(this.element.ownerDocument, d, this._handleFocusin, !h));
      }
      i === "hidden" ? (this.element.classList.toggle(this.options.classVisible, !1), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !1), (this.options.selectorFocusOnClose || this.previouslyFocusedNode) && (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus()) : i === "shown" && (this.element.classList.toggle(this.options.classVisible, !0), this.element.ownerDocument.body.classList.toggle(this.options.classBody, !0)), c = this.manage(On(this.element, "transitionend", l));
    }
  }, {
    key: "_hookCloseActions",
    value: function() {
      var i = this;
      this.manage(On(this.element, "click", function(r) {
        var a = Ji(r, i.options.selectorModalClose);
        a && (r.delegateTarget = a), (a || r.target === i.element) && i.hide(r);
      })), this._handleKeydownListener && (this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release()), this._handleKeydownListener = this.manage(On(this.element.ownerDocument.body, "keydown", function(r) {
        r.which === 27 && i.shouldStateBeChanged("hidden") && (r.stopPropagation(), i.hide(r));
      }));
    }
    /**
     * Handles `focusin` (or `focus` depending on browser support of `focusin`) event to do wrap-focus behavior.
     * @param {Event} evt The event.
     * @private
     */
  }], [{
    key: "options",
    get: (
      /**
       * The component options.
       * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
       * properties in this object are overridden for the instance being create and how {@linkcode Modal.init .init()} works.
       * @member Modal.options
       * @type {object}
       * @property {string} selectorInit The CSS class to find modal dialogs.
       * @property {string} [selectorModalClose] The selector to find elements that close the modal.
       * @property {string} [selectorPrimaryFocus] The CSS selector to determine the element to put focus when modal gets open.
       * @property {string} [selectorFocusOnClose] The CSS selector to determine the element to put focus when modal closes.
       *   If undefined, focus returns to the previously focused element prior to the modal opening.
       * @property {string} [selectorModalContainer] The CSS selector for the content container of the modal for focus wrap feature.
       * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
       * @property {string[]} [selectorsFloatingMenu]
       *   The CSS selectors of floating menus.
       *   Used for detecting if focus-wrap behavior should be disabled temporarily.
       * @property {string} [classVisible] The CSS class for the visible state.
       * @property {string} [classBody] The CSS class for `<body>` with open modal.
       * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
       * @property {string} [eventBeforeShown]
       *   The name of the custom event fired before this modal is shown.
       *   Cancellation of this event stops showing the modal.
       * @property {string} [eventAfterShown]
       *   The name of the custom event telling that modal is sure shown
       *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
       * @property {string} [eventBeforeHidden]
       *   The name of the custom event fired before this modal is hidden.
       *   Cancellation of this event stops hiding the modal.
       * @property {string} [eventAfterHidden]
       *   The name of the custom event telling that modal is sure hidden
       *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
       */
      function() {
        var i = fi.prefix;
        return {
          selectorInit: "[data-modal]",
          selectorModalClose: "[data-modal-close]",
          selectorPrimaryFocus: "[data-modal-primary-focus]",
          selectorsFloatingMenus: [".".concat(i, "--overflow-menu-options"), ".".concat(i, "--tooltip"), ".flatpickr-calendar"],
          selectorModalContainer: ".".concat(i, "--modal-container"),
          classVisible: "is-visible",
          classBody: "".concat(i, "--body--with-modal-open"),
          attribInitTarget: "data-modal-target",
          initEventNames: ["click"],
          eventBeforeShown: "modal-beingshown",
          eventAfterShown: "modal-shown",
          eventBeforeHidden: "modal-beinghidden",
          eventAfterHidden: "modal-hidden"
        };
      }
    )
  }]), e.components = /* @__PURE__ */ new WeakMap(), e;
}(yp(wp, yf, af, Pp));
class d0 extends ot {
  constructor(t, e, n) {
    super(t, e, n), this.type = "modal", this.isEventListenerAdded = !1, this.handleShowModal = () => {
      const i = this.services.domUtils.getChartID();
      this.modal.attr("data-modal", !0).attr("class", "cds--modal").attr("role", "dialog").attr("aria-modal", !0).attr("aria-labelledby", `${i}__modal-title`).attr("aria-describedby", `${i}__modal-description`).attr("tabindex", -1), this.modal.html(this.getModalHTML()), this.modal.select("div.cds--modal-footer button.cds--btn").on("click", () => this.model.exportToCSV()), Lf.create(this.modal.node()).show(), document.addEventListener("modal-hidden", this.handleHideModal);
    }, this.handleHideModal = () => {
      this.modal.attr("role", null).attr("aria-modal", null).attr("aria-labelledby", null).attr("aria-describedby", null).attr("tabindex", null), document.removeEventListener("modal-hidden", this.handleHideModal);
    }, this.init();
  }
  addEventListeners() {
    this.services.events.addEventListener(x.Modal.SHOW, this.handleShowModal);
  }
  removeEventListeners() {
    this.services.events.removeEventListener(x.Modal.SHOW, this.handleShowModal);
  }
  getModalHTML() {
    const t = this.services.domUtils.getChartID(), e = this.model.getOptions(), { title: n, downloadAsCSV: i } = T(e, "locale", "translations", "tabularRep"), r = T(e, "style", "prefix"), a = this.model.getTabularDataArray();
    return `
		<div class="cds--modal-container">
			<div class="cds--modal-header">

				<p class="cds--modal-header__label cds--type-delta" id="modal-title">${n}</p>

				<p class="cds--modal-header__heading cds--type-beta" id="${t}__modal-description">${ue(
      e.title
    )}</p>

				<button class="cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>
					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="cds--modal-close__icon">
						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>
					</svg>
				</button>
			</div>

			<div class="cds--modal-content">
				<table class="cds--data-table cds--data-table--no-border">
					<thead>
						<tr>
							${yt(a, 0).map(
      (o) => `<th scope="col">
								<div class="cds--table-header-label">${ue(o)}</div>
							</th>`
    ).join("")}
						</tr>
					</thead>

					<tbody>${a.slice(1).map(
      (o) => `
							<tr>
								${o.map((c) => `<td>${ue(c)}</td>`).join("")}
							</tr>`
    ).join("")}
					</tbody>
				</table>
			</div>

			<div class="cds--modal-footer">
			  <div class="${qt}--${r}-modal-footer-spacer"></div>
			  <button class="cds--btn cds--btn--primary" type="button" data-modal-primary-focus>${i}</button>
			</div>
		</div>`;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.model.getOptions();
    if (!this.isEventListenerAdded) {
      const n = R(this.services.domUtils.getHolder()), i = T(e, "style", "prefix");
      this.modal = _.appendOrSelect(n, `div.${qt}--${i}--modal`), this.addEventListeners(), this.isEventListenerAdded = !0;
    }
  }
  destroy() {
    this.removeEventListeners(), this.isEventListenerAdded = !1;
  }
}
class Af extends ot {
  constructor() {
    super(...arguments), this.type = "title", this.renderType = st.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getComponentContainer(), n = T(this.getOptions(), "title"), i = e.selectAll("p.title").data([n]);
    if (i.enter().append("p").classed("title", !0).attr("role", "heading").attr("aria-level", 2).merge(i).html((r) => ue(r)), i.node() && i.node().offsetWidth < i.node().scrollWidth) {
      const r = this;
      i.on("mouseover", function(a) {
        r.services.events.dispatchEvent(x.Tooltip.SHOW, {
          event: a,
          hoveredElement: i,
          content: i.text()
        });
      }).on("mousemove", function(a) {
        r.services.events.dispatchEvent(x.Tooltip.MOVE, {
          event: a
        });
      }).on("mouseout", function() {
        r.services.events.dispatchEvent(x.Tooltip.HIDE);
      });
    }
    i.exit().remove();
  }
  /**
   * Truncates title creating ellipses and attaching tooltip for exposing full title.
   */
  truncateTitle(t, e) {
    if (e <= 0)
      return;
    const n = t.text();
    if (t.node().getComputedTextLength() > e) {
      t.append("tspan").text("...");
      const i = _.appendOrSelect(t, "tspan").node().getComputedTextLength(), r = t.text(), a = this.getSubstringIndex(
        t.node(),
        0,
        r.length - 1,
        e - i
      );
      t.html(r.substring(0, a - 1)).append("tspan").text("...");
      const o = this;
      t.on("mouseover", function(c) {
        o.services.events.dispatchEvent(x.Tooltip.SHOW, {
          event: c,
          hoveredElement: t,
          content: n
        });
      }).on("mousemove", function(c) {
        o.services.events.dispatchEvent(x.Tooltip.MOVE, {
          event: c
        });
      }).on("mouseout", function() {
        o.services.events.dispatchEvent(x.Tooltip.HIDE);
      });
    }
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    return _.getSVGElementSize(this.parent.node(), {
      useAttrs: !0
    }).width;
  }
  /**
   * Returns the index for a maximum length substring that is less than the width parameter.
   * @param title the title node used for getting the text lengths of substrings
   * @param start the start index for the binary search
   * @param end the end index for the binary search
   * @param width the width of the svg container that holds the title
   */
  getSubstringIndex(t, e, n, i) {
    const r = Math.floor((n + e) / 2);
    return t.getSubStringLength(0, r) > i ? this.getSubstringIndex(t, e, r, i) : t.getSubStringLength(0, r) < i ? t.getSubStringLength(0, r + 1) > i ? r : this.getSubstringIndex(t, r, n, i) : r;
  }
}
class Mf extends ot {
  constructor() {
    super(...arguments), this.type = "legend", this.renderType = st.HTML;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = T(e, "legend"), i = T(n, "alignment"), r = T(e, "legend", "orientation");
    let a = this.model.getDataGroups();
    const { DISABLED: o } = wt.items.status, c = a.some((y) => y.status === o), l = T(n, "order"), h = this.getComponentContainer().classed("center-aligned", i === Jt.CENTER).classed("right-aligned", i === Jt.RIGHT).classed(r, !0).classed("has-deactivated-items", c).attr("role", it.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
    l && (a = this.sortDataGroups(a, l));
    const d = h.selectAll("div.legend-item").data(a, (y) => y.name), u = d.enter().append("div").attr("class", "legend-item");
    u.merge(h.selectAll("div.legend-item")).classed("active", function(y) {
      return y.status === wt.items.status.ACTIVE;
    });
    const p = T(this.getOptions(), "legend", "clickable");
    h.classed("clickable", p && a.length > 1);
    const f = wt.checkbox.radius, g = u.append("div").classed("checkbox", !0), m = g.merge(d.select("div.checkbox")).attr("role", it.CHECKBOX).attr("tabindex", p ? 0 : -1).attr(
      "aria-labelledby",
      (y, v) => this.services.domUtils.generateElementIDString(`legend-datagroup-${v}-title`)
    ).attr("aria-checked", ({ status: y }) => y === wt.items.status.ACTIVE).attr("width", f * 2).attr("height", f * 2).attr(
      "class",
      (y) => this.model.getColorClassName({
        classNameTypes: [tt.BACKGROUND],
        dataGroupName: y.name,
        originalClassName: "checkbox"
      })
    ).style(
      "background",
      (y) => y.status === wt.items.status.ACTIVE ? this.model.getFillColor(y.name) || this.model.getStrokeColor(y.name) : null
    ).classed("active", function(y) {
      return y.status === wt.items.status.ACTIVE;
    });
    g.append("svg").attr("focusable", !1).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", !0).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z"), u.append("p").merge(d.select("p"));
    const E = T(e, "legend", "additionalItems");
    if (E && a.length) {
      const y = this, v = h.selectAll("div.additional-item").data(E);
      v.exit().remove();
      const S = v.enter().append("div").merge(v).classed("legend-item", !0).classed("additional", !0).attr(
        "aria-labelledby",
        (I, k) => this.services.domUtils.generateElementIDString(
          `legend-datagroup-${m.size() + k}-title`
        )
      );
      S.selectAll("*").remove();
      let b, O = 1;
      S.append("svg").classed("icon", !0).each(function(I) {
        const k = R(this);
        !b || b != I.type ? (b = I.type, O = 1) : O++, y.addAdditionalItem(k, I, O);
      }), S.append("p").merge(S.select("p")), this.truncateLegendText();
    }
    d.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove(), p && u.size() > 1 && this.addEventListeners();
  }
  sortDataGroups(t, e) {
    if (t.sort(
      (n, i) => e.indexOf(n.name) - e.indexOf(i.name)
    ), e.length < t.length) {
      const n = t.length - e.length;
      return t.slice(n).concat(t.slice(0, n));
    }
    return t;
  }
  addAdditionalItem(t, e, n) {
    const { width: i, height: r } = wt.area;
    if (e.type === Oe.RADIUS ? t.style("width", `${r}px`).style("height", `${r}px`) : t.style("width", `${i}px`).style("height", `${r}px`), e.type === Oe.RADIUS) {
      const { iconData: a, fill: o, stroke: c } = wt.radius;
      t.attr("fill", "none").selectAll("circle").data(a).enter().append("circle").classed("radius", !0).attr("role", it.IMG).attr("aria-label", "radius").attr("cx", (h) => h.cx).attr("cy", (h) => h.cy).attr("r", (h) => h.r).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c);
    } else if (e.type === Oe.LINE) {
      const a = wt.line;
      t.select("line.line").empty() && t.append("line").classed(`line-${n}`, !0).attr("role", it.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", a.yPosition).attr("x2", i).attr("y2", a.yPosition).style("stroke", e.stroke ? e.stroke : a.stroke).style("stroke-width", a.strokeWidth);
    } else if (e.type === Oe.AREA)
      t.select("rect.area").empty() && t.append("rect").classed(`area-${n}`, !0).attr("role", it.IMG).attr("aria-label", "area").attr("width", i).attr("height", r).style(
        "fill",
        n > 3 && !e.fill ? wt.area.fill : e.fill
      ).style("stroke", e.stroke);
    else if (e.type === Oe.SIZE) {
      const { iconData: a, fill: o, stroke: c } = wt.size;
      t.attr("fill", "none").attr("role", it.IMG).attr("aria-label", "size").selectAll("rect").data(a).enter().append("rect").classed("size", !0).attr("width", (h) => h.width).attr("height", (h) => h.height).attr("y", () => 0).style("fill", e.fill ? e.fill : o).style("stroke", e.stroke ? e.stroke : c).style("stroke-width", 1);
    } else if (e.type === Oe.QUARTILE) {
      const { iconData: a } = wt.quartile;
      t.selectAll("rect").attr("role", it.IMG).attr("aria-label", "quartile").data(a).enter().append("rect").attr("class", (c, l) => `quartile-${l === 0 ? "wrapper" : "line"}`).attr("x", (c) => c.x).attr("y", (c) => c.y).attr("width", (c) => c.width).attr("height", (c) => c.height);
    } else if (e.type === Oe.ZOOM) {
      const { iconData: a, color: o } = T(wt, "zoom"), c = t.attr("role", it.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(a).enter();
      c.append("g").attr("x", (l) => l.x).attr("y", (l) => l.y).attr("width", (l) => l.width).attr("height", (l) => l.height).append("polygon").attr(
        "points",
        "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82"
      ).attr("fill", () => e.color ? e.color : o), c.append("path").attr(
        "d",
        "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z"
      ).attr("fill", () => e.color ? e.color : o);
    }
  }
  truncateLegendText() {
    const t = this.getComponentContainer(), e = T(this.getOptions(), "legend", "truncation"), n = T(e, "type"), i = T(e, "threshold"), r = T(e, "numCharacter"), a = t.selectAll("div.legend-item p");
    a.attr("id", function() {
      return (this.parentNode.querySelector("div.checkbox") || this.parentNode).getAttribute("aria-labelledby");
    }), n !== Ze.NONE ? a.html(function(o) {
      const c = ue(o.name);
      return c.length > i && c.length !== r ? Cn(c, n, r) : c;
    }) : a.html((o) => ue(o.name));
  }
  addEventListeners() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), i = T(n, "legend"), r = T(i, "truncation");
    e.selectAll("div.legend-item").on("mouseover", function(a) {
      t.services.events.dispatchEvent(x.Legend.ITEM_HOVER, {
        hoveredElement: R(this)
      });
      const o = R(this);
      o.select("div.checkbox").classed("hovered", !0);
      const c = o.datum();
      c.name.length > r.threshold && r.numCharacter < c.name.length && r.type !== Ze.NONE && t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: c.name
      });
    }).on("mousemove", function(a) {
      R(this).datum().name.length > r.threshold && r.type !== Ze.NONE && t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function() {
      t.services.events.dispatchEvent(x.Legend.ITEM_CLICK, {
        clickedElement: R(this)
      });
      const o = R(this).datum();
      t.model.toggleDataLabel(o.name);
    }).on("mouseout", function() {
      const a = R(this);
      a.select("div.checkbox").classed("hovered", !1), a.datum().name.length > r.threshold && r.type !== Ze.NONE && t.services.events.dispatchEvent(x.Tooltip.HIDE), t.services.events.dispatchEvent(x.Legend.ITEM_MOUSEOUT, {
        hoveredElement: a
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keyup", function(a) {
      a.key && a.key === "Tab" && t.services.events.dispatchEvent(x.Legend.ITEM_HOVER, {
        hoveredElement: R(this)
      });
    }), e.selectAll("div.legend-item div.checkbox").on("keydown", function(a, o) {
      a.key && a.key === " " ? (a.preventDefault(), t.model.toggleDataLabel(o.name)) : a.key && a.key === "Tab" && t.services.events.dispatchEvent(x.Legend.ITEM_MOUSEOUT, {
        hoveredElement: R(this)
      });
    }), e.selectAll("g.additional-item").on("mouseover", function(a) {
      const o = R(this), c = o.datum();
      c.name.length > r.threshold && t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: a,
        hoveredElement: o,
        content: c.name
      });
    });
  }
}
class _f extends ot {
  constructor(t, e, n) {
    super(t, e, n), this.type = "chart-clip", this.renderType = st.SVG, this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999), this.init();
  }
  init() {
    this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: !0 });
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    this.createClipPath();
  }
  createClipPath() {
    const t = this.parent, { cartesianScales: e } = this.services;
    if (!e) throw new Error("Service cartesianScales was undefined");
    const n = e.getMainXScale(), i = e.getMainYScale(), [r, a] = n.range(), [o, c] = i.range();
    if (!t)
      throw new Error("svg is undefined");
    this.chartClipPath = _.appendOrSelect(
      t,
      `clipPath.${this.type}`
    ).attr("id", this.chartClipId);
    const l = _.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    a - r > 0 && l.attr("x", r).attr("y", c).attr("width", a - r).attr("height", o - c), this.chartClipPath.merge(l).lower();
  }
}
class p0 extends _f {
  constructor() {
    super(...arguments), this.type = "canvas-chart-clip", this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
  }
  createClipPath() {
    const t = this.parent, { width: e, height: n } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    this.chartClipPath = _.appendOrSelect(t, `clipPath.${this.type}`).attr(
      "id",
      this.chartClipId
    );
    const i = _.appendOrSelect(this.chartClipPath, `rect.${this.type}`);
    i.attr("x", 0).attr("y", 0).attr("width", e).attr("height", n), this.chartClipPath.merge(i).lower();
  }
}
var Fe, Ot;
(function(s) {
  s.LEFT = "left", s.RIGHT = "right", s.TOP = "top", s.BOTTOM = "bottom";
})(Ot || (Ot = {}));
var Ka = (Fe = {}, Fe[Ot.LEFT] = function(s, t, e) {
  return {
    top: s.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(s.left - t.offsetWidth)
  };
}, Fe[Ot.RIGHT] = function(s, t, e) {
  return {
    top: s.top - Math.round(t.offsetHeight / 2) + Math.round(e.height / 2),
    left: Math.round(s.left + e.width)
  };
}, Fe[Ot.TOP] = function(s, t, e) {
  return {
    top: Math.round(s.top - t.offsetHeight),
    left: s.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Fe[Ot.BOTTOM] = function(s, t, e) {
  return {
    top: Math.round(s.top + e.height),
    left: s.left - Math.round(t.offsetWidth / 2) + Math.round(e.width / 2)
  };
}, Fe), Ja = typeof window < "u" ? window : {
  innerHeight: 0,
  scrollY: 0,
  innerWidth: 0,
  scrollX: 0
}, Ns = (
  /** @class */
  function() {
    function s(t) {
      t === void 0 && (t = {}), this.positions = Ka, this.positions = Object.assign({}, Ka, t);
    }
    return s.prototype.getRelativeOffset = function(t) {
      for (var e = {
        left: t.offsetLeft,
        top: t.offsetTop
      }; t.offsetParent && getComputedStyle(t.offsetParent).position === "static"; )
        e.left += t.offsetLeft, e.top += t.offsetTop, t = t.offsetParent;
      return e;
    }, s.prototype.getAbsoluteOffset = function(t) {
      for (var e = t, n = {
        top: 0,
        left: 0
      }; e.offsetParent; ) {
        var i = getComputedStyle(e.offsetParent);
        i.position === "static" && i.marginLeft && i.marginTop && (parseInt(i.marginTop, 10) && (n.top += parseInt(i.marginTop, 10)), parseInt(i.marginLeft, 10) && (n.left += parseInt(i.marginLeft, 10))), e = e.offsetParent;
      }
      var r = t.getBoundingClientRect(), a = document.body.getBoundingClientRect();
      return {
        top: r.top - a.top + n.top,
        left: r.left - a.left + n.left
      };
    }, s.prototype.findRelative = function(t, e, n) {
      var i = this.getRelativeOffset(t), r = t.getBoundingClientRect();
      return this.calculatePosition(i, r, e, n);
    }, s.prototype.findAbsolute = function(t, e, n) {
      var i = this.getAbsoluteOffset(t), r = t.getBoundingClientRect();
      return this.calculatePosition(i, r, e, n);
    }, s.prototype.findPosition = function(t, e, n, i) {
      i === void 0 && (i = this.getAbsoluteOffset.bind(this));
      var r = i(t), a = t.getBoundingClientRect();
      return this.calculatePosition(r, a, e, n);
    }, s.prototype.findPositionAt = function(t, e, n) {
      return this.calculatePosition(t, { top: 0, left: 0, height: 0, width: 0 }, e, n);
    }, s.prototype.getPlacementBox = function(t, e) {
      var n = t.offsetHeight + e.top, i = t.offsetWidth + e.left;
      return {
        top: e.top,
        bottom: n,
        left: e.left,
        right: i
      };
    }, s.prototype.addOffset = function(t, e, n) {
      return e === void 0 && (e = 0), n === void 0 && (n = 0), Object.assign({}, t, {
        top: t.top + e,
        left: t.left + n
      });
    }, s.prototype.setElement = function(t, e) {
      t.style.top = e.top + "px", t.style.left = e.left + "px";
    }, s.prototype.findBestPlacement = function(t, e, n, i, r) {
      var a = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this)), r === void 0 && (r = this.findPosition.bind(this));
      var o = n.map(function(c) {
        var l = r(t, e, c), h = a.getPlacementBox(e, l), d = 0, u = 0, p = i();
        h.top < p.top ? d = p.top - h.top : h.bottom > p.height && (d = h.bottom - p.height), h.left < p.left ? u = p.left - h.left : h.right > p.width && (u = h.right - p.width), d && !u ? u = 1 : u && !d && (d = 1);
        var f = e.offsetHeight * e.offsetWidth, g = d * u, m = f - g, E = m / f;
        return {
          placement: c,
          weight: E
        };
      });
      return o.sort(function(c, l) {
        return l.weight - c.weight;
      }), o[0].placement;
    }, s.prototype.findBestPlacementAt = function(t, e, n, i) {
      var r = this;
      i === void 0 && (i = this.defaultContainerFunction.bind(this));
      var a = function(o, c, l) {
        return r.findPositionAt(t, c, l);
      };
      return this.findBestPlacement(null, e, n, i, a);
    }, s.prototype.defaultContainerFunction = function() {
      return {
        // we go with window here, because that's going to be the simple/common case
        top: 0,
        left: 0,
        height: Ja.innerHeight,
        width: Ja.innerWidth
      };
    }, s.prototype.calculatePosition = function(t, e, n, i) {
      return this.positions[i] ? this.positions[i](t, n, e) : (console.error("No function found for placement, defaulting to 0,0"), { left: 0, top: 0 });
    }, s;
  }()
);
new Ns();
class Cf extends ot {
  constructor(t, e, n) {
    super(t, e, n), this.type = "tooltip", this.renderType = st.HTML, this.isEventListenerAdded = !1, this.lastTriggeredEventType = "", this.positionService = new Ns(), this.handleShowTooltip = (i) => {
      const r = i.detail.data || i.detail.items, a = R(i.detail.event.target).datum();
      let o;
      const c = this.formatItems(this.getItems(i));
      i.detail.content ? o = `<div class="title-tooltip"><p>${Qn(i.detail.content)}</p></div>` : o = Qn(this.getTooltipHTML(c));
      const l = _.appendOrSelect(this.tooltip, "div.content-box");
      if (T(this.getOptions(), "tooltip", "customHTML"))
        if (i.detail.content) {
          const h = `<div class="title-tooltip"><p>${Qn(
            i.detail.content
          )}</p></div>`;
          l.html(h);
        } else
          l.html(
            `<div class="title-tooltip"><p>${Qn(
              this.model.getOptions().tooltip.customHTML(r, o, a)
            )}</p></div>`
          );
      else
        l.html(o);
      l.selectAll(".datapoint-tooltip").each(function(h, d) {
        const u = c[d];
        c[d] && c[d].color && R(this).select(".tooltip-color").attr("class", "tooltip-color").style("background-color", u.color);
      }), this.positionTooltip(i), this.tooltip.classed("hidden", !1).attr("aria-hidden", !1), this.lastTriggeredEventType = i.type;
    }, this.handleHideTooltip = () => {
      this.tooltip.classed("hidden", !0).attr("aria-hidden", !0);
    }, this.init();
  }
  addTooltipEventListener() {
    this.services.events.addEventListener(x.Tooltip.MOVE, (t) => {
      this.lastTriggeredEventType !== x.Toolbar.SHOW_TOOLTIP && this.tooltip.classed("hidden") === !1 && this.positionTooltip(t);
    }), this.services.events.addEventListener(x.Tooltip.SHOW, this.handleShowTooltip), this.services.events.addEventListener(x.Tooltip.HIDE, this.handleHideTooltip), this.services.events.addEventListener(x.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.addEventListener(x.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.addEventListener(x.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  removeTooltipEventListener() {
    this.services.events.removeEventListener(x.Tooltip.MOVE, null), this.services.events.removeEventListener(x.Tooltip.SHOW, this.handleShowTooltip), this.services.events.removeEventListener(x.Tooltip.HIDE, this.handleHideTooltip), this.services.events.removeEventListener(x.Chart.MOUSEOUT, this.handleHideTooltip), this.services.events.removeEventListener(x.Toolbar.SHOW_TOOLTIP, this.handleShowTooltip), this.services.events.removeEventListener(x.Toolbar.HIDE_TOOLTIP, this.handleHideTooltip);
  }
  getItems(t) {
    return t.detail.items ? t.detail.items : [];
  }
  formatItems(t) {
    const e = this.getOptions(), n = T(e, "tooltip", "truncation", "type"), i = T(e, "tooltip", "truncation", "threshold"), r = T(e, "tooltip", "truncation", "numCharacter");
    return n !== Ze.NONE ? t.map((a) => {
      const o = a.labelIcon ? 12 : 0;
      return a.value = a.value ? this.valueFormatter(a.value, a.label) : a.value, a.label && a.label.length + o > i && (a.label = Cn(a.label, n, r)), a.value && a.value.length > i && (a.value = Cn(a.value, n, r)), a;
    }) : t.map((a) => (a.value = a.value ? this.valueFormatter(a.value, a.label) : a.value, a));
  }
  getTooltipHTML(t) {
    return '<ul class="multi-tooltip">' + t.map(
      (e) => `<li>
					<div class="datapoint-tooltip${e.bold ? " bold" : ""}">
						${e.class || e.color ? `<div class="tooltip-color ${e.class}"></div>` : ""}
						<div class="label">
						<p>${e.label || ""}</p>
						${e.labelIcon ? `<span class="label-icon"/>${e.labelIcon}</span>` : ""}
						</div>
						${e.value === void 0 || e.value === null ? "" : `<p class="value"/>${e.value}</p>`}
					</div>
				</li>`
    ).join("") + "</ul>";
  }
  isDate(t) {
    return t instanceof Date;
  }
  valueFormatter(t, e) {
    const n = this.getOptions(), i = T(n, "tooltip", "valueFormatter"), {
      code: r,
      number: a,
      date: o
    } = T(n, "locale");
    if (i)
      return i(t, e);
    if (this.isDate(t))
      return o(t, r, { month: "short", day: "numeric", year: "numeric" });
    try {
      if (typeof t == "string" && /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z/.test(t)) {
        const c = new Date(t);
        return o(c, r, {
          month: "short",
          day: "numeric",
          year: "numeric"
        });
      }
    } catch {
    }
    return a(t, r);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = T(e, "tooltip", "enabled");
    if (n) {
      const i = R(this.services.domUtils.getHolder()), r = T(e, "style", "prefix");
      this.tooltip = _.appendOrSelect(i, `div.${qt}--${r}--tooltip`), this.tooltip.style("max-width", null).attr("role", "tooltip"), this.isEventListenerAdded || (this.addTooltipEventListener(), this.isEventListenerAdded = !0), this.tooltip.classed("hidden", !0);
    } else !n && this.isEventListenerAdded && (this.removeTooltipEventListener(), this.isEventListenerAdded = !1);
  }
  addOffsetByPlacement(t, e, n) {
    const i = Object.assign({}, t);
    return e == Ot.LEFT ? i.left -= n : e == Ot.RIGHT ? i.left += n : e == Ot.TOP ? i.top -= n : e == Ot.BOTTOM && (i.top += n), i;
  }
  positionTooltip(t) {
    const e = this.services.domUtils.getHolder(), n = e.offsetWidth, i = e.offsetHeight, r = this.tooltip.node(), a = this.getOptions(), o = T(a, "zoomBar", "top", "enabled"), c = !!T(t, "detail", "noWrap"), l = Array.isArray(T(t, "detail", "placements")), h = l ? T(t, "detail", "placements") : [Ot.RIGHT, Ot.LEFT, Ot.TOP, Ot.BOTTOM];
    let d, { horizontalOffset: u } = Wr;
    const { defaultOffset: p } = Wr;
    if (this.tooltip.select("div.title-tooltip").classed("title-tooltip-nowrap", c), l) {
      const m = T(t, "detail", "event", "target"), E = this.services.domUtils.getElementOffset(m, !0);
      d = this.positionService.findBestPlacementAt(
        E,
        r,
        h,
        () => ({
          top: 0,
          left: 0,
          width: n,
          height: i
        })
      );
      let y = this.positionService.findPosition(
        m,
        r,
        d,
        () => this.services.domUtils.getElementOffset(m)
      );
      y = this.addOffsetByPlacement(y, d, p), this.positionService.setElement(r, y);
      return;
    }
    let f = T(t, "detail", "mousePosition");
    if (!f)
      f = en(T(t, "detail", "event"), e);
    else {
      const m = T(a, "zoomBar", "top", "type"), E = Yt.height[m];
      o && (f[1] += E + Yt.spacerHeight);
    }
    f[0] / n > 0.9 ? d = Ot.LEFT : f[0] / n < 0.1 ? d = Ot.RIGHT : d = this.positionService.findBestPlacementAt(
      {
        left: f[0],
        top: f[1]
      },
      r,
      h,
      () => ({
        top: void 0,
        // properties were never set to optional (probably should)
        left: void 0,
        // ditto
        width: n,
        height: i
      })
    ), d === Ot.LEFT && (u *= -1);
    const g = this.positionService.findPositionAt(
      {
        left: f[0] + u,
        top: f[1]
      },
      r,
      d
    );
    this.positionService.setElement(r, g);
  }
}
const Qe = class Qe extends ot {
  constructor() {
    super(...arguments), this.type = "grid-brush", this.renderType = st.SVG, this.selectionSelector = "rect.selection", this.frontSelectionSelector = "rect.frontSelection";
  }
  // needs to match the class name in _grid-brush.scss
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.parent, n = this.getComponentContainer();
    if (!e) throw new Error("SVG was not defined");
    const i = _.appendOrSelect(
      e,
      "svg.chart-grid-backdrop"
    ), r = _.appendOrSelect(i, `g.${this.type}`), a = _.appendOrSelect(r, this.selectionSelector), { width: o, height: c } = _.getSVGElementSize(i, {
      useAttrs: !0
    }), { cartesianScales: l } = this.services, h = l.getMainXScaleType(), d = l.getMainXScale(), [u] = d.range();
    n.attr("transform", `translate(${u},0)`);
    const p = _.appendOrSelect(n, this.frontSelectionSelector);
    if (d && h === Mt.TIME) {
      let f = this.model.get("zoomDomain");
      f === void 0 && (f = this.services.zoom.getDefaultZoomBarDomain(), f && this.model.set({ zoomDomain: f }, { animate: !1 }));
      const g = (b) => {
        const O = b[1] - b[0];
        let I = "0," + O.toString();
        const k = Math.floor(c / Qe.DASH_LENGTH), G = k * Qe.DASH_LENGTH;
        for (let C = 0; C < k; C++)
          I += "," + Qe.DASH_LENGTH;
        I += "," + (c - G), k % 2 === 1 && (I += ",0"), I += "," + O.toString(), I += "," + c.toString(), p.attr("stroke-dasharray", I);
      }, m = (b) => {
        const O = b.selection;
        O === null || O[0] === O[1] || (p.attr("x", parseFloat(a.attr("x")) + parseFloat(i.attr("x"))).attr("y", a.attr("y")).attr("width", a.attr("width")).attr("height", a.attr("height")).style("cursor", "pointer").style("display", null), g(O));
      }, E = (b, O) => {
        const I = rc().range([0, o]).domain(f);
        let k = [I.invert(b), I.invert(O)];
        k[0].valueOf() === k[1].valueOf() && (k = this.services.zoom.getDefaultZoomBarDomain()), (f[0].valueOf() !== k[0].valueOf() || f[1].valueOf() !== k[1].valueOf()) && this.services.zoom.handleDomainChange(k);
      };
      let y;
      const v = (b) => {
        const O = b.selection;
        O !== null && (E(O[0], O[1]), r.call(y.move, null), p.style("display", "none"));
      };
      c != 0 && o != 0 && (y = Ho().extent([
        [0, 0],
        [o - 1, c]
      ]).on("start brush end", m).on("end.brushed", v), r.call(y));
      const S = this.services.zoom.getZoomRatio();
      i.on("click", function(b) {
        if (b.shiftKey) {
          const O = this.services.domUtils.getHolder(), I = en(r.node(), O)[0];
          let k = I - o * S / 2;
          k < 0 && (k = 0);
          let G = I + o * S / 2;
          G > o && (G = o), E(k, G);
        }
      });
    }
  }
};
Qe.DASH_LENGTH = 4;
let Qa = Qe;
class f0 extends ot {
  constructor() {
    super(...arguments), this.type = "zoom-bar", this.renderType = st.SVG, this.MIN_SELECTION_DIFF = 9e-10, this.brushSelector = "g.zoom-bar-brush", this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999), this.brush = Ho(), this.highlightStrokeWidth = 1;
  }
  init() {
    this.services.events.addEventListener(x.ZoomBar.UPDATE, this.render.bind(this));
    const t = T(this.getOptions(), "zoomBar", Y.TOP, "data");
    this.model.setZoomBarData(t);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer(), n = this.services.zoom.isZoomBarLoading(Y.TOP), i = this.services.zoom.isZoomBarLocked(Y.TOP), r = T(this.getOptions(), "zoomBar", Y.TOP, "type"), a = T(this.getOptions(), "axes", Y.BOTTOM, "highlights"), o = Yt.height[r], { width: c } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (c === 0)
      return;
    let l = 0;
    const h = this.model.get("axesMargins");
    h && h.left && (l = h.left);
    const d = _.appendOrSelect(e, "svg.zoom-container").attr("width", "100%").attr("height", o).attr("opacity", 1);
    if (_.appendOrSelect(e, "rect.zoom-spacer").attr("x", 0).attr("y", o).attr("width", "100%").attr("height", Yt.spacerHeight).attr("opacity", 1).attr("fill", "none"), r === Ge.GRAPH_VIEW ? _.appendOrSelect(d, "rect.zoom-bg").attr("x", l).attr("y", 0).attr("width", c - l).attr("height", "100%").classed("zoom-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ) : r === Ge.SLIDER_VIEW && _.appendOrSelect(d, "rect.zoom-slider-bg").attr("x", l).attr("y", o / 2 - 1).attr("width", c - l).attr("height", 2).classed("zoom-slider-bg-skeleton", n).style(
      "stroke",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    ), n) {
      this.renderSkeleton(d, l, c);
      return;
    }
    const { cartesianScales: u } = this.services, p = u.getMainXScale(), f = u.getMainYScale(), g = u.getMainXScaleType();
    if (p && g === Mt.TIME) {
      let m = this.services.zoom.getZoomBarData();
      if (Eo(m) || m.length === 1)
        return;
      this.xScale = p.copy(), this.yScale = f.copy();
      const E = this.services.zoom.getDefaultZoomBarDomain(m);
      m = this.compensateDataForDefaultDomain(m, E);
      const y = this.model.get("initialZoomDomain"), v = T(
        this.getOptions(),
        "zoomBar",
        Y.TOP,
        "initialZoomDomain"
      );
      v && v[0] && v[1] && (v[0] = new Date(v[0]), v[1] = new Date(v[1])), v && !(y && y[0].valueOf() === v[0].valueOf() && y[1].valueOf() === v[1].valueOf()) ? this.model.set(
        {
          // use a new object instead of newInitialZoomDomain
          initialZoomDomain: tn([], v),
          zoomDomain: v ? tn([], v) : E
        },
        { skipUpdate: !0 }
      ) : v === null && y !== null && this.model.set(
        {
          initialZoomDomain: null,
          zoomDomain: tn([], E)
        },
        { skipUpdate: !0 }
      ), this.xScale.range([l, c]).domain(E), this.maxSelectionRange = this.xScale.range(), this.yScale.range([0, o - 6]).domain(ks(m, (O) => O.value));
      const S = this.model.get("zoomDomain");
      if (r === Ge.GRAPH_VIEW && (this.renderZoomBarArea(d, "path.zoom-graph-area-unselected", m, null), this.updateClipPath(e, this.clipId, 0, 0, 0, 0), this.renderZoomBarArea(d, "path.zoom-graph-area", m, this.clipId), this.renderZoomBarBaseline(d, l, c), a)) {
        const O = a.highlightStartMapsTo, I = a.highlightEndMapsTo, k = a.color, G = a.labelMapsTo;
        a.data.forEach((C, L) => {
          _.appendOrSelect(d, `rect.highlight-${L}`).attr("height", o - 2 * this.highlightStrokeWidth).attr("y", this.highlightStrokeWidth).attr("x", this.xScale(C[O])).attr(
            "width",
            this.xScale(C[I]) - this.xScale(C[O])
          ).style(
            "fill",
            k && k.scale[C[G]] ? k.scale[C[G]] : null
          ).style("fill-opacity", 0.1).style(
            "stroke",
            k && k.scale[C[G]] ? k.scale[C[G]] : null
          ).style("stroke-dasharray", "2, 2").attr("stroke-width", "1px");
        });
      }
      this.addBrushEventListener(S, l, c);
      const b = _.appendOrSelect(e, this.brushSelector).call(this.brush);
      if (S !== void 0) if (S[0].valueOf() === S[1].valueOf())
        b.call(this.brush.move, this.xScale.range()), this.updateBrushHandle(this.getComponentContainer(), this.xScale.range());
      else {
        const O = S.map((I) => this.xScale(I));
        O[1] - O[0] < this.MIN_SELECTION_DIFF || (b.call(this.brush.move, O), this.updateBrushHandle(this.getComponentContainer(), O));
      }
      i && (this.brush.filter(() => !1), b.selectAll("rect").attr("cursor", "auto"));
    }
  }
  addBrushEventListener(t, e, n) {
    const i = (o) => {
      const c = o.selection;
      c === null ? this.handleBrushedEvent(o, t, this.xScale, this.xScale.range()) : c[0] === c[1] || this.handleBrushedEvent(o, t, this.xScale, c);
    }, r = T(this.getOptions(), "zoomBar", Y.TOP, "type"), a = Yt.height[r];
    this.brush.extent([
      [e, 0],
      [n, a]
    ]).on("start brush end", null).on("start brush end", i);
  }
  // brush event listener
  handleBrushedEvent(t, e, n, i) {
    const r = [n.invert(i[0]), n.invert(i[1])];
    if (this.updateBrushHandle(this.getComponentContainer(), i), t.sourceEvent != null && (t.sourceEvent.type === "mousemove" || t.sourceEvent.type === "mouseup" || t.sourceEvent.type === "mousedown" || t.sourceEvent.type === "touchstart" || t.sourceEvent.type === "touchmove" || t.sourceEvent.type === "touchend")) {
      (e === void 0 || e[0] !== r[0] || e[1] !== r[1]) && this.services.zoom.handleDomainChange(r, {
        dispatchEvent: !1
      });
      let a;
      t.type === "start" ? a = x.ZoomBar.SELECTION_START : t.type === "brush" ? a = x.ZoomBar.SELECTION_IN_PROGRESS : t.type === "end" && (a = x.ZoomBar.SELECTION_END, this.services.events.dispatchEvent(x.ZoomDomain.CHANGE, {
        newDomain: r
      })), this.services.events.dispatchEvent(a, {
        selection: i,
        newDomain: r
      });
    }
  }
  updateBrushHandle(t, e) {
    const n = this, i = Yt.handleWidth, r = T(this.getOptions(), "zoomBar", Y.TOP, "type"), a = Yt.height[r], o = -i / 2, c = Yt.handleBarWidth, l = r === Ge.GRAPH_VIEW ? Yt.handleBarHeight : 6, h = -c / 2, d = (a - l) / 2;
    t.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(p) {
      if (p.type === "w")
        return Math.max(e[0] + o, n.maxSelectionRange[0]);
      if (p.type === "e")
        return Math.min(e[1] + o, n.maxSelectionRange[1] - i);
    }).attr("y", 0).attr("width", i).attr("height", a).attr("cursor", "ew-resize").style("display", null);
    const u = t.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
    u.enter().append("rect").attr("class", function(p) {
      return "handle-bar handle-bar--" + p.type;
    }), u.attr("x", function(p) {
      if (p.type === "w")
        return Math.max(
          e[0] + h,
          n.maxSelectionRange[0] - o + h
        );
      if (p.type === "e")
        return Math.min(
          e[1] + h,
          n.maxSelectionRange[1] + o + h
        );
    }).attr("y", d).attr("width", c).attr("height", l).attr("cursor", "ew-resize"), r === Ge.SLIDER_VIEW && this.updateSliderSelectedArea(e), this.updateClipPath(
      t,
      this.clipId,
      e[0],
      0,
      e[1] - e[0],
      a
    );
  }
  updateSliderSelectedArea(t) {
    const e = T(this.getOptions(), "zoomBar", Y.TOP, "type"), n = Yt.height[e], r = this.getComponentContainer().select("svg.zoom-container");
    _.appendOrSelect(r, "rect.zoom-slider-selected-area").attr("x", t[0]).attr("y", n / 2 - 1).attr("width", t[1] - t[0]).attr("height", 2);
  }
  renderZoomBarArea(t, e, n, i) {
    const { cartesianScales: r } = this.services, a = r.getMainXAxisPosition(), o = r.getMainYAxisPosition(), c = r.getMainXScaleType(), l = r.getMainYScaleType(), h = (E, y, v) => (S) => r.getValueFromScale(E, y, v, S), d = h(this.xScale, c, a), u = h(this.yScale, l, o), p = T(this.getOptions(), "zoomBar", Y.TOP, "type"), f = Yt.height[p], g = yr().x((E) => d(E)).y0(f).y1((E) => f - u(E)), m = _.appendOrSelect(t, e).datum(n).attr("d", g);
    i && m.attr("clip-path", `url(#${i})`);
  }
  updateClipPath(t, e, n, i, r, a) {
    const o = _.appendOrSelect(t, "clipPath").attr("id", e);
    _.appendOrSelect(o, "rect").attr("x", n).attr("y", i).attr("width", r).attr("height", a);
  }
  // assume the domains in data are already sorted
  compensateDataForDefaultDomain(t, e) {
    if (!t || t.length < 2)
      return;
    const n = jl(t), i = this.services.cartesianScales.getDomainIdentifier(), r = this.services.cartesianScales.getRangeIdentifier();
    if (Number(e[0]) < Number(n[0][i])) {
      const a = {};
      a[i] = e[0], a[r] = 0, n.unshift(a);
    }
    if (Number(e[1]) > Number(n[n.length - 1][i])) {
      const a = {};
      a[i] = e[1], a[r] = 0, n.push(a);
    }
    return n;
  }
  renderZoomBarBaseline(t, e, n, i = !1) {
    const r = T(
      this.model.getOptions(),
      "zoomBar",
      Y.TOP,
      "type"
    ), a = Yt.height[r], o = Nn()([
      [e, a],
      [n, a]
    ]);
    _.appendOrSelect(t, "path.zoom-bg-baseline").attr("d", o).classed("zoom-bg-baseline-skeleton", i).style(
      "stroke",
      i ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  renderSkeleton(t, e, n) {
    this.renderZoomBarArea(t, "path.zoom-graph-area-unselected", [], null), this.renderZoomBarArea(t, "path.zoom-graph-area", [], this.clipId), this.brush.on("start brush end", null), _.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null), T(this.getOptions(), "zoomBar", Y.TOP, "type") === Ge.GRAPH_VIEW && this.renderZoomBarBaseline(t, e, n, !0);
  }
  destroy() {
    this.brush.on("start brush end", null), this.services.events.removeEventListener(x.ZoomBar.UPDATE, this.render.bind(this));
  }
}
class g0 extends ot {
  constructor(t, e) {
    super(t, e), this.type = "threshold", this.renderType = st.SVG, this.positionService = new Ns();
  }
  render(t = !1) {
    const e = T(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(Y).includes(u)) {
        const p = e[u];
        p.thresholds && p.thresholds.length > 0 && n.push({
          axisPosition: u,
          thresholds: p.thresholds,
          correspondingDatasets: p == null ? void 0 : p.correspondingDatasets,
          mapsTo: p == null ? void 0 : p.mapsTo
        });
      }
    });
    const r = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-thresholds").data(n, (u) => u.axisPosition);
    r.exit().attr("opacity", 0).remove();
    const o = r.enter().append("g").merge(r);
    o.attr("class", (u) => `axis-thresholds ${u.axisPosition}`);
    const c = o.selectAll("g.threshold-group").data(
      (u) => u.thresholds.map((p) => (p.axisPosition = u.axisPosition, p.datum = this.constructDatumObj(u, p), p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("line").attr("class", "threshold-line"), l.append("rect").attr("class", "threshold-hoverable-area"), l.merge(c).attr("class", "threshold-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getScaleByPosition(
        u
      ), f = d.services.cartesianScales.getScaleTypeByPosition(u);
      let g = null, m = null;
      u === Y.LEFT || u === Y.RIGHT ? (m = p, g = d.services.cartesianScales.getMainXScale()) : (g = p, m = d.services.cartesianScales.getMainYScale());
      const E = f === Mt.LABELS, [y, v] = g.range(), [S, b] = m.range(), { cartesianScales: O } = d.services, I = O.getOrientation(), k = (D) => O.getDomainValue(D), G = (D) => O.getRangeValue(D), [C, L] = ye(
        k,
        G,
        I
      ), B = R(this);
      u === Y.TOP || u === Y.BOTTOM ? (B.selectAll("line.threshold-line").transition().call(
        (D) => d.services.transitions.setupTransition({
          transition: D,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("y1", b).attr("y2", S).attr(
        "x1",
        ({ datum: D }) => C(D) + (E ? p.step() / 2 : 0)
      ).attr(
        "x2",
        ({ datum: D }) => C(D) + (E ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: D }) => D), B.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", ({ datum: D }) => -C(D)).attr("width", Math.abs(S - b)).classed("rotate", !0)) : (B.selectAll("line.threshold-line").transition().call(
        (D) => d.services.transitions.setupTransition({
          transition: D,
          name: "threshold-line-update",
          animate: t
        })
      ).attr("x1", y).attr("x2", v).attr(
        "y1",
        ({ datum: D }) => L(D) + (E ? p.step() / 2 : 0)
      ).attr(
        "y2",
        ({ datum: D }) => L(D) + (E ? p.step() / 2 : 0)
      ).style("stroke", ({ fillColor: D }) => D), B.selectAll("rect.threshold-hoverable-area").attr("x", y).attr("y", ({ datum: D }) => L(D)).attr("width", Math.abs(v - y)).classed("rotate", !1));
    }), this.services.events.addEventListener(x.Threshold.SHOW, (u) => {
      this.setThresholdLabelPosition(u.detail), this.label.classed("hidden", !1);
    }), this.services.events.addEventListener(x.Threshold.HIDE, () => {
      this.label.classed("hidden", !0);
    }), this.appendThresholdLabel(), this.addEventListeners();
  }
  getFormattedValue(t) {
    const { value: e, axisPosition: n } = t, i = this.getOptions(), r = this.services.cartesianScales.getScaleTypeByPosition(n), { code: a, number: o } = T(i, "locale");
    if (r === Mt.TIME) {
      const c = [Y.LEFT, Y.RIGHT].includes(n), l = this.services.cartesianScales.getMainXScale(), h = this.services.cartesianScales.getMainYScale(), d = c ? h : l, u = T(i, "timeScale"), p = yi(
        d.ticks(),
        T(u, "timeInterval")
      );
      return Ei(e, 0, d.ticks(), p, u, i.locale);
    }
    return o(e, a);
  }
  appendThresholdLabel() {
    const t = R(this.services.domUtils.getHolder()), e = T(this.getOptions(), "style", "prefix");
    this.label = _.appendOrSelect(
      t,
      `div.${qt}--${e}--threshold--label`
    ).classed("hidden", !0);
  }
  setThresholdLabelPosition({ event: t, datum: e }) {
    const n = this.services.domUtils.getHolder(), i = en(t, n), r = e.valueFormatter ? e.valueFormatter(e.value) : this.getFormattedValue(e);
    this.label.html(ue(`${e.label || "Threshold"}: ${r}`)).style("background-color", e.fillColor);
    const a = this.label.node(), o = this.positionService.findBestPlacementAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      [Ot.RIGHT, Ot.LEFT, Ot.TOP, Ot.BOTTOM],
      () => ({
        top: void 0,
        // other package lists this as non-optional
        left: void 0,
        // ditto
        width: n.offsetWidth,
        height: n.offsetHeight
      })
    ), c = this.positionService.findPositionAt(
      {
        left: i[0],
        top: i[1]
      },
      a,
      o
    );
    this.positionService.setElement(a, c);
  }
  // Constructs object to pass in scale functions
  constructDatumObj(t, e) {
    const n = {};
    return t.correspondingDatasets && (n.group = T(t, "correspondingDatasets", 0)), n[t.mapsTo] = e.value, n;
  }
  addEventListeners() {
    const t = this;
    this.getComponentContainer({ withinChartClip: !0 }).selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(n) {
      R(this.parentNode).select("line.threshold-line").classed("active", !0), t.services.events.dispatchEvent(x.Threshold.SHOW, {
        event: n,
        hoveredElement: R(this),
        datum: R(this).datum()
      });
    }).on("mouseout", function(n) {
      R(this.parentNode).select("line.threshold-line").classed("active", !1), t.services.events.dispatchEvent(x.Threshold.HIDE, {
        event: n,
        hoveredElement: R(this),
        datum: R(this).datum()
      });
    });
  }
}
class m0 extends ot {
  constructor(t, e) {
    super(t, e), this.type = "highlight", this.renderType = st.SVG, this.positionService = new Ns(), this.highlightStrokeWidth = 1;
  }
  render(t = !1) {
    const e = T(this.getOptions(), "axes"), n = [];
    Object.keys(e).forEach((u) => {
      if (Object.values(Y).includes(u)) {
        const p = e[u];
        p.highlights && p.highlights.data.length > 0 && n.push({
          axisPosition: u,
          highlightStartMapsTo: p.highlights.highlightStartMapsTo,
          highlightEndMapsTo: p.highlights.highlightEndMapsTo,
          labelMapsTo: p.highlights.labelMapsTo,
          highlight: p.highlights.data,
          color: p.highlights.color
        });
      }
    });
    const r = this.getComponentContainer({ withinChartClip: !0 }).selectAll("g.axis-highlight").data(n, (u) => u.axisPosition);
    r.exit().attr("opacity", 0).remove();
    const o = r.enter().append("g").merge(r);
    o.attr("class", (u) => `axis-highlight ${u.axisPosition}`);
    const c = o.selectAll("g.highlight-group").data(
      (u) => u.highlight.map((p) => (p.axisPosition = u.axisPosition, p.highlightStartMapsTo = u.highlightStartMapsTo, p.labelMapsTo = u.labelMapsTo, p.color = u.color, p.highlightEndMapsTo = u.highlightEndMapsTo, p))
    );
    c.exit().attr("opacity", 0).remove();
    const l = c.enter().append("g");
    l.append("rect").attr("class", "highlight-bar"), l.append("line").attr("class", "highlight-line"), l.merge(c).attr("class", "highlight-group");
    const d = this;
    o.each(function({ axisPosition: u }) {
      const p = d.services.cartesianScales.getMainXScale(), f = d.services.cartesianScales.getMainYScale(), [g, m] = p.range(), [E, y] = f.range(), { cartesianScales: v } = d.services, S = v.getOrientation(), b = (C) => v.getDomainValue(C), O = (C) => v.getRangeValue(C), [I, k] = ye(
        b,
        O,
        S
      ), G = R(this);
      u === Y.TOP || u === Y.BOTTOM ? G.selectAll("rect.highlight-bar").transition().call(
        (C) => d.services.transitions.setupTransition({
          transition: C,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("y", Math.max(y + d.highlightStrokeWidth, 0)).attr("height", Math.max(E - 2 * d.highlightStrokeWidth, 0)).attr("x", ({ highlightStartMapsTo: C, ...L }) => I(L[C])).attr(
        "width",
        ({ highlightStartMapsTo: C, highlightEndMapsTo: L, ...B }) => Math.max(I(B[L]) - I(B[C]), 0)
      ).style("stroke", ({ color: C, labelMapsTo: L, ...B }) => C && C.scale[B[L]] ? C.scale[B[L]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: C, labelMapsTo: L, ...B }) => C && C.scale[B[L]] ? C.scale[B[L]] : null) : G.selectAll("rect.highlight-bar").transition().call(
        (C) => d.services.transitions.setupTransition({
          transition: C,
          name: "highlight-bar-update",
          animate: t
        })
      ).attr("x", g).attr("width", Math.max(m - g, 0)).attr("y", ({ highlightEndMapsTo: C, ...L }) => k(L[C])).attr(
        "height",
        ({ highlightStartMapsTo: C, highlightEndMapsTo: L, ...B }) => Math.max(k(B[C]) - k(B[L]), 0)
      ).style("stroke", ({ color: C, labelMapsTo: L, ...B }) => C && C.scale[B[L]] ? C.scale[B[L]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", d.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", ({ color: C, labelMapsTo: L, ...B }) => C && C.scale[B[L]] ? C.scale[B[L]] : null);
    });
  }
}
class v0 extends Cf {
  getItems(t) {
    if (t.detail.items)
      return t.detail.items;
    const { data: e } = t.detail;
    if (!e || !e.length || !e[0])
      return [];
    const n = this.getOptions(), { cartesianScales: i } = this.services, r = i.getDomainIdentifier(), a = i.isDualAxes(), { groupMapsTo: o } = n.data, c = i.getDomainLabel();
    let l = i.getRangeLabel();
    const h = e[0][r];
    let d;
    if (e.length === 1) {
      const u = e[0], p = i.getRangeIdentifier(u);
      if (a) {
        const g = i.getRangeAxisPosition({
          datum: u,
          groups: [u[o]]
        });
        l = i.getScaleLabel(g);
      }
      const f = u[p];
      d = [
        {
          label: c,
          value: h
        },
        ...Array.isArray(f) && f.length === 2 ? [
          {
            label: "Start",
            value: f[0]
          },
          {
            label: "End",
            value: f[1]
          }
        ] : [
          {
            label: l,
            value: u[p]
          }
        ]
      ], t.detail.additionalItems && t.detail.additionalItems.forEach(
        (g) => d.push({
          label: g.label,
          value: g.value
        })
      ), d.push({
        label: yt(n, "locale.translations.group") || yt(n, "tooltip.groupLabel"),
        value: u[o],
        color: this.model.getFillColor(u[o]),
        class: this.model.getColorClassName({
          classNameTypes: [tt.TOOLTIP],
          dataGroupName: u[o]
        })
      });
    } else if (e.length > 1 && (d = [
      {
        label: c,
        value: h
      }
    ], d = d.concat(
      e.map((u) => {
        const p = u[i.getRangeIdentifier(u)];
        return {
          label: u[o],
          value: Array.isArray(p) && p.length === 2 ? `${p[0]} - ${p[1]}` : p,
          color: this.model.getFillColor(u[o]),
          class: this.model.getColorClassName({
            classNameTypes: [tt.TOOLTIP],
            dataGroupName: u[o]
          })
        };
      }).sort((u, p) => p.value - u.value)
    ), !a && T(n, "tooltip", "showTotal") === !0)) {
      const u = i.getRangeIdentifier();
      d.push({
        label: yt(n, "locale.translations.total") || yt(n, "tooltip.totalLabel") || "Total",
        value: e.reduce(
          (p, f) => p + f[u],
          0
        ),
        bold: !0
      });
    }
    return d;
  }
}
function to(s, t) {
  let e;
  if (t === void 0)
    for (const n of s)
      n != null && (e < n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let i of s)
      (i = t(i, ++n, s)) != null && (e < i || e === void 0 && i >= i) && (e = i);
  }
  return e;
}
function kf(s, t) {
  let e;
  if (t === void 0)
    for (const n of s)
      n != null && (e > n || e === void 0 && n >= n) && (e = n);
  else {
    let n = -1;
    for (let i of s)
      (i = t(i, ++n, s)) != null && (e > i || e === void 0 && i >= i) && (e = i);
  }
  return e;
}
function gi(s, t) {
  let e = 0;
  if (t === void 0)
    for (let n of s)
      (n = +n) && (e += n);
  else {
    let n = -1;
    for (let i of s)
      (i = +t(i, ++n, s)) && (e += i);
  }
  return e;
}
function Rf(s) {
  return s.depth;
}
function If(s, t) {
  return t - 1 - s.height;
}
function Ll(s, t) {
  return s.sourceLinks.length ? s.depth : t - 1;
}
function ts(s) {
  return function() {
    return s;
  };
}
function eo(s, t) {
  return Ms(s.source, t.source) || s.index - t.index;
}
function no(s, t) {
  return Ms(s.target, t.target) || s.index - t.index;
}
function Ms(s, t) {
  return s.y0 - t.y0;
}
function mi(s) {
  return s.value;
}
function Df(s) {
  return s.index;
}
function Pf(s) {
  return s.nodes;
}
function Nf(s) {
  return s.links;
}
function so(s, t) {
  const e = s.get(t);
  if (!e) throw new Error("missing: " + t);
  return e;
}
function io({ nodes: s }) {
  for (const t of s) {
    let e = t.y0, n = e;
    for (const i of t.sourceLinks)
      i.y0 = e + i.width / 2, e += i.width;
    for (const i of t.targetLinks)
      i.y1 = n + i.width / 2, n += i.width;
  }
}
function $f() {
  let s = 0, t = 0, e = 1, n = 1, i = 24, r = 8, a, o = Df, c = Ll, l, h, d = Pf, u = Nf, p = 6;
  function f() {
    const w = { nodes: d.apply(null, arguments), links: u.apply(null, arguments) };
    return g(w), m(w), E(w), y(w), b(w), io(w), w;
  }
  f.update = function(w) {
    return io(w), w;
  }, f.nodeId = function(w) {
    return arguments.length ? (o = typeof w == "function" ? w : ts(w), f) : o;
  }, f.nodeAlign = function(w) {
    return arguments.length ? (c = typeof w == "function" ? w : ts(w), f) : c;
  }, f.nodeSort = function(w) {
    return arguments.length ? (l = w, f) : l;
  }, f.nodeWidth = function(w) {
    return arguments.length ? (i = +w, f) : i;
  }, f.nodePadding = function(w) {
    return arguments.length ? (r = a = +w, f) : r;
  }, f.nodes = function(w) {
    return arguments.length ? (d = typeof w == "function" ? w : ts(w), f) : d;
  }, f.links = function(w) {
    return arguments.length ? (u = typeof w == "function" ? w : ts(w), f) : u;
  }, f.linkSort = function(w) {
    return arguments.length ? (h = w, f) : h;
  }, f.size = function(w) {
    return arguments.length ? (s = t = 0, e = +w[0], n = +w[1], f) : [e - s, n - t];
  }, f.extent = function(w) {
    return arguments.length ? (s = +w[0][0], e = +w[1][0], t = +w[0][1], n = +w[1][1], f) : [[s, t], [e, n]];
  }, f.iterations = function(w) {
    return arguments.length ? (p = +w, f) : p;
  };
  function g({ nodes: w, links: V }) {
    for (const [P, $] of w.entries())
      $.index = P, $.sourceLinks = [], $.targetLinks = [];
    const N = new Map(w.map((P, $) => [o(P, $, w), P]));
    for (const [P, $] of V.entries()) {
      $.index = P;
      let { source: X, target: F } = $;
      typeof X != "object" && (X = $.source = so(N, X)), typeof F != "object" && (F = $.target = so(N, F)), X.sourceLinks.push($), F.targetLinks.push($);
    }
    if (h != null)
      for (const { sourceLinks: P, targetLinks: $ } of w)
        P.sort(h), $.sort(h);
  }
  function m({ nodes: w }) {
    for (const V of w)
      V.value = V.fixedValue === void 0 ? Math.max(gi(V.sourceLinks, mi), gi(V.targetLinks, mi)) : V.fixedValue;
  }
  function E({ nodes: w }) {
    const V = w.length;
    let N = new Set(w), P = /* @__PURE__ */ new Set(), $ = 0;
    for (; N.size; ) {
      for (const X of N) {
        X.depth = $;
        for (const { target: F } of X.sourceLinks)
          P.add(F);
      }
      if (++$ > V) throw new Error("circular link");
      N = P, P = /* @__PURE__ */ new Set();
    }
  }
  function y({ nodes: w }) {
    const V = w.length;
    let N = new Set(w), P = /* @__PURE__ */ new Set(), $ = 0;
    for (; N.size; ) {
      for (const X of N) {
        X.height = $;
        for (const { source: F } of X.targetLinks)
          P.add(F);
      }
      if (++$ > V) throw new Error("circular link");
      N = P, P = /* @__PURE__ */ new Set();
    }
  }
  function v({ nodes: w }) {
    const V = to(w, ($) => $.depth) + 1, N = (e - s - i) / (V - 1), P = new Array(V);
    for (const $ of w) {
      const X = Math.max(0, Math.min(V - 1, Math.floor(c.call(null, $, V))));
      $.layer = X, $.x0 = s + X * N, $.x1 = $.x0 + i, P[X] ? P[X].push($) : P[X] = [$];
    }
    if (l) for (const $ of P)
      $.sort(l);
    return P;
  }
  function S(w) {
    const V = kf(w, (N) => (n - t - (N.length - 1) * a) / gi(N, mi));
    for (const N of w) {
      let P = t;
      for (const $ of N) {
        $.y0 = P, $.y1 = P + $.value * V, P = $.y1 + a;
        for (const X of $.sourceLinks)
          X.width = X.value * V;
      }
      P = (n - P + a) / (N.length + 1);
      for (let $ = 0; $ < N.length; ++$) {
        const X = N[$];
        X.y0 += P * ($ + 1), X.y1 += P * ($ + 1);
      }
      B(N);
    }
  }
  function b(w) {
    const V = v(w);
    a = Math.min(r, (n - t) / (to(V, (N) => N.length) - 1)), S(V);
    for (let N = 0; N < p; ++N) {
      const P = Math.pow(0.99, N), $ = Math.max(1 - P, (N + 1) / p);
      I(V, P, $), O(V, P, $);
    }
  }
  function O(w, V, N) {
    for (let P = 1, $ = w.length; P < $; ++P) {
      const X = w[P];
      for (const F of X) {
        let et = 0, J = 0;
        for (const { source: Q, value: j } of F.targetLinks) {
          let Z = j * (F.layer - Q.layer);
          et += D(Q, F) * Z, J += Z;
        }
        if (!(J > 0)) continue;
        let ct = (et / J - F.y0) * V;
        F.y0 += ct, F.y1 += ct, L(F);
      }
      l === void 0 && X.sort(Ms), k(X, N);
    }
  }
  function I(w, V, N) {
    for (let P = w.length, $ = P - 2; $ >= 0; --$) {
      const X = w[$];
      for (const F of X) {
        let et = 0, J = 0;
        for (const { target: Q, value: j } of F.sourceLinks) {
          let Z = j * (Q.layer - F.layer);
          et += A(F, Q) * Z, J += Z;
        }
        if (!(J > 0)) continue;
        let ct = (et / J - F.y0) * V;
        F.y0 += ct, F.y1 += ct, L(F);
      }
      l === void 0 && X.sort(Ms), k(X, N);
    }
  }
  function k(w, V) {
    const N = w.length >> 1, P = w[N];
    C(w, P.y0 - a, N - 1, V), G(w, P.y1 + a, N + 1, V), C(w, n, w.length - 1, V), G(w, t, 0, V);
  }
  function G(w, V, N, P) {
    for (; N < w.length; ++N) {
      const $ = w[N], X = (V - $.y0) * P;
      X > 1e-6 && ($.y0 += X, $.y1 += X), V = $.y1 + a;
    }
  }
  function C(w, V, N, P) {
    for (; N >= 0; --N) {
      const $ = w[N], X = ($.y1 - V) * P;
      X > 1e-6 && ($.y0 -= X, $.y1 -= X), V = $.y0 - a;
    }
  }
  function L({ sourceLinks: w, targetLinks: V }) {
    if (h === void 0) {
      for (const { source: { sourceLinks: N } } of V)
        N.sort(no);
      for (const { target: { targetLinks: N } } of w)
        N.sort(eo);
    }
  }
  function B(w) {
    if (h === void 0)
      for (const { sourceLinks: V, targetLinks: N } of w)
        V.sort(no), N.sort(eo);
  }
  function D(w, V) {
    let N = w.y0 - (w.sourceLinks.length - 1) * a / 2;
    for (const { target: P, width: $ } of w.sourceLinks) {
      if (P === V) break;
      N += $ + a;
    }
    for (const { source: P, width: $ } of V.targetLinks) {
      if (P === w) break;
      N -= $;
    }
    return N;
  }
  function A(w, V) {
    let N = V.y0 - (V.targetLinks.length - 1) * a / 2;
    for (const { source: P, width: $ } of V.targetLinks) {
      if (P === w) break;
      N += $ + a;
    }
    for (const { target: P, width: $ } of w.sourceLinks) {
      if (P === V) break;
      N -= $;
    }
    return N;
  }
  return f;
}
var rr = Math.PI, ar = 2 * rr, _e = 1e-6, Vf = ar - _e;
function or() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Al() {
  return new or();
}
or.prototype = Al.prototype = {
  constructor: or,
  moveTo: function(s, t) {
    this._ += "M" + (this._x0 = this._x1 = +s) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(s, t) {
    this._ += "L" + (this._x1 = +s) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(s, t, e, n) {
    this._ += "Q" + +s + "," + +t + "," + (this._x1 = +e) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(s, t, e, n, i, r) {
    this._ += "C" + +s + "," + +t + "," + +e + "," + +n + "," + (this._x1 = +i) + "," + (this._y1 = +r);
  },
  arcTo: function(s, t, e, n, i) {
    s = +s, t = +t, e = +e, n = +n, i = +i;
    var r = this._x1, a = this._y1, o = e - s, c = n - t, l = r - s, h = a - t, d = l * l + h * h;
    if (i < 0) throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = s) + "," + (this._y1 = t);
    else if (d > _e) if (!(Math.abs(h * o - c * l) > _e) || !i)
      this._ += "L" + (this._x1 = s) + "," + (this._y1 = t);
    else {
      var u = e - r, p = n - a, f = o * o + c * c, g = u * u + p * p, m = Math.sqrt(f), E = Math.sqrt(d), y = i * Math.tan((rr - Math.acos((f + d - g) / (2 * m * E))) / 2), v = y / E, S = y / m;
      Math.abs(v - 1) > _e && (this._ += "L" + (s + v * l) + "," + (t + v * h)), this._ += "A" + i + "," + i + ",0,0," + +(h * u > l * p) + "," + (this._x1 = s + S * o) + "," + (this._y1 = t + S * c);
    }
  },
  arc: function(s, t, e, n, i, r) {
    s = +s, t = +t, e = +e, r = !!r;
    var a = e * Math.cos(n), o = e * Math.sin(n), c = s + a, l = t + o, h = 1 ^ r, d = r ? n - i : i - n;
    if (e < 0) throw new Error("negative radius: " + e);
    this._x1 === null ? this._ += "M" + c + "," + l : (Math.abs(this._x1 - c) > _e || Math.abs(this._y1 - l) > _e) && (this._ += "L" + c + "," + l), e && (d < 0 && (d = d % ar + ar), d > Vf ? this._ += "A" + e + "," + e + ",0,1," + h + "," + (s - a) + "," + (t - o) + "A" + e + "," + e + ",0,1," + h + "," + (this._x1 = c) + "," + (this._y1 = l) : d > _e && (this._ += "A" + e + "," + e + ",0," + +(d >= rr) + "," + h + "," + (this._x1 = s + e * Math.cos(i)) + "," + (this._y1 = t + e * Math.sin(i))));
  },
  rect: function(s, t, e, n) {
    this._ += "M" + (this._x0 = this._x1 = +s) + "," + (this._y0 = this._y1 = +t) + "h" + +e + "v" + +n + "h" + -e + "Z";
  },
  toString: function() {
    return this._;
  }
};
function ro(s) {
  return function() {
    return s;
  };
}
function Bf(s) {
  return s[0];
}
function Gf(s) {
  return s[1];
}
var Hf = Array.prototype.slice;
function Uf(s) {
  return s.source;
}
function zf(s) {
  return s.target;
}
function Ff(s) {
  var t = Uf, e = zf, n = Bf, i = Gf, r = null;
  function a() {
    var o, c = Hf.call(arguments), l = t.apply(this, c), h = e.apply(this, c);
    if (r || (r = o = Al()), s(r, +n.apply(this, (c[0] = l, c)), +i.apply(this, c), +n.apply(this, (c[0] = h, c)), +i.apply(this, c)), o) return r = null, o + "" || null;
  }
  return a.source = function(o) {
    return arguments.length ? (t = o, a) : t;
  }, a.target = function(o) {
    return arguments.length ? (e = o, a) : e;
  }, a.x = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : ro(+o), a) : n;
  }, a.y = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : ro(+o), a) : i;
  }, a.context = function(o) {
    return arguments.length ? (r = o ?? null, a) : r;
  }, a;
}
function Wf(s, t, e, n, i) {
  s.moveTo(t, e), s.bezierCurveTo(t = (t + n) / 2, e, t, i, n, i);
}
function Xf() {
  return Ff(Wf);
}
function jf(s) {
  return [s.source.x1, s.y0];
}
function Yf(s) {
  return [s.target.x0, s.y1];
}
function qf() {
  return Xf().source(jf).target(Yf);
}
class y0 extends ot {
  constructor() {
    super(...arguments), this.type = "alluvial", this.renderType = st.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 });
    e.html("");
    const { width: n, height: i } = _.getSVGElementSize(e, {
      useAttrs: !0
    });
    if (n < 1 || i < 1)
      return;
    const r = this.model.getOptions(), a = this.model.getDisplayData(), o = T(
      this.getOptions(),
      "color",
      "gradient",
      "enabled"
    );
    let c = ee.minNodePadding;
    r.alluvial.nodePadding > ee.minNodePadding && (c = r.alluvial.nodePadding);
    const l = T(r, "alluvial", "nodeAlignment");
    let h = Ll;
    l === Jt.LEFT ? h = Rf : l === Jt.RIGHT && (h = If);
    const d = $f().nodeId((v) => v.name).nodeWidth(ee.nodeWidth).nodePadding(c).nodeAlign(h).extent([
      [2, 30],
      [n - 2, i]
    ]);
    this.graph = d({
      nodes: r.alluvial.nodes.map((v) => Object.assign({}, v)),
      links: a.map((v) => Object.assign({}, v))
    }), this.graph.nodes = this.graph.nodes.filter((v) => v.value !== 0);
    const u = {};
    this.graph.nodes.forEach((v) => {
      const S = v.x0;
      v.category && (u[S] = v == null ? void 0 : v.category);
    }), e.append("g").classed("header-arrows", !0).selectAll("g").data(Object.keys(u)).join("g").attr("transform", (v) => `translate(${v}, 0)`).append("text").attr(
      "id",
      (v, S) => this.services.domUtils.generateElementIDString(`alluvial-category-${S}`)
    ).style("font-size", "14px").text((v) => u[v] ? u[v] : "").attr("y", 20).attr("x", (v, S) => {
      const b = this.services.domUtils.generateElementIDString(
        `alluvial-category-${S}`
      ), { width: O } = _.getSVGElementSize(R(`text#${b}`), {
        useBBox: !0
      });
      let I = 0;
      return v + I >= O && (I = -O + 4), I;
    });
    const f = e.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
    if (f.exit().remove(), o) {
      const v = T(this.getOptions(), "color", "scale");
      v && f.enter().append("linearGradient").attr("id", (S) => `${this.gradient_id}-link-${S.index}`).attr("gradientUnits", "userSpaceOnUse").call(
        (S) => S.append("stop").attr("offset", "0%").attr("stop-color", (b) => v[b.source.name])
      ).call(
        (S) => S.append("stop").attr("offset", "100%").attr("stop-color", (b) => v[b.target.name])
      ), f.exit().remove();
    }
    f.enter().append("path").classed("link", !0).attr("d", qf()).attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-line-${v.index}`)
    ).attr("class", (v) => r.alluvial.monochrome ? this.model.getColorClassName({
      classNameTypes: [tt.STROKE],
      dataGroupName: 0,
      originalClassName: "link"
    }) : this.model.getColorClassName({
      classNameTypes: [tt.STROKE],
      dataGroupName: v.source.index,
      originalClassName: "link"
    })).style("stroke", (v) => o ? `url(#${this.gradient_id}-link-${v.index})` : this.model.getFillColor(v.source.name, null, {
      ...v,
      source: v.source.name,
      target: v.target.name
    })).attr("stroke-width", (v) => Math.max(1, v.width)).style("stroke-opacity", ee.opacity.default).attr(
      "aria-label",
      (v) => `${v.source.name} → ${v.target.name} (${v.value}${r.alluvial.units ? " " + r.alluvial.units : ""})`
    );
    const g = e.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-${v.index}`)
    ).classed("node-group", !0).attr("transform", (v) => `translate(${v.x0}, ${v.y0})`);
    g.append("rect").classed("node", !0).attr("height", (v) => v.y1 - v.y0).attr("width", (v) => v.x1 - v.x0).attr("fill", "black");
    const m = g.append("g").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-title-${v.index}`)
    ), { code: E, number: y } = T(r, "locale");
    m.append("text").attr(
      "id",
      (v) => this.services.domUtils.generateElementIDString(`alluvial-node-text-${v.index}`)
    ).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text((v) => `${v.name} (${y(v.value, E)})`).attr("aria-label", (v) => `${v.name} (${v.value})`), m.append("rect").classed("node-text-bg", !0).attr("width", (v, S) => {
      const b = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${S}`
      ), { width: O } = _.getSVGElementSize(R(`text#${b}`), {
        useBBox: !0
      });
      return O + 8;
    }).attr("height", 18).attr("stroke-width", 2).lower(), m.attr("transform", (v, S) => {
      const b = this.services.domUtils.generateElementIDString(
        `alluvial-node-text-${S}`
      ), { width: O } = _.getSVGElementSize(R(`text#${b}`), {
        useBBox: !0
      }), I = (v.y1 - v.y0) / 2 - 9;
      let k = v.x1 - v.x0;
      return v.x1 >= O ? k = k - (O + 16) : k += 4, `translate(${k}, ${I})`;
    }), this.addLineEventListener(), this.addNodeEventListener();
  }
  addLineEventListener() {
    const t = this.getOptions(), e = this, { number: n, code: i } = T(this.getOptions(), "locale"), r = xi((a, o = "mouseover") => {
      const c = e.parent.selectAll("path.link").transition().call(
        (l) => e.services.transitions.setupTransition({
          transition: l,
          name: "alluvial-links-mouse-highlight"
        })
      );
      o === "mouseout" ? (R(a).lower(), c.style("stroke-opacity", ee.opacity.default)) : c.style("stroke-opacity", function() {
        return a === this ? (R(this).raise(), ee.opacity.selected) : ee.opacity.unfocus;
      });
    }, 33);
    this.parent.selectAll("path.link").on("mouseover", function(a, o) {
      const c = R(this);
      r(this, "mouseover"), c.classed("link-hovered", !0);
      const l = getComputedStyle(this).getPropertyValue("stroke");
      e.services.events.dispatchEvent(x.Alluvial.LINE_MOUSEOVER, {
        event: a,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: a,
        hoveredElement: c,
        items: [
          {
            label: o.target.name,
            value: (n(o.value, i) ? `${n(o.value, i)}` : "-") + (t.alluvial.units ? ` ${t.alluvial.units}` : ""),
            color: l,
            labelIcon: e.getRightArrowIcon()
          }
        ]
      });
    }).on("mousemove", function(a, o) {
      e.services.events.dispatchEvent(x.Alluvial.LINE_MOUSEMOVE, {
        event: a,
        element: R(this),
        datum: o
      }), e.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: a
      });
    }).on("click", function(a, o) {
      e.services.events.dispatchEvent(x.Alluvial.LINE_CLICK, {
        event: a,
        element: R(this),
        datum: o
      });
    }).on("mouseout", function(a, o) {
      const c = R(this);
      r(this, "mouseout"), c.classed("link-hovered", !1), e.services.events.dispatchEvent(x.Alluvial.LINE_MOUSEOUT, {
        event: a,
        element: c,
        datum: o
      }), e.services.events.dispatchEvent(x.Tooltip.HIDE, {
        event: a,
        hoveredElement: c
      });
    });
  }
  addNodeEventListener() {
    const t = this, e = xi((n = [], i = "mouseover") => {
      if (i === "mouseout" || n.length === 0) {
        t.parent.selectAll("path.link").classed("link-hovered", !1).data(this.graph.links, (a) => a.index).order().style("stroke-opacity", ee.opacity.default);
        return;
      }
      t.parent.selectAll("path.link").transition().call(
        (a) => this.services.transitions.setupTransition({
          transition: a,
          name: "alluvial-link-mouse-highlight"
        })
      ).style("stroke-opacity", function(a) {
        return n.some((o) => o === a.index) ? (R(this).classed("link-hovered", !0).raise(), ee.opacity.selected) : ee.opacity.unfocus;
      });
    }, 66);
    t.parent.selectAll(".node-group").on("mouseover", function(n, i) {
      const r = R(this), a = [];
      if (t.traverse({ link: "sourceLinks", node: "target" }, i, a), t.traverse({ link: "targetLinks", node: "source" }, i, a), a.length) {
        const o = mn(r.attr("transform"));
        if (r.attr("transform", `translate(${o.x - 2}, ${o.y})`), r.classed("node-hovered", !0).selectAll("rect.node").attr("width", 8), i.x0 - 2 === 0) {
          const l = t.services.domUtils.generateElementIDString(
            `alluvial-node-title-${i.index}`
          ), h = t.parent.select(`g#${l}`), d = mn(h.attr("transform"));
          h.attr("transform", `translate(${d.x + 4},${d.y})`);
        }
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-text-${i.index}`
        );
        t.parent.select(`text#${c}`).style("font-weight", "bold"), e(a, "mouseover"), t.services.events.dispatchEvent(x.Alluvial.NODE_MOUSEOVER, {
          event: n,
          element: r,
          datum: i
        });
      }
    }).on("mousemove", function(n, i) {
      t.services.events.dispatchEvent(x.Alluvial.NODE_MOUSEMOVE, {
        event: n,
        element: R(this),
        datum: i
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, i) {
      t.services.events.dispatchEvent(x.Alluvial.NODE_CLICK, {
        event: n,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(n, i) {
      const r = R(this), a = mn(r.attr("transform"));
      if (r.classed("node-hovered", !1).attr("transform", `translate(${a.x + 2}, ${a.y})`).select("rect.node").attr("width", ee.nodeWidth), i.x0 - 2 === 0) {
        const c = t.services.domUtils.generateElementIDString(
          `alluvial-node-title-${i.index}`
        ), l = t.parent.select(`g#${c}`), h = mn(l.attr("transform"));
        l.attr("transform", `translate(${h.x - 4},${h.y})`);
      }
      const o = t.services.domUtils.generateElementIDString(
        `alluvial-node-text-${i.index}`
      );
      t.parent.select(`text#${o}`).style("font-weight", "normal"), e([], "mouseout"), t.services.events.dispatchEvent(x.Alluvial.NODE_MOUSEOUT, {
        event: n,
        element: r,
        datum: i
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  // Traverse graph and get all connected links to node
  traverse(t, e, n = []) {
    e[t.link].map((r) => (n.push(r.index), r[t.node])).forEach((r) => this.traverse(t, r, n));
  }
  getRightArrowIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" class="arrow-right" width="32" height="32" viewBox="0 0 32 32">
			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>
			<rect width="32" height="32"/>
		</svg>`;
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
  }
}
class E0 extends ot {
  constructor() {
    super(...arguments), this.type = "grid", this.renderType = st.SVG;
  }
  render(t = !0) {
    const e = T(this.getOptions(), "grid", "x", "enabled"), n = T(this.getOptions(), "grid", "y", "enabled");
    this.drawBackdrop(e, n), !(!e && !n) && (e && (_.appendOrSelect(this.backdrop, "g.x.grid"), this.drawXGrid(t)), n && (_.appendOrSelect(this.backdrop, "g.y.grid"), this.drawYGrid(t)));
  }
  drawXGrid(t) {
    const e = this.parent, n = this.backdrop.attr("height"), i = this.services.cartesianScales.getMainXScale(), r = hr(i).tickSizeInner(-n).tickSizeOuter(0);
    if (T(this.getOptions(), "grid", "x", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getDomainAxisPosition(), l = T(this.getOptions(), "axes", c, "ticks", "values");
      l && r.tickValues(l);
    } else {
      const c = T(this.getOptions(), "grid", "x", "numberOfTicks");
      r.ticks(c);
    }
    const o = e.select(".x.grid").attr("transform", `translate(${-this.backdrop.attr("x")}, ${n})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(r) : o.call(r), this.cleanGrid(o);
  }
  drawYGrid(t) {
    const e = this.parent, n = this.backdrop.attr("width"), i = this.services.cartesianScales.getMainYScale(), r = Go(i).tickSizeInner(-n).tickSizeOuter(0);
    if (T(this.getOptions(), "grid", "y", "alignWithAxisTicks")) {
      const c = this.services.cartesianScales.getRangeAxisPosition(), l = T(this.getOptions(), "axes", c, "ticks", "values");
      l && r.tickValues(l);
    } else {
      const c = T(this.getOptions(), "grid", "y", "numberOfTicks");
      r.ticks(c);
    }
    const o = e.select(".y.grid").attr("transform", `translate(0, ${-this.backdrop.attr("y")})`);
    t ? o.transition().call(
      (c) => this.services.transitions.setupTransition({
        transition: c,
        name: "grid-update",
        animate: t
      })
    ).call(r) : o.call(r), this.cleanGrid(o);
  }
  /**
   * Returns the threshold for the gridline tooltips based on the mouse location.
   * Calculated based on the mouse position between the two closest gridlines or edges of chart.
   */
  getGridlineThreshold(t) {
    const e = this.parent, n = e.selectAll(".x.grid .tick").nodes().sort((h, d) => Number(fe(h).tx) - Number(fe(d).tx));
    let i = -1;
    if (!n.length)
      return;
    n.forEach((h) => {
      t[0] >= +fe(h).tx && i++;
    });
    const r = i + 1 < n.length ? i + 1 : n.length, a = n[i], o = n[r];
    let c;
    if (!a)
      c = +fe(o).tx;
    else if (o)
      c = +fe(o).tx - +fe(a).tx;
    else {
      const h = e.select("rect.chart-grid-backdrop").node();
      c = _.getSVGElementSize(h).width - +fe(a).tx;
    }
    const { threshold: l } = this.getOptions().tooltip.gridline;
    return c * l;
  }
  /**
   * Returns the active gridlines based on the gridline threshold and mouse position.
   * @param position mouse positon
   */
  getActiveGridline(t) {
    const e = T(this.getOptions, "tooltip", "gridline", "threshold"), n = e || this.getGridlineThreshold(t);
    return this.parent.selectAll(".x.grid .tick").filter(function() {
      const a = fe(this), o = {
        min: Number(a.tx) - n,
        max: Number(a.tx) + n
      };
      return o.min <= t[0] && t[0] <= o.max;
    });
  }
  drawBackdrop(t, e) {
    const n = this.parent, i = this.services.cartesianScales.getMainXScale(), r = this.services.cartesianScales.getMainYScale(), [a, o] = i.range(), [c, l] = r.range();
    this.backdrop = _.appendOrSelect(n, "svg.chart-grid-backdrop");
    const h = _.appendOrSelect(
      this.backdrop,
      t || e ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop"
    );
    this.backdrop.merge(h).attr("x", a).attr("y", l).attr("width", Math.abs(o - a)).attr("height", Math.abs(c - l)).lower(), h.attr("width", "100%").attr("height", "100%");
  }
  cleanGrid(t) {
    t.selectAll("text").remove(), t.select(".domain").remove();
  }
}
class S0 extends ot {
  constructor() {
    super(...arguments), this.type = "area", this.renderType = st.SVG, this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999), this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-area"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? me.opacity.unselected : me.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", me.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions();
    let i = [0, 0];
    const { cartesianScales: r } = this.services, a = r.getOrientation(), o = yr().curve(this.services.curves.getD3Curve()).defined((b) => {
      const O = r.getRangeIdentifier(), I = b[O];
      return I != null;
    }), c = this.model.getGroupedData(this.configs.groups), l = T(n, "bounds"), h = l && c && c.length === 1;
    !h && l && console.warn(
      `Bounds can only be shown when having 1 single datagroup, you've supplied ${c.length}`
    );
    let d = 0;
    const u = (b, O) => {
      T(n, "axes", b, "includeZero") === !1 && O[0] > 0 && O[1] > 0 && (d = O[0]);
    }, p = (b) => h ? r.getBoundedScaledValues(b)[0] : r.getRangeValue(d), f = (b) => h ? r.getBoundedScaledValues(b)[1] : r.getRangeValue(b);
    a === Ft.VERTICAL ? (i = r.getMainYScale().domain(), u(r.getMainYAxisPosition(), i), o.x((b) => r.getDomainValue(b)).y0((b) => p(b)).y1((b) => f(b))) : (i = r.getMainXScale().domain(), u(r.getMainXAxisPosition(), i), o.x0((b) => p(b)).x1((b) => f(b)).y((b) => r.getDomainValue(b)));
    const g = T(n, "color", "gradient", "enabled"), m = c && c.length === 1 && g;
    c.length > 1 && g && console.error("Gradients can only be enabled when having 1 single dataset");
    const E = e.selectAll("path.area").data(c, (b) => b.name), y = R(this.services.domUtils.getMainContainer());
    if (E.exit().attr("opacity", 0).remove(), !c.length)
      return;
    if (m) {
      const b = y.select(
        `path.${this.model.getColorClassName({
          classNameTypes: [tt.STROKE],
          dataGroupName: c[0].name
        })}`
      ).node();
      let O;
      if (b)
        O = getComputedStyle(b, null).getPropertyValue(
          "stroke"
        );
      else {
        const I = T(this.model.getOptions(), "color", "scale");
        if (I !== null) {
          const k = Object.keys(I);
          O = I[k[0]];
        }
      }
      ta.appendOrUpdateLinearGradient({
        svg: this.parent,
        id: this.services.domUtils.generateElementIDString(
          `${c[0].name.replace(" ", "")}_${this.gradient_id}`
        ),
        x1: "0%",
        x2: "0%",
        y1: "0%",
        y2: "100%",
        stops: ta.getStops(i, O)
      });
    } else
      this.parent.selectAll("defs linearGradient").empty() || this.parent.selectAll("defs linearGradient").each(function() {
        this.parentNode.remove();
      });
    const v = this, S = E.enter().append("path");
    m ? S.merge(E).style(
      "fill",
      (b) => `url(#${this.services.domUtils.generateElementIDString(
        `${b.name.replace(" ", "")}_${this.gradient_id}`
      )})`
    ).attr("class", "area").attr(
      "class",
      (b) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: b.name,
        originalClassName: "area"
      })
    ).attr("d", (b) => {
      const { data: O } = b;
      return o(O);
    }) : (S.attr("opacity", 0).merge(E).attr("class", "area").attr(
      "class",
      (b) => this.model.getColorClassName({
        classNameTypes: [tt.FILL, tt.STROKE],
        dataGroupName: b.name,
        originalClassName: "area"
      })
    ).style("fill", (b) => v.model.getFillColor(b.name, null, b.data)).transition().call(
      (b) => this.services.transitions.setupTransition({
        transition: b,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", h ? 1 : me.opacity.selected).attr("d", (b) => {
      const { data: O } = b;
      return o(O);
    }), h && S.attr("fill-opacity", me.opacity.selected).style("stroke", (b) => v.model.getStrokeColor(b.name, null, b.data)).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px"));
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class x0 extends ot {
  constructor() {
    super(...arguments), this.type = "line", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("path.line").transition("legend-hover-line").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-line"
        })
      ).attr("opacity", (n) => n.name !== e.datum().name ? ge.opacity.unselected : ge.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ge.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), { cartesianScales: n, curves: i } = this.services, r = (f) => n.getDomainValue(f), a = (f) => n.getRangeValue(f), [o, c] = ye(
      r,
      a,
      n.getOrientation()
    ), l = this.getOptions(), h = Nn().x(o).y(c).curve(i.getD3Curve()).defined((f) => {
      const g = n.getRangeIdentifier(f), m = f[g];
      return m != null;
    });
    let d = [];
    if (this.configs.stacked) {
      const f = Object.keys(l.axes).some((E) => l.axes[E].percentage), { groupMapsTo: g } = l.data;
      d = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: f
      }).map((E) => {
        const y = this.services.cartesianScales.getDomainIdentifier(E), v = this.services.cartesianScales.getRangeIdentifier(E);
        return {
          name: T(E, 0, g),
          data: E.map((S) => ({
            [y]: S.data.sharedStackKey,
            [g]: S[g],
            [v]: S[1]
          })),
          hidden: !lu(E, (S) => S[0] !== S[1])
        };
      });
    } else
      d = this.model.getGroupedData(this.configs.groups);
    const u = e.selectAll("path.line").data(d, (f) => f.name);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("line", !0).attr("opacity", 0).merge(u).data(d, (f) => f.name).attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        dataGroupName: f.name,
        originalClassName: "line"
      })
    ).style("stroke", (f) => this.model.getStrokeColor(f.name, null, f.data)).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", (f) => {
      const { data: g } = f;
      return g.map((m) => {
        const E = this.services.cartesianScales.getRangeIdentifier(m);
        return m[E];
      }).join(",");
    }).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "line-update-enter",
        animate: t
      })
    ).attr("opacity", (f) => f.hidden ? 0 : 1).attr("d", (f) => {
      const { data: g } = f;
      return h(g);
    });
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
const ao = 5;
function Zf(s, t) {
  return s > t - ao && s < t + ao;
}
class Ml extends ot {
  constructor() {
    super(...arguments), this.type = "ruler", this.renderType = st.SVG, this.isXGridEnabled = T(this.getOptions(), "grid", "x", "enabled"), this.isYGridEnabled = T(this.getOptions(), "grid", "y", "enabled"), this.isEventListenerAdded = !1;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = T(this.getOptions(), "ruler", "enabled");
    this.drawBackdrop(), e && !this.isEventListenerAdded ? this.addBackdropEventListeners() : !e && this.isEventListenerAdded && this.removeBackdropEventListeners();
  }
  removeBackdropEventListeners() {
    this.isEventListenerAdded = !1, this.backdrop.on("mousemove mouseover mouseout", null);
  }
  formatTooltipData(t) {
    return t;
  }
  showRuler(t, [e, n]) {
    const i = this.parent, r = this.services.cartesianScales.getOrientation(), a = this.model.getDisplayData(), o = this.services.cartesianScales.getRangeScale(), [c, l] = o.range(), h = r === Ft.HORIZONTAL ? n : e, d = _.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), u = _.appendOrSelect(d, "line.ruler-line"), p = i.selectAll("[role=graphics-symbol]"), f = a.map((m) => ({
      domainValue: this.services.cartesianScales.getDomainValue(m),
      originalData: m
    })).filter((m) => Zf(m.domainValue, h));
    if (this.pointsWithinLine && f.length === this.pointsWithinLine.length && f.map((m) => m.domainValue).join() === this.pointsWithinLine.map((m) => m.domainValue).join())
      return this.pointsWithinLine = f, this.services.events.dispatchEvent(x.Tooltip.MOVE, {
        mousePosition: [e, n]
      });
    this.pointsWithinLine = f;
    const g = this.pointsWithinLine.reduce((m, E) => {
      if (m.length === 0)
        return m.push(E), m;
      const y = m[0].domainValue, v = Math.abs(h - E.domainValue), S = Math.abs(h - y);
      return v > S || (v < S ? m = [E] : m.push(E)), m;
    }, []);
    if (g.length > 0) {
      const m = g.map((S) => S.originalData).filter((S) => {
        const b = this.services.cartesianScales.getRangeIdentifier(S), O = S[b];
        return O != null;
      }), E = g.map(
        (S) => S.domainValue
      ), y = p.filter((S) => {
        const b = this.services.cartesianScales.getDomainValue(S);
        return E.includes(b);
      });
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Vo(this.elementsToHighlight, y) && this.hideRuler(), y.dispatch("mouseover"), this.elementsToHighlight = y, this.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: t,
        mousePosition: [e, n],
        hoveredElement: u,
        data: this.formatTooltipData(m)
      }), d.attr("opacity", 1);
      const v = g[0];
      r === "horizontal" ? u.attr("x1", l).attr("x2", c).attr("y1", v.domainValue).attr("y2", v.domainValue) : u.attr("y1", l).attr("y2", c).attr("x1", v.domainValue).attr("x2", v.domainValue);
    } else
      this.hideRuler();
  }
  hideRuler() {
    const t = this.parent, e = _.appendOrSelect(t, "g.ruler");
    t.selectAll("[role=graphics-symbol]").dispatch("mouseout"), this.services.events.dispatchEvent(x.Tooltip.HIDE), e.attr("opacity", 0);
  }
  /**
   * Adds the listener on the X grid to trigger multiple point tooltips along the x axis.
   */
  addBackdropEventListeners() {
    this.isEventListenerAdded = !0;
    const t = this, e = this.services.domUtils.getHolder(), n = this.model.getDisplayData();
    let i = function(r) {
      const a = en(r, t.parent.node());
      t.showRuler(r, a);
    };
    if (n.length > 100) {
      const r = n.length % 50 * 12.5;
      i = Yl(
        function(a) {
          const { mousePosition: o } = this;
          t.showRuler(a, o);
        },
        r,
        e
      );
    }
    this.backdrop.on("mousemove mouseover", i).on("mouseout", this.hideRuler.bind(this));
  }
  drawBackdrop() {
    const t = this.parent;
    this.backdrop = _.appendOrSelect(t, "svg.chart-grid-backdrop");
  }
}
class Sr extends ot {
  constructor() {
    super(...arguments), this.type = "scatter", this.renderType = st.SVG, this.handleChartHolderOnHover = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "chart-holder-hover-scatter"
          });
        }
      ).attr("opacity", 1);
    }, this.handleChartHolderOnMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "chart-holder-mouseout-scatter"
          });
        }
      ).attr("opacity", 0);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(
        (i) => {
          var r;
          return (r = this.services.transitions) == null ? void 0 : r.setupTransition({
            transition: i,
            name: "legend-hover-scatter"
          });
        }
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      if (!this.parent) throw new Error("Parent not defined");
      this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(
        (t) => {
          var e;
          return (e = this.services.transitions) == null ? void 0 : e.setupTransition({
            transition: t,
            name: "legend-mouseout-scatter"
          });
        }
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    if (!t) throw new Error("Services events are undefined.");
    t.addEventListener(
      x.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
    const { fadeInOnChartHolderMouseover: e } = this.configs;
    e && (t.addEventListener(x.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.addEventListener(x.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut));
  }
  filterBasedOnZoomDomain(t) {
    const { cartesianScales: e } = this.services;
    if (!e) throw new Error("Services cartesianScales are undefined.");
    const n = e.getDomainIdentifier(t), i = this.model.get("zoomDomain");
    return i !== void 0 ? t.filter(
      (r) => r[n].getTime() >= i[0].getTime() && r[n].getTime() <= i[1].getTime()
    ) : t;
  }
  getScatterData() {
    const t = this.getOptions(), { stacked: e } = this.configs;
    let n;
    if (e) {
      const i = Object.keys(t.axes).some((r) => t.axes[r].percentage);
      n = this.model.getStackedData({
        groups: this.configs.groups,
        percentage: i
      });
    } else {
      const { cartesianScales: i } = this.services;
      if (!i) throw new Error("Services cartesianScales are undefined.");
      n = this.model.getDisplayData(this.configs.groups).filter((r) => {
        const a = i.getRangeIdentifier(r);
        return r[a] !== void 0 && r[a] !== null;
      });
    }
    return this.filterBasedOnZoomDomain(n);
  }
  render(t) {
    if (!(T(this.getOptions(), "points", "enabled") || T(this.getOptions(), "bubble", "enabled")))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), i = this.getOptions(), { groupMapsTo: r } = i.data, { cartesianScales: a } = this.services;
    if (!a) throw new Error("Services cartesianScales are undefined.");
    const o = a.getDomainIdentifier(), c = n.selectAll("circle.dot").data(
      this.getScatterData(),
      (d) => `${d[r]}-${d[o]}`
    );
    c.exit().attr("opacity", 0).remove();
    const h = c.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(c);
    this.styleCircles(h, t), this.addEventListeners();
  }
  // A value is an anomaly if is above all defined domain and range thresholds
  isDatapointThresholdAnomaly(t) {
    const { handleThresholds: e } = this.configs;
    if (!e)
      return !1;
    const { cartesianScales: n } = this.services;
    if (!n) throw new Error("Cartesian scales service is undefined");
    const i = n.getOrientation(), [r, a] = ye(
      n.getHighestDomainThreshold(),
      n.getHighestRangeThreshold(),
      i
    ), [o, c] = ye(
      (d) => n.getDomainValue(d),
      (d) => n.getRangeValue(d),
      i
    ), l = o(t), h = c(t);
    return a && r ? h <= a.scaleValue && l >= r.scaleValue : a ? h <= a.scaleValue : r ? l >= r.scaleValue : !1;
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { filled: i, fillOpacity: r } = n.points, { cartesianScales: a } = this.services;
    if (!a) throw new Error("Cartesian scales service is undefined");
    const { groupMapsTo: o } = n.data, c = (p) => a.getDomainValue(p), l = (p) => a.getRangeValue(p), [h, d] = ye(
      c,
      l,
      a.getOrientation()
    ), { fadeInOnChartHolderMouseover: u } = this.configs;
    t.raise().classed("dot", !0).attr("class", (p) => {
      const f = a.getDomainIdentifier(p), m = this.model.getIsFilled(p[o], p[f], p, i) ? [tt.FILL, tt.STROKE] : [tt.STROKE];
      return this.model.getColorClassName({
        classNameTypes: m,
        dataGroupName: p[o],
        originalClassName: "dot"
      }) || "";
    }).classed("threshold-anomaly", (p) => this.isDatapointThresholdAnomaly(p)).classed("filled", (p) => {
      const f = a.getDomainIdentifier(p);
      return this.model.getIsFilled(p[o], p[f], p, i);
    }).classed("unfilled", (p) => {
      const f = a.getDomainIdentifier(p);
      return !this.model.getIsFilled(p[o], p[f], p, i);
    }).transition().call(
      (p) => {
        var f;
        return (f = this.services.transitions) == null ? void 0 : f.setupTransition({
          transition: p,
          name: "scatter-update-enter",
          animate: e
        });
      }
    ).attr("cx", h).attr("cy", d).attr("r", n.points.radius).style("fill", (p) => {
      const f = a.getDomainIdentifier(p);
      if (this.model.getIsFilled(p[o], p[f], p, i))
        return this.model.getFillColor(p[o], p[f], p);
    }).style("stroke", (p) => {
      const f = a.getDomainIdentifier(p);
      return this.model.getStrokeColor(p[o], p[f], p);
    }).attr("fill-opacity", i ? r : 1).attr("opacity", u ? 0 : 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", (p) => {
      const f = a.getRangeIdentifier(p);
      return p[f];
    }), this.addEventListeners();
  }
  // Extended in bubble graphs
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getTooltipAdditionalItems(t) {
    return null;
  }
  addEventListeners() {
    const t = this, { groupMapsTo: e } = t.getOptions().data;
    if (!this.parent) throw new Error("Parent not defined");
    this.parent.selectAll("circle").on("mouseover", function(n, i) {
      var a, o;
      const r = R(this);
      r.classed("hovered", !0).attr(
        "class",
        (c) => t.model.getColorClassName({
          classNameTypes: [tt.FILL],
          dataGroupName: c[e],
          originalClassName: r.attr("class")
        })
      ).style("fill", (c) => {
        var h;
        const l = (h = t.services.cartesianScales) == null ? void 0 : h.getDomainIdentifier(c);
        return t.model.getFillColor(c[e], c[l], c);
      }).classed("unfilled", !1), (a = t.services.events) == null || a.dispatchEvent(x.Tooltip.SHOW, {
        event: n,
        hoveredElement: r,
        data: [i],
        additionalItems: t.getTooltipAdditionalItems(i)
      }), (o = t.services.events) == null || o.dispatchEvent(x.Scatter.SCATTER_MOUSEOVER, {
        event: n,
        element: r,
        datum: i
      });
    }).on("mousemove", function(n, i) {
      var a, o;
      const r = R(this);
      (a = t.services.events) == null || a.dispatchEvent(x.Scatter.SCATTER_MOUSEMOVE, {
        event: n,
        element: r,
        datum: i
      }), (o = t.services.events) == null || o.dispatchEvent(x.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, i) {
      var r;
      (r = t.services.events) == null || r.dispatchEvent(x.Scatter.SCATTER_CLICK, {
        event: n,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(n, i) {
      var a, o, c;
      const r = R(this);
      if (r.classed("hovered", !1), !t.configs.filled) {
        const { filled: l } = t.getOptions().points, h = (a = t.services.cartesianScales) == null ? void 0 : a.getDomainIdentifier(i), d = t.model.getIsFilled(
          i[e],
          i[h],
          i,
          l
        );
        r.classed("unfilled", !d).style("fill", (u) => d || l ? t.model.getFillColor(u[e], u[h], u) : null);
      }
      (o = t.services.events) == null || o.dispatchEvent(x.Scatter.SCATTER_MOUSEOUT, {
        event: n,
        element: r,
        datum: i
      }), (c = t.services.events) == null || c.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: r
      });
    });
  }
  destroy() {
    var e;
    (e = this.parent) == null || e.selectAll("circle").on("mousemove", null).on("mouseout", null);
    const { events: t } = this.services;
    if (!t) throw new Error("Services events undefined");
    t.removeEventListener(
      x.Legend.ITEM_HOVER,
      this.handleLegendOnHover
    ), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(x.Chart.MOUSEOVER, this.handleChartHolderOnHover), t.removeEventListener(x.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
  }
}
class _l extends ot {
  constructor(t, e, n) {
    super(t, e, n), this.type = "axes", this.renderType = st.SVG, this.truncation = {
      [Y.LEFT]: !1,
      [Y.RIGHT]: !1,
      [Y.TOP]: !1,
      [Y.BOTTOM]: !1
    }, n && (this.configs = n), this.margins = this.configs.margins;
  }
  render(t = !0) {
    const { position: e } = this.configs, n = this.getOptions(), i = T(n, "axes", e, "visible"), r = this.getComponentContainer(), { width: a, height: o } = _.getSVGElementSize(r, {
      useAttrs: !0
    }), c = _.appendOrSelect(r, `g.axis.${e}`);
    let l, h;
    if (e === Y.BOTTOM || e === Y.TOP ? (l = this.configs.axes[Y.LEFT] ? this.margins.left : 0, h = this.configs.axes[Y.RIGHT] ? a - this.margins.right : a) : (l = o - this.margins.bottom, h = this.margins.top), !this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const d = this.services.cartesianScales.getScaleByPosition(e);
    this.scaleType === Mt.LABELS || this.scaleType === Mt.LABELS_RATIO ? d.rangeRound([l, h]) : d.range([l, h]);
    let u;
    switch (e) {
      case Y.LEFT:
        u = Go;
        break;
      case Y.BOTTOM:
        u = hr;
        break;
      case Y.RIGHT:
        u = vu;
        break;
      case Y.TOP:
        u = mu;
        break;
    }
    c.attr("aria-label", `${e} axis`);
    const p = !c.select("g.ticks").empty();
    let f = _.appendOrSelect(c, "g.ticks");
    p || (f.attr("role", `${it.GRAPHICS_OBJECT} ${it.GROUP}`), f.attr("aria-label", `${e} ticks`));
    const g = _.appendOrSelect(c, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", !0).attr("aria-label", `invisible ${e} ticks`), m = T(n, "axes", e), E = this.scaleType === Mt.TIME || m.scaleType === Mt.TIME, y = e === Y.LEFT || e === Y.RIGHT, v = this.model.get("zoomDomain");
    if (v && E && !y && d.domain(v), !i) {
      f.attr("aria-hidden", !0);
      return;
    }
    const S = T(m, "scaleType"), b = T(n, "data", "loading"), O = T(m, "ticks", "number"), I = T(m, "ticks", "values"), k = T(m, "truncation", "type"), G = T(m, "truncation", "threshold"), C = T(m, "truncation", "numCharacter"), L = O !== null, B = T(n, "timeScale"), D = _.appendOrSelect(g, "g.tick"), A = _.appendOrSelect(D, "text").text("0"), w = _.getSVGElementSize(A.node(), {
      useBBox: !0
    }).height;
    D.remove();
    const V = this.scaleType || m.scaleType || Mt.LINEAR, N = u(d).tickSizeOuter(0);
    if (d.ticks) {
      let j;
      if (L ? j = O : (j = qe.ticks.number, y && (j = this.getNumberOfFittingTicks(
        o,
        w,
        qe.ticks.verticalSpaceRatio
      ))), d.ticks().length === 1 && d.ticks()[0] === 0 && (j = 0), N.ticks(j), E)
        if (!d.ticks(j).length)
          N.tickValues([]);
        else {
          const Z = T(n, "timeScale", "addSpaceOnEdges"), ut = T(n, "axes", e, "domain"), ht = d.copy();
          Z && !ut && ht.nice(j);
          const Et = ht.ticks(j);
          Z && Et.length > 2 && !ut && (Et.splice(Et.length - 1, 1), Et.splice(0, 1)), N.tickValues(Et);
        }
    }
    let P;
    const $ = T(m, "ticks", "formatter"), { code: X, number: F } = T(n, "locale");
    if (E) {
      const j = yi(
        N.tickValues(),
        T(n, "timeScale", "timeInterval")
      );
      $ === null ? P = (Z, ut) => Ei(Z, ut, N.tickValues(), j, B, n.locale) : P = (Z, ut) => {
        const ht = Ei(
          Z,
          ut,
          N.tickValues(),
          j,
          B,
          n.locale
        );
        return $(Z, ut, ht);
      };
    } else
      $ === null ? V === Mt.LINEAR && (P = (j) => F(j, X)) : P = $;
    N.tickFormat(P);
    const [et, J] = this.services.cartesianScales.getScaleByPosition(e).domain();
    let ct;
    if (I) {
      if (E)
        I.forEach((j, Z) => {
          j.getTime === void 0 && (I[Z] = new Date(j));
        }), ct = I.filter((j) => {
          const Z = j.getTime();
          return Z >= new Date(et).getTime() && Z <= new Date(J).getTime();
        });
      else if (S === Mt.LABELS) {
        const j = this.services.cartesianScales.getScaleByPosition(e).domain();
        ct = I.filter((Z) => j.includes(Z));
      } else
        ct = I.filter(
          (j) => j >= et && j <= J
        );
      N.tickValues(ct);
    }
    switch (e) {
      case Y.LEFT:
        f.attr("transform", `translate(${this.margins.left}, 0)`);
        break;
      case Y.BOTTOM:
        f.attr("transform", `translate(0, ${o - this.margins.bottom})`);
        break;
      case Y.RIGHT:
        f.attr("transform", `translate(${a - this.margins.right}, 0)`);
        break;
      case Y.TOP:
        f.attr("transform", `translate(0, ${this.margins.top})`);
        break;
    }
    const Q = this.model.isDataEmpty();
    if (m.title) {
      const j = _.appendOrSelect(c, "text.axis-title").html(
        Q || b ? "" : ue(m.title)
      ), Z = T(m, "titleOrientation");
      let ut;
      switch (e) {
        case Y.LEFT:
          Z === Yr.RIGHT ? j.attr("transform", "rotate(90)").attr("y", 0).attr("x", d.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle") : j.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(d.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case Y.BOTTOM:
          j.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${o + 4})`
          ).style("text-anchor", "middle");
          break;
        case Y.RIGHT:
          Z === Yr.LEFT ? j.attr("transform", "rotate(-90)").attr("y", a).attr("x", -(d.range()[0] / 2)).style("text-anchor", "middle") : j.attr("transform", "rotate(90)").attr("y", -a).attr("x", d.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
          break;
        case Y.TOP:
          ut = _.getSVGElementSize(j, {
            useBBox: !0
          }).height, j.attr(
            "transform",
            `translate(${this.margins.left / 2 + d.range()[1] / 2}, ${ut / 2})`
          ).style("text-anchor", "middle");
          break;
      }
    }
    if (E) {
      const j = yi(
        N.tickValues(),
        T(n, "timeScale", "timeInterval")
      ), Z = B.showDayName, ut = f;
      t && (f = f.transition().call(
        (Et) => this.services.transitions.setupTransition({
          transition: Et,
          name: "axis-update",
          animate: t
        })
      )), f = f.call(N), ut.selectAll(".tick").data(N.tickValues(), d).order().select("text").style("font-weight", (Et, Ut) => ql(Et, Ut, N.tickValues(), j, Z) ? "bold" : "normal");
    } else
      !t || !p ? f = f.call(N) : f = f.transition().call(
        (j) => this.services.transitions.setupTransition({
          transition: j,
          name: "axis-update",
          animate: t
        })
      ).call(N);
    if (g.call(N), e === Y.BOTTOM || e === Y.TOP) {
      let j = !1;
      const Z = T(m, "ticks", "rotation");
      if (Z === zs.ALWAYS)
        j = !0;
      else if (Z === zs.NEVER)
        j = !1;
      else if (!Z || Z === zs.AUTO)
        if (d.step)
          j = g.selectAll("g.tick text").nodes().some(
            (ht) => _.getSVGElementSize(ht, {
              useBBox: !0
            }).width >= d.step()
          );
        else {
          j = !1;
          const ut = g.append("text").text("A"), ht = _.getSVGElementSize(ut.node(), {
            useBBox: !0
          }).width;
          let Et;
          g.selectAll("g.tick").each(function() {
            const Ut = R(this), H = parseFloat(T(fe(this), "tx"));
            H !== null && Et + Ut.text().length * ht * 0.8 >= H && (j = !0), Et = H;
          }), ut.remove();
        }
      j ? (L || (N.ticks(
        this.getNumberOfFittingTicks(a, w, qe.ticks.horizontalSpaceRatio)
      ), g.call(N), f.call(N)), c.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").attr("text-anchor", e === Y.TOP ? "start" : "end")) : c.selectAll("g.ticks g.tick text").attr("transform", null).attr("text-anchor", null);
    }
    if (b ? c.attr("opacity", 0) : c.attr("opacity", 1), f.selectAll("g.tick").attr("aria-label", (j) => j), g.selectAll("g.tick").attr("aria-label", (j) => j), k !== Ze.NONE && S === Mt.LABELS && !I) {
      const j = this.services.cartesianScales.getScaleDomain(e);
      if (j.length > 0) {
        const Z = r.select(`g.axis.${e} g.ticks g.tick`).html();
        c.selectAll("g.ticks g.tick").html(Z);
        const ut = this;
        c.selectAll("g.tick text").data(j).text(function(ht) {
          return ht.length > G ? (ut.truncation[e] = !0, Cn(ht, k, C)) : ht;
        }), this.getInvisibleAxisRef().selectAll("g.tick text").data(j).text(function(ht) {
          return ht.length > G ? Cn(ht, k, C) : ht;
        }), c.selectAll("g.ticks").html(this.getInvisibleAxisRef().html()), c.selectAll("g.tick text").data(j);
      }
    }
    this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = _.appendOrSelect(t, `g.axis.${e}`), i = this.getOptions(), r = T(i, "axes", e), a = T(r, "scaleType"), o = T(r, "truncation", "threshold"), c = this;
    n.selectAll("g.tick text").on("mouseover", function(l, h) {
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: R(this),
        datum: h
      }), a === Mt.LABELS && h.length > o && c.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: l,
        hoveredElement: R(this),
        content: h
      });
    }).on("mousemove", function(l, h) {
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: R(this),
        datum: h
      }), a === Mt.LABELS && h.length > o && c.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      c.services.events.dispatchEvent(x.Axis.LABEL_CLICK, {
        event: l,
        element: R(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: R(this),
        datum: h
      }), a === Mt.LABELS && c.services.events.dispatchEvent(x.Tooltip.HIDE);
    });
  }
  getInvisibleAxisRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} g.ticks.invisible`);
  }
  getTitleRef() {
    const { position: t } = this.configs;
    return this.getComponentContainer().select(`g.axis.${t} text.axis-title`);
  }
  getNumberOfFittingTicks(t, e, n) {
    const i = Math.floor(t / (e * n));
    return $o(i, 2, qe.ticks.number);
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    _.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
  }
}
class Kf extends _l {
  constructor(t, e, n) {
    super(t, e, n);
  }
  render(t = !0) {
    super.render(t), super.destroy();
    const e = this.configs.position, n = this.getComponentContainer(), i = _.appendOrSelect(n, `g.axis.${e}`), r = this;
    i.selectAll("g.tick").each(function(a, o) {
      const c = R(this);
      c.classed("tick-hover", !0).attr("tabindex", o === 0 ? 0 : -1);
      const l = c.select("text"), { width: h, height: d } = _.getSVGElementSize(l, {
        useBBox: !0
      }), u = _.appendOrSelect(c, "rect.axis-holder");
      let p = 0, f = 0;
      switch (e) {
        case Y.LEFT:
          p = -h + Number(l.attr("x")), f = -(d / 2);
          break;
        case Y.RIGHT:
          p = Math.abs(Number(l.attr("x"))), f = -(d / 2);
          break;
        case Y.TOP:
          p = -(h / 2), f = -d + Number(l.attr("y")) / 2, r.truncation[e] && (p = 0, u.attr("transform", "rotate(-45)"));
          break;
        case Y.BOTTOM:
          p = -(h / 2), f = d / 2 - 2, r.truncation[e] && (p = -h, u.attr("transform", "rotate(-45)"));
          break;
      }
      u.attr("x", p - qe.hover.rectanglePadding).attr("y", f).attr("width", h + qe.hover.rectanglePadding * 2).attr("height", d).lower();
    }), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getComponentContainer(), { position: e } = this.configs, n = _.appendOrSelect(t, `g.axis.${e}`), i = this.getOptions(), r = T(i, "axes", e), a = T(r, "scaleType"), o = T(r, "truncation", "threshold"), c = this;
    n.selectAll("g.tick.tick-hover").on("mouseover", function(l) {
      const h = R(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEOVER, {
        event: l,
        element: h,
        datum: d
      }), a === Mt.LABELS && d.length > o && c.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: l,
        element: h,
        datum: d
      });
    }).on("mousemove", function(l) {
      const h = R(this).select("text"), d = h.datum();
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEMOVE, {
        event: l,
        element: h,
        datum: d
      }), c.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l) {
      c.services.events.dispatchEvent(x.Axis.LABEL_CLICK, {
        event: l,
        element: R(this).select("text"),
        datum: R(this).select("text").datum()
      });
    }).on("mouseout", function(l) {
      c.services.events.dispatchEvent(x.Axis.LABEL_MOUSEOUT, {
        event: l,
        element: R(this).select("text"),
        datum: R(this).select("text").datum()
      }), a === Mt.LABELS && c.services.events.dispatchEvent(x.Tooltip.HIDE);
    }).on("focus", function(l) {
      const h = { clientX: 0, clientY: 0 };
      if (l.target) {
        l.target.focus();
        const d = l.target.getBoundingClientRect();
        h.clientX = d.x, h.clientY = d.y;
      }
      c.services.events.dispatchEvent(x.Axis.LABEL_FOCUS, {
        event: { ...l, ...h },
        element: R(this),
        datum: R(this).select("text").datum()
      });
    }).on("blur", function(l) {
      c.services.events.dispatchEvent(x.Axis.LABEL_BLUR, {
        event: l,
        element: R(this),
        datum: R(this).select("text").datum()
      });
    }).on("keydown", function(l) {
      l.key && l.key === "Escape" && (c.services.events.dispatchEvent(x.Tooltip.HIDE), c.services.events.dispatchEvent(x.Axis.LABEL_BLUR, {
        event: l,
        element: R(this),
        datum: R(this).select("text").datum()
      })), e === Y.LEFT || e === Y.RIGHT ? l.key && l.key === "ArrowUp" ? c.goNext(this, l) : l.key && l.key === "ArrowDown" && c.goPrevious(this, l) : l.key && l.key === "ArrowLeft" ? c.goPrevious(this, l) : l.key && l.key === "ArrowRight" && c.goNext(this, l);
    });
  }
  // Focus on the next HTML element sibling
  goNext(t, e) {
    t.nextElementSibling && t.nextElementSibling.tagName !== "path" && t.nextElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  // Focus on the previous HTML element sibling
  goPrevious(t, e) {
    t.previousElementSibling && t.previousElementSibling.tagName !== "path" && t.previousElementSibling.dispatchEvent(new Event("focus")), e.preventDefault();
  }
  destroy() {
    const t = this.getComponentContainer(), { position: e } = this.configs;
    _.appendOrSelect(t, `g.axis.${e}`).selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
  }
}
class b0 extends ot {
  constructor() {
    super(...arguments), this.type = "2D-axes", this.renderType = st.SVG, this.children = {}, this.thresholds = [], this.margins = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  render(t = !1) {
    const e = {}, n = Object.keys(Y), i = T(this.getOptions(), "axes");
    n.forEach((o) => {
      i[Y[o]] && (e[Y[o]] = !0);
    }), this.configs.axes = e, n.forEach((o) => {
      const c = Y[o];
      if (this.configs.axes[c] && !this.children[c]) {
        const l = {
          position: c,
          axes: this.configs.axes,
          margins: this.margins
        }, h = this.model.axisFlavor === ec.DEFAULT ? new _l(this.model, this.services, l) : new Kf(this.model, this.services, l);
        h.setModel(this.model), h.setServices(this.services), h.setParent(this.parent), this.children[c] = h;
      }
    }), Object.keys(this.children).forEach((o) => {
      this.children[o].render(t);
    });
    const r = {};
    Object.keys(this.children).forEach((o) => {
      const c = this.children[o], l = c.configs.position, h = c.getInvisibleAxisRef(), { width: d, height: u } = _.getSVGElementSize(h, { useBBox: !0 });
      let p;
      switch (c.getTitleRef().empty() ? p = 0 : (p = _.getSVGElementSize(c.getTitleRef(), {
        useBBox: !0
      }).height, (l === Y.LEFT || l === Y.RIGHT) && (p += 5)), l) {
        case Y.TOP:
          r.top = u + p;
          break;
        case Y.BOTTOM:
          r.bottom = u + p;
          break;
        case Y.LEFT:
          r.left = d + p;
          break;
        case Y.RIGHT:
          r.right = d + p;
          break;
      }
    }), this.services.events.dispatchEvent(x.Axis.RENDER_COMPLETE), Object.keys(r).some(
      (o) => this.margins[o] !== r[o]
    ) && (this.margins = Object.assign(this.margins, r), this.model.set({ axesMargins: this.margins }, { skipUpdate: !0 }), this.services.events.dispatchEvent(x.ZoomBar.UPDATE), Object.keys(this.children).forEach((o) => {
      const c = this.children[o];
      c.margins = this.margins;
    }), this.render(!0));
  }
}
class Jf extends ot {
  constructor() {
    super(...arguments), this.type = "skeleton";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = T(this.getOptions(), "data", "loading");
    e ? this.renderSkeleton(e) : this.removeSkeleton();
  }
  renderSkeleton(t) {
    if (this.configs.skeleton === Hn.GRID)
      this.renderGridSkeleton(t);
    else if (this.configs.skeleton === Hn.VERT_OR_HORIZ)
      this.renderVertOrHorizSkeleton(t);
    else if (this.configs.skeleton === Hn.PIE)
      this.renderPieSkeleton(t);
    else if (this.configs.skeleton === Hn.DONUT)
      this.renderDonutSkeleton(t);
    else
      throw new Error(`"${this.configs.skeleton}" is not a valid Skeleton type.`);
  }
  renderGridSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawXGrid(t), this.drawYGrid(t), t && this.setShimmerEffect("shimmer-lines");
  }
  renderVertOrHorizSkeleton(t) {
    const e = this.services.cartesianScales.getOrientation();
    this.setScales(), this.drawBackdrop(t), e === Ft.VERTICAL && this.drawYGrid(t), e === Ft.HORIZONTAL && this.drawXGrid(t), this.setShimmerEffect("shimmer-lines");
  }
  renderPieSkeleton(t) {
    const e = this.computeOuterRadius();
    this.drawRing(e, 0, t), t && this.setShimmerEffect("shimmer-areas");
  }
  renderDonutSkeleton(t) {
    const e = this.computeOuterRadius(), n = this.computeInnerRadius();
    this.drawRing(e, n, t), t && this.setShimmerEffect("shimmer-areas");
  }
  setScales() {
    const t = this.services.cartesianScales.getMainXScale().range(), e = this.services.cartesianScales.getMainYScale().range();
    this.xScale = ke().domain([0, 1]).range(t), this.yScale = ke().domain([0, 1]).range(e);
  }
  drawBackdrop(t) {
    const e = this.parent, { width: n, height: i } = _.getSVGElementSize(e, {
      useAttrs: !0
    });
    this.backdrop = _.appendOrSelect(e, "svg.chart-skeleton.DAII").attr("width", n).attr("height", i);
    const r = _.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
    r.attr("width", "100%").attr("height", "100%");
    const [a] = this.xScale.range(), [, o] = this.yScale.range();
    this.backdrop.merge(r).attr("x", a).attr("y", o), r.classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawXGrid(t) {
    const e = +this.backdrop.attr("width"), n = T(this.getOptions(), "grid", "x", "numberOfTicks"), i = this.xScale.ticks(n).map((o) => o * e), r = _.appendOrSelect(this.backdrop, "g.x.skeleton"), a = r.selectAll("line").data(i);
    a.enter().append("line").merge(a).attr("x1", (o) => o).attr("x2", (o) => o).attr("y1", 0).attr("y2", "100%"), r.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawYGrid(t) {
    const e = +this.backdrop.attr("height"), n = this.backdrop.attr("width"), i = T(this.getOptions(), "grid", "y", "numberOfTicks"), r = this.xScale.ticks(i).map((c) => c * e), a = _.appendOrSelect(this.backdrop, "g.y.skeleton"), o = a.selectAll("line").data(r);
    o.enter().append("line").merge(o).attr("x1", 0).attr("x2", n).attr("y1", (c) => c).attr("y2", (c) => c), a.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  drawRing(t, e, n = !0) {
    const i = this.parent, { width: r, height: a } = _.getSVGElementSize(i, {
      useAttrs: !0
    }), o = _.appendOrSelect(i, "svg.chart-skeleton").attr("width", r).attr("height", a), c = e === 0 ? "pie" : "donut", l = T(this.getOptions(), c, "alignment");
    _.appendOrSelect(o, "rect.chart-skeleton-area-container").attr("width", r).attr("height", a).attr("fill", "none");
    const h = Dn().innerRadius(e).outerRadius(t).startAngle(0).endAngle(Math.PI * 2), d = t + Math.abs(vt.radiusOffset), u = t + (Math.min(r, a) - t * 2) / 2, p = _.appendOrSelect(o, "path").attr("class", "skeleton-area-shape").attr("transform", `translate(${d}, ${u})`).attr("d", h).classed("shimmer-effect-areas", n).classed("empty-state-areas", !n).style(
      "fill",
      n ? `url(#${this.services.domUtils.generateElementIDString("shimmer-areas")})` : null
    );
    let f = t + vt.xOffset;
    l === Jt.CENTER ? f = r / 2 : l === Jt.RIGHT && (f = r - t - vt.xOffset);
    const g = t + vt.yOffset;
    p.attr("transform", `translate(${f}, ${g})`);
  }
  // same logic in pie
  computeOuterRadius() {
    const { width: t, height: e } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return Math.min(t, e) / 2 + vt.radiusOffset;
  }
  // same logic in donut
  computeInnerRadius() {
    return this.computeOuterRadius() * (3 / 4);
  }
  setShimmerEffect(t) {
    const r = "stop-bg-shimmer", a = "stop-shimmer", o = this.parent.select(".chart-skeleton"), { width: c } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), l = 0, h = c, d = _.appendOrSelect(o, "defs").lower(), u = _.appendOrSelect(d, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(t)).attr("class", t).attr("x1", l - 3 * 0.2 * c).attr("x2", h).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)"), p = `
			<stop class="${r}" offset="${l}"></stop>
			<stop class="${a}" offset="${l + 0.2}"></stop>
			<stop class="${r}" offset="${l + 2 * 0.2}"></stop>
		`;
    u.html(p), f();
    function f() {
      u.attr("gradientTransform", `translate(${l - 3 * 0.2 * c}, 0)`).transition().duration(2e3).delay(1e3).ease(xu).attr("gradientTransform", `translate(${h + 3 * 0.2 * c}, 0)`).on("end", f);
    }
  }
  removeSkeleton() {
    this.parent.select(".chart-skeleton").remove();
  }
}
class T0 extends ot {
  constructor() {
    super(...arguments), this.type = "boxplot", this.renderType = st.SVG;
  }
  render(t) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: i } = n.data, r = this.model.getDataGroupNames(), a = this.services.cartesianScales.getMainXScale(), o = this.services.cartesianScales.getMainYScale(), [c, l] = a.range(), [h, d] = o.range(), u = l - c, p = h - d;
    if (u === 0)
      return;
    const { cartesianScales: f } = this.services, g = f.getOrientation(), m = g === Ft.VERTICAL, [E, y] = ye(
      (L) => this.services.cartesianScales.getDomainValue(L),
      (L) => this.services.cartesianScales.getRangeValue(L),
      g
    ), v = Math.floor((m ? u : p) / r.length), S = Math.min(v / 2, 16), b = this.model.getBoxplotData(), O = e.selectAll(".box-group").data(b);
    O.exit().remove();
    const I = O.enter().append("g").attr("class", "box-group"), k = O.merge(I);
    I.append("path").merge(O.select("path.vertical-line.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        originalClassName: "vertical-line start"
      })
    ).attr("stroke-width", jt.strokeWidth.default).attr("fill", "none").transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-verticalstartline",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]), D = B, A = f.getRangeValue(L.whiskers.min), w = f.getRangeValue(L.quartiles.q_25);
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    }), I.append("path").merge(O.select("path.vertical-line.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        originalClassName: "vertical-line end"
      })
    ).attr("stroke-width", jt.strokeWidth.default).attr("fill", "none").transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-verticalendline",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]), D = B, A = f.getRangeValue(L.whiskers.max), w = f.getRangeValue(L.quartiles.q_75);
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    }), I.append("path").merge(O.select("path.box")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.FILL, tt.STROKE],
        originalClassName: "box"
      })
    ).attr("fill-opacity", jt.box.opacity.default).attr("stroke-width", jt.strokeWidth.default).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", (L) => L[i]).transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-quartiles",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]) - S / 2, D = B + S, A = f.getRangeValue(
        Math[m ? "max" : "min"](L.quartiles.q_75, L.quartiles.q_25)
      ), w = A + Math.abs(
        f.getRangeValue(L.quartiles.q_75) - f.getRangeValue(L.quartiles.q_25)
      );
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    }), I.append("path").merge(O.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", (L) => {
      const B = f.getDomainValue(L[i]) - S / 2, D = B + S, A = f.getRangeValue(L.whiskers.min), w = f.getRangeValue(L.whiskers.max);
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    }), I.append("path").merge(O.select("path.whisker.start")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        originalClassName: "whisker start"
      })
    ).attr("stroke-width", jt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-startingwhisker",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]) - S / 4, D = B + S / 2, A = f.getRangeValue(L.whiskers.min), w = f.getRangeValue(L.whiskers.min);
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    }), I.append("path").merge(O.select("path.median")).attr("fill", "none").attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        originalClassName: "median"
      })
    ).attr("stroke-width", 2).transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-median",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]) - S / 2, D = B + S, A = f.getRangeValue(L.quartiles.q_50);
      return $t({ x0: B, x1: D, y0: A, y1: A }, g);
    }), I.append("path").merge(O.select("path.whisker.end")).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        originalClassName: "whisker end"
      })
    ).attr("stroke-width", jt.strokeWidth.thicker).attr("fill", "none").transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-endingwhisker",
        animate: t
      })
    ).attr("d", (L) => {
      const B = f.getDomainValue(L[i]) - S / 4, D = B + S / 2, A = f.getRangeValue(L.whiskers.max), w = f.getRangeValue(L.whiskers.max);
      return $t({ x0: B, x1: D, y0: A, y1: w }, g);
    });
    const G = k.selectAll("circle.outlier").data(
      (L) => L.outliers.map((B) => ({
        min: L.whiskers.min,
        max: L.whiskers.max,
        [i]: L[i],
        value: B
      }))
    );
    G.exit().remove();
    const C = G.enter().append("circle");
    G.merge(C).attr("r", jt.circle.radius).attr(
      "class",
      () => this.model.getColorClassName({
        classNameTypes: [tt.FILL, tt.STROKE],
        originalClassName: "outlier"
      })
    ).attr("fill-opacity", jt.circle.opacity.default).attr("cx", E).transition().call(
      (L) => this.services.transitions.setupTransition({
        transition: L,
        name: "boxplot-update-circles",
        animate: t
      })
    ).attr("cy", y), this.addBoxEventListeners(), this.addCircleEventListeners();
  }
  addBoxEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data;
    this.parent.selectAll("path.highlight-area").on("mouseover", function(i, r) {
      const a = R(this);
      R(this.parentNode).select("path.box").classed("hovered", !0).attr("fill-opacity", jt.box.opacity.hovered), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        items: [
          {
            label: T(e, "locale", "translations", "group") || T(e, "tooltip", "groupLabel") || "Group",
            value: r[n],
            class: t.model.getColorClassName({
              classNameTypes: [tt.TOOLTIP]
            })
          },
          {
            label: "Minimum",
            value: r.whiskers.min
          },
          {
            label: "Q1",
            value: r.quartiles.q_25
          },
          {
            label: "Median",
            value: r.quartiles.q_50
          },
          {
            label: "Q3",
            value: r.quartiles.q_75
          },
          {
            label: "Maximum",
            value: r.whiskers.max
          },
          {
            label: "IQR",
            value: r.quartiles.q_75 - r.quartiles.q_25
          }
        ]
      }), t.services.events.dispatchEvent(x.Boxplot.BOX_MOUSEOVER, {
        event: i,
        element: a,
        datum: r
      });
    }).on("mousemove", function(i, r) {
      const a = R(this);
      t.services.events.dispatchEvent(x.Boxplot.BOX_MOUSEMOVE, {
        event: i,
        element: a,
        datum: r
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, r) {
      t.services.events.dispatchEvent(x.Boxplot.BOX_CLICK, {
        event: i,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(i, r) {
      const a = R(this);
      R(this.parentNode).select("path.box").classed("hovered", !1).attr("fill-opacity", jt.box.opacity.default), t.services.events.dispatchEvent(x.Boxplot.BOX_MOUSEOUT, {
        event: i,
        element: a,
        datum: r
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  addCircleEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, i = this.services.cartesianScales.getRangeIdentifier();
    this.parent.selectAll("circle").on("mouseover", function(r, a) {
      const o = R(this);
      o.classed("hovered", !0).attr("fill-opacity", jt.circle.opacity.hovered).classed("unfilled", !1), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        items: [
          {
            label: T(e, "locale", "translations", "group") || T(e, "tooltip", "groupLabel") || "Group",
            value: a[n],
            class: t.model.getColorClassName({
              classNameTypes: [tt.TOOLTIP]
            })
          },
          {
            label: "Outlier",
            value: a[i]
          }
        ]
      }), t.services.events.dispatchEvent(x.Boxplot.OUTLIER_MOUSEOVER, {
        event: r,
        element: o,
        datum: a
      });
    }).on("mousemove", function(r, a) {
      const o = R(this);
      t.services.events.dispatchEvent(x.Boxplot.OUTLIER_MOUSEMOVE, {
        event: r,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, a) {
      t.services.events.dispatchEvent(x.Boxplot.OUTLIER_CLICK, {
        event: r,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(r, a) {
      const o = R(this);
      o.classed("hovered", !1).attr("fill-opacity", jt.circle.opacity.default), t.services.events.dispatchEvent(x.Boxplot.OUTLIER_MOUSEOUT, {
        event: r,
        element: o,
        datum: a
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class O0 extends ot {
  constructor() {
    super(...arguments), this.type = "zero-line", this.renderType = st.SVG;
  }
  render(t) {
    const e = this.services.cartesianScales.getRangeAxisPosition({
      groups: this.configs.groups
    }), n = this.services.cartesianScales.getScaleByPosition(e), [i, r] = n.domain(), a = i > 0 && r < 0 || i < 0 && r > 0, o = this.getComponentContainer();
    if (!a) {
      o.selectAll("line.domain").remove();
      return;
    }
    const [c, l] = this.services.cartesianScales.getDomainScale().range();
    let h = +n(0) + 0.5;
    h || (h = n.range()[0]);
    const d = Zl(
      {
        x0: c,
        x1: l,
        y0: h,
        y1: h
      },
      this.services.cartesianScales.getOrientation()
    );
    _.appendOrSelect(o, "line.domain").transition().call(
      (p) => this.services.transitions.setupTransition({
        transition: p,
        name: "zero-line-update",
        animate: t
      })
    ).attr("y1", d.y0).attr("y2", d.y1).attr("x1", d.x0).attr("x2", d.x1);
  }
}
class w0 extends Sr {
  constructor() {
    super(...arguments), this.type = "bubble", this.renderType = st.SVG;
  }
  getRadiusScale(t) {
    const e = this.getOptions(), { radiusMapsTo: n } = e.bubble, i = t.data(), r = i.map((l) => l[n]).filter((l) => l), a = _.getHTMLElementSize(this.services.domUtils.getMainContainer()), o = r.length > 0, c = o ? ks(r) : [1, 1];
    return ke().domain(c).range(o ? e.bubble.radiusRange(a, i) : [4, 4]);
  }
  styleCircles(t, e) {
    const n = this.getOptions(), { radiusMapsTo: i } = n.bubble, r = this.getRadiusScale(t), { groupMapsTo: a } = n.data, { cartesianScales: o } = this.services, c = (u) => o.getDomainValue(u), l = (u) => o.getRangeValue(u), [h, d] = ye(
      c,
      l,
      o.getOrientation()
    );
    t.raise().classed("dot", !0).attr("role", it.GRAPHICS_SYMBOL).attr("aria-label", (u) => {
      const p = o.getRangeIdentifier(u);
      return u[p];
    }).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bubble-update-enter",
        animate: e
      })
    ).attr("cx", h).attr("cy", d).attr("r", (u) => r(u[i] || 1)).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [tt.FILL, tt.STROKE],
        dataGroupName: u[a],
        originalClassName: "dot"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[a], u[p], u);
    }).style("stroke", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getStrokeColor(u[a], u[p], u);
    }).attr("fill-opacity", n.bubble.fillOpacity).attr("opacity", 1);
  }
  getTooltipAdditionalItems(t) {
    const e = T(this.getOptions(), "bubble");
    return [
      {
        label: T(e, "radiusLabel"),
        value: t[T(e, "radiusMapsTo")]
      }
    ];
  }
}
class L0 extends ot {
  constructor() {
    super(...arguments), this.type = "bullet", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, i = this.getComponentContainer({ withinChartClip: !0 }), r = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getRangeScale(), o = this.services.cartesianScales.getRangeIdentifier(), [c, l] = a.range(), [, h] = a.domain(), d = () => {
      const g = [];
      r.forEach((y) => {
        y.ranges ? y.ranges.forEach((v, S) => {
          v != null && v < h && g.push({
            datum: y,
            value: v,
            order: S + 1
          });
        }) : g.push({
          datum: y,
          order: 1
        });
      });
      const m = _.appendOrSelect(i, "g.range-boxes").selectAll("path.range-box").data(g, (y) => `${y[n]}-${y.order}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (y) => `range-box order-${y.order}`).transition().call(
        (y) => this.services.transitions.setupTransition({
          transition: y,
          name: "bullet-range-box-update-enter",
          animate: t
        })
      ).attr("d", (y) => {
        let S, b, O, I;
        return y.order === 1 ? (S = this.services.cartesianScales.getDomainValue(y.datum) - 16 / 2, b = S + 16, O = l - 2, I = c + 1) : (S = this.services.cartesianScales.getDomainValue(y.datum) - 16 / 2, b = S + 16, O = this.services.cartesianScales.getRangeValue(y.value), I = l), $t(
          { x0: S, x1: b, y0: O, y1: I },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, u = () => {
      const g = _.appendOrSelect(i, "g.bars").selectAll("path.bar").data(r, (E) => E[n]);
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("bar", !0).transition().call(
        (E) => this.services.transitions.setupTransition({
          transition: E,
          name: "bullet-bar-update-enter",
          animate: t
        })
      ).attr(
        "class",
        (E) => this.model.getColorClassName({
          classNameTypes: [tt.FILL],
          dataGroupName: E[n],
          originalClassName: "bar"
        })
      ).style("fill", (E) => {
        const y = this.services.cartesianScales.getDomainIdentifier(E);
        return this.model.getFillColor(E[n], E[y], E);
      }).attr("d", (E) => {
        const v = this.services.cartesianScales.getDomainValue(E) - 4, S = v + 8, b = this.services.cartesianScales.getRangeValue(0) + 1, O = this.services.cartesianScales.getRangeValue(E);
        return $t(
          { x0: v, x1: S, y0: b, y1: O },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (E) => E.value);
    }, p = () => {
      const g = _.appendOrSelect(i, "g.markers").selectAll("path.marker").data(
        r.filter((E) => T(E, "marker") !== null),
        (E) => E[n]
      );
      g.exit().attr("opacity", 0).remove(), g.enter().append("path").attr("opacity", 0).merge(g).classed("marker", !0).transition().call(
        (E) => this.services.transitions.setupTransition({
          transition: E,
          name: "bullet-marker-update-enter",
          animate: t
        })
      ).attr("d", (E) => {
        const v = this.services.cartesianScales.getDomainValue(E) - 12, S = v + 24, b = this.services.cartesianScales.getRangeValue(E.marker);
        return $t(
          { x0: v, x1: S, y0: b, y1: b },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    }, f = () => {
      let g = [];
      r.filter((y) => T(y, "marker") !== null).forEach((y) => {
        const v = y.marker, S = y[o];
        g = g.concat([
          { datum: y, value: v * 0.25, barValue: S },
          { datum: y, value: v * 0.5, barValue: S },
          { datum: y, value: v * 0.75, barValue: S }
        ]);
      });
      const m = _.appendOrSelect(i, "g.quartiles").selectAll("path.quartile").data(g, (y) => y[n]);
      m.exit().attr("opacity", 0).remove(), m.enter().append("path").attr("opacity", 0).merge(m).attr("class", (y) => `quartile ${y.value <= y.barValue ? "over-bar" : ""}`).transition().call(
        (y) => this.services.transitions.setupTransition({
          transition: y,
          name: "bullet-quartile-update-enter",
          animate: t
        })
      ).attr("d", ({ datum: y, value: v }) => {
        let S = 4;
        y.ranges && y.ranges.indexOf(v) !== -1 && (S = 8);
        const b = this.services.cartesianScales.getDomainValue(y) - S / 2, O = b + S, I = this.services.cartesianScales.getRangeValue(v);
        return $t(
          { x0: b, x1: O, y0: I, y1: I },
          this.services.cartesianScales.getOrientation()
        );
      }).attr("opacity", 1);
    };
    d(), u(), p(), f(), this.addEventListeners();
  }
  addEventListeners() {
    const t = this, e = this.getOptions(), { groupMapsTo: n } = e.data, i = this.services.cartesianScales.getRangeIdentifier(), { code: r, number: a } = T(e, "locale");
    this.parent.selectAll("path.bar").on("mouseover", function(o, c) {
      const l = R(this);
      l.classed("hovered", !0), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOVER, {
        event: o,
        element: l,
        datum: c
      });
      const h = T(e, "bullet", "performanceAreaTitles"), d = t.model.getMatchingRangeIndexForDatapoint(c);
      t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: o,
        hoveredElement: l,
        items: [
          {
            label: T(e, "locale", "translations", "group") || T(e, "tooltip", "groupLabel") || "Group",
            value: c[n],
            class: t.model.getColorClassName({
              classNameTypes: [tt.TOOLTIP],
              dataGroupName: c[n]
            })
          },
          {
            label: "Value",
            value: c[i]
          },
          {
            label: "Target",
            value: c.marker
          },
          {
            label: "Percentage",
            value: `${a(Math.floor(c[i] / c.marker * 100), r)}%`
          },
          {
            label: "Performance",
            value: h[d]
          }
        ]
      });
    }).on("mousemove", function(o, c) {
      t.services.events.dispatchEvent(x.Bar.BAR_MOUSEMOVE, {
        event: o,
        element: R(this),
        datum: c
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: o
      });
    }).on("click", function(o, c) {
      t.services.events.dispatchEvent(x.Bar.BAR_CLICK, {
        event: o,
        element: R(this),
        datum: c
      });
    }).on("mouseout", function(o, c) {
      const l = R(this);
      l.classed("hovered", !1), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOUT, {
        event: o,
        element: l,
        datum: c
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: l
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
function Qf(s) {
  return s;
}
function tg(s) {
  if (s == null) return Qf;
  var t, e, n = s.scale[0], i = s.scale[1], r = s.translate[0], a = s.translate[1];
  return function(o, c) {
    c || (t = e = 0);
    var l = 2, h = o.length, d = new Array(h);
    for (d[0] = (t += o[0]) * n + r, d[1] = (e += o[1]) * i + a; l < h; ) d[l] = o[l], ++l;
    return d;
  };
}
function eg(s, t) {
  for (var e, n = s.length, i = n - t; i < --n; ) e = s[i], s[i++] = s[n], s[n] = e;
}
function ng(s, t) {
  return typeof t == "string" && (t = s.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(e) {
    return oo(s, e);
  }) } : oo(s, t);
}
function oo(s, t) {
  var e = t.id, n = t.bbox, i = t.properties == null ? {} : t.properties, r = xr(s, t);
  return e == null && n == null ? { type: "Feature", properties: i, geometry: r } : n == null ? { type: "Feature", id: e, properties: i, geometry: r } : { type: "Feature", id: e, bbox: n, properties: i, geometry: r };
}
function xr(s, t) {
  var e = tg(s.transform), n = s.arcs;
  function i(h, d) {
    d.length && d.pop();
    for (var u = n[h < 0 ? ~h : h], p = 0, f = u.length; p < f; ++p)
      d.push(e(u[p], p));
    h < 0 && eg(d, f);
  }
  function r(h) {
    return e(h);
  }
  function a(h) {
    for (var d = [], u = 0, p = h.length; u < p; ++u) i(h[u], d);
    return d.length < 2 && d.push(d[0]), d;
  }
  function o(h) {
    for (var d = a(h); d.length < 4; ) d.push(d[0]);
    return d;
  }
  function c(h) {
    return h.map(o);
  }
  function l(h) {
    var d = h.type, u;
    switch (d) {
      case "GeometryCollection":
        return { type: d, geometries: h.geometries.map(l) };
      case "Point":
        u = r(h.coordinates);
        break;
      case "MultiPoint":
        u = h.coordinates.map(r);
        break;
      case "LineString":
        u = a(h.arcs);
        break;
      case "MultiLineString":
        u = h.arcs.map(a);
        break;
      case "Polygon":
        u = c(h.arcs);
        break;
      case "MultiPolygon":
        u = h.arcs.map(c);
        break;
      default:
        return null;
    }
    return { type: d, coordinates: u };
  }
  return l(t);
}
function sg(s, t) {
  var e = {}, n = {}, i = {}, r = [], a = -1;
  t.forEach(function(l, h) {
    var d = s.arcs[l < 0 ? ~l : l], u;
    d.length < 3 && !d[1][0] && !d[1][1] && (u = t[++a], t[a] = l, t[h] = u);
  }), t.forEach(function(l) {
    var h = o(l), d = h[0], u = h[1], p, f;
    if (p = i[d])
      if (delete i[p.end], p.push(l), p.end = u, f = n[u]) {
        delete n[f.start];
        var g = f === p ? p : p.concat(f);
        n[g.start = p.start] = i[g.end = f.end] = g;
      } else
        n[p.start] = i[p.end] = p;
    else if (p = n[u])
      if (delete n[p.start], p.unshift(l), p.start = d, f = i[d]) {
        delete i[f.end];
        var m = f === p ? p : f.concat(p);
        n[m.start = f.start] = i[m.end = p.end] = m;
      } else
        n[p.start] = i[p.end] = p;
    else
      p = [l], n[p.start = d] = i[p.end = u] = p;
  });
  function o(l) {
    var h = s.arcs[l < 0 ? ~l : l], d = h[0], u;
    return s.transform ? (u = [0, 0], h.forEach(function(p) {
      u[0] += p[0], u[1] += p[1];
    })) : u = h[h.length - 1], l < 0 ? [u, d] : [d, u];
  }
  function c(l, h) {
    for (var d in l) {
      var u = l[d];
      delete h[u.start], delete u.start, delete u.end, u.forEach(function(p) {
        e[p < 0 ? ~p : p] = 1;
      }), r.push(u);
    }
  }
  return c(i, n), c(n, i), t.forEach(function(l) {
    e[l < 0 ? ~l : l] || r.push([l]);
  }), r;
}
function ig(s) {
  for (var t = -1, e = s.length, n, i = s[e - 1], r = 0; ++t < e; ) n = i, i = s[t], r += n[0] * i[1] - n[1] * i[0];
  return Math.abs(r);
}
function rg(s) {
  return xr(s, ag.apply(this, arguments));
}
function ag(s, t) {
  var e = {}, n = [], i = [];
  t.forEach(r);
  function r(c) {
    switch (c.type) {
      case "GeometryCollection":
        c.geometries.forEach(r);
        break;
      case "Polygon":
        a(c.arcs);
        break;
      case "MultiPolygon":
        c.arcs.forEach(a);
        break;
    }
  }
  function a(c) {
    c.forEach(function(l) {
      l.forEach(function(h) {
        (e[h = h < 0 ? ~h : h] || (e[h] = [])).push(c);
      });
    }), n.push(c);
  }
  function o(c) {
    return ig(xr(s, { type: "Polygon", arcs: [c] }).coordinates[0]);
  }
  return n.forEach(function(c) {
    if (!c._) {
      var l = [], h = [c];
      for (c._ = 1, i.push(l); c = h.pop(); )
        l.push(c), c.forEach(function(d) {
          d.forEach(function(u) {
            e[u < 0 ? ~u : u].forEach(function(p) {
              p._ || (p._ = 1, h.push(p));
            });
          });
        });
    }
  }), n.forEach(function(c) {
    delete c._;
  }), {
    type: "MultiPolygon",
    arcs: i.map(function(c) {
      var l = [], h;
      if (c.forEach(function(g) {
        g.forEach(function(m) {
          m.forEach(function(E) {
            e[E < 0 ? ~E : E].length < 2 && l.push(E);
          });
        });
      }), l = sg(s, l), (h = l.length) > 1)
        for (var d = 1, u = o(l[0]), p, f; d < h; ++d)
          (p = o(l[d])) > u && (f = l[0], l[0] = l[d], l[d] = f, u = p);
      return l;
    }).filter(function(c) {
      return c.length > 0;
    })
  };
}
class A0 extends Ml {
  constructor() {
    super(...arguments), this.type = "ruler-binned", this.renderType = st.SVG;
  }
  showRuler(t, [e, n]) {
    const i = this.parent, r = this.model.getOptions(), { cartesianScales: a } = this.services, o = a.getOrientation(), c = a.getRangeScale(), [l, h] = c.range(), d = a.getDomainScale(), u = d.invert(
      o === Ft.VERTICAL ? e : n
    ), p = _.appendOrSelect(i, "g.ruler").attr("aria-label", "ruler"), f = _.appendOrSelect(p, "line.ruler-line"), m = i.selectAll("[role=graphics-symbol]").filter((E) => {
      if (parseFloat(yt(E, "data.x0")) <= u && parseFloat(yt(E, "data.x1")) >= u)
        return !0;
    });
    if (m.size() > 0) {
      this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Vo(this.elementsToHighlight, m) && this.hideRuler(), m.dispatch("mouseover"), this.elementsToHighlight = m;
      const E = R(m.nodes()[0]).datum(), y = parseFloat(yt(E, "data.x0")), v = parseFloat(yt(E, "data.x1")), S = this.model.getActiveDataGroupNames(), b = S.reverse().map((I) => ({
        label: I,
        value: yt(E, `data.${I}`),
        class: this.model.getColorClassName({
          classNameTypes: [tt.TOOLTIP],
          dataGroupName: I
        })
      })).filter((I) => I.value !== 0);
      if (b.length > 0) {
        this.services.events.dispatchEvent(x.Tooltip.SHOW, {
          event: t,
          mousePosition: [e, n],
          hoveredElement: f,
          items: [
            {
              label: yt(r, "bins.rangeLabel") || "Range",
              value: `${y} – ${v}`
            },
            ...b,
            ...T(r, "tooltip", "showTotal") === !0 ? [
              {
                label: yt(r, "locale.translations.total") || yt(r, "tooltip.totalLabel") || "Total",
                value: S.reduce(
                  (k, G) => k + parseFloat(yt(E, `data.${G}`)),
                  0
                )
              }
            ] : []
          ]
        }), p.attr("opacity", 1);
        const I = d((y + v) / 2);
        o === "horizontal" ? f.attr("x1", h).attr("x2", l).attr("y1", I).attr("y2", I) : f.attr("y1", h).attr("y2", l).attr("x1", I).attr("x2", I);
      } else
        this.hideRuler();
    } else
      this.hideRuler();
  }
}
class M0 extends Ml {
  formatTooltipData(t) {
    return t.reverse();
  }
}
const _0 = (s, t) => {
  const e = s.x, n = s.y, i = t.x, r = t.y, a = Is();
  return a.moveTo(e, n), a.lineTo(i, r), a.toString();
}, C0 = (s, t, e = 0.5) => {
  const n = s.x, i = s.y, r = t.x, a = t.y, o = Is();
  return o.moveTo(n, i), o.lineTo(n + (r - n) * e, i), o.lineTo(n + (r - n) * e, a), o.lineTo(r, a), o.toString();
}, k0 = (s, t, e, n, i, r) => {
  const a = s.x, o = s.y, c = t.x, l = t.y, h = Is();
  return h.moveTo(a, o), h.bezierCurveTo(e, n, i, r, c, l), h.toString();
}, R0 = {
  d: "M7 0v8L0 4z",
  height: 8,
  width: 7.5,
  id: "arrowLeft"
}, I0 = {
  d: "M0 0v8l7-4z",
  height: 8,
  width: 7.5,
  id: "arrowRight"
}, D0 = {
  d: "M5.32 9.513a4.75 4.75 0 100-9.5 4.75 4.75 0 000 9.5z",
  height: 10,
  width: 10,
  id: "circle"
}, P0 = {
  d: "M5.03517654-1e-7l4.99999996 5-4.99999996 5-5-5L2.4517844 2.58339204z",
  height: 10,
  width: 10,
  id: "diamond"
}, N0 = {
  d: "M0 .44974747h8v8H0v-3.6830331z",
  height: 9,
  width: 8,
  id: "square"
}, $0 = {
  d: "M0 0h1.5v8H0z",
  height: 8,
  width: 2,
  id: "tee"
};
class V0 extends Mf {
  constructor(t, e, n) {
    super(t, e, n), this.type = "color-legend", this.renderType = st.SVG, this.gradient_id = `gradient-id-${Math.floor(Math.random() * 99999999999)}`, this.handleAxisCompleteEvent = () => {
      const i = this.getComponentContainer(), { width: r } = _.getSVGElementSize(i, {
        useAttrs: !0
      }), a = T(this.getOptions(), "data", "loading");
      if (r > wt.color.barWidth && !a) {
        const o = T(this.getOptions(), "heatmap", "colorLegend", "title"), { cartesianScales: c } = this.services, h = c.getMainXScale().range();
        if (h[0] > 1 && (i.select("g.legend").attr("transform", `translate(${h[0]}, 0)`), o)) {
          const { width: d } = _.getSVGElementSize(
            i.select("g.legend-title").select("text"),
            { useBBox: !0 }
          ), u = h[0] - d - 9;
          u > 1 ? i.select("g.legend-title").attr("transform", `translate(${u}, 0)`) : (i.select("g.legend").attr("transform", `translate(${h[0]}, 16)`), i.select("g.legend-title").attr("transform", `translate(${h[0]}, 0)`));
        }
      } else
        i.select("g.legend-title").attr("transform", "translate(0, 0)");
    }, this.chartType = n.chartType;
  }
  init() {
    this.chartType === "heatmap" && this.services.events.addEventListener(x.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = this.getOptions(), n = this.getComponentContainer(), { width: i } = _.getSVGElementSize(n, {
      useAttrs: !0
    }), r = T(e, "color", "gradient", "colors"), a = T(e, this.chartType, "colorLegend", "type");
    let o = T(e, "color", "pairing", "option");
    const c = T(e, "heatmap", "colorLegend", "title");
    if (T(this.getOptions(), "data", "loading")) {
      n.html("");
      return;
    }
    const h = !Eo(r), d = Kl(this.model.getDisplayData()), u = !(i <= wt.color.barWidth), p = u ? wt.color.barWidth : i, f = _.appendOrSelect(n, "g.legend"), g = _.appendOrSelect(f, "g.legend-axis");
    if (c) {
      const C = _.appendOrSelect(n, "g.legend-title");
      _.appendOrSelect(C, "text").text(c).attr("dy", "0.7em"), f.attr("transform", "translate(0, 16)");
    }
    const m = d[0] < 0 && d[1] > 0 ? "diverge" : "mono";
    (o < 1 && o > 4 && m === "mono" || o < 1 && o > 2 && m === "diverge") && (o = 1);
    let E = [];
    const y = m === "diverge" ? 17 : 11;
    if (h)
      E = r;
    else
      for (let C = 1; C < y + 1; C++)
        E.push(
          a === Fs.LINEAR ? `stop-color-${m}-${o}-${C}` : `fill-${m}-${o}-${C}`
        );
    const v = So(d[0], d[1]), S = Su(v, 3), b = ke().domain(d).range([0, p]), O = hr(b).tickSize(0).tickValues(S), { code: I, number: k } = T(e, "locale");
    O.tickFormat((C) => k(C, I));
    let G;
    switch (a) {
      case Fs.LINEAR:
        this.drawLinear(E, f, p);
        break;
      case Fs.QUANTIZE:
        G = this.drawQuantize(
          E,
          m,
          h,
          f,
          p
        ), b.range([G, p]);
        break;
      default:
        throw Error("Entered color legend type is not supported.");
    }
    g.attr("transform", `translate(0,${wt.color.axisYTranslation})`).call(O), g.select(".domain").remove(), g.select("g.tick:last-of-type text").style("text-anchor", u ? "middle" : "end"), g.select("g.tick:first-of-type text").style(
      "text-anchor",
      u && this.chartType !== "choropleth" ? "middle" : "start"
    );
  }
  // Renders gradient legend
  drawLinear(t, e, n) {
    const i = 100 / (t.length - 1);
    _.appendOrSelect(e, "linearGradient").attr("id", `${this.gradient_id}-legend`).selectAll("stop").data(t).enter().append("stop").attr("offset", (o, c) => `${c * i}%`).attr("class", (o, c) => t[c]).attr("stop-color", (o) => o), _.appendOrSelect(e, "rect").attr("width", n).attr("height", wt.color.barHeight).style("fill", `url(#${this.gradient_id}-legend)`);
  }
  /**
   * Renders quantized legend
   * @returns number (range start)
   */
  drawQuantize(t, e, n, i, r) {
    !n && e === "diverge" && t.splice(t.length / 2, 1);
    const a = cr().domain(t).range([0, r]);
    return _.appendOrSelect(i, "g.quantized-rect").selectAll("rect").data(a.domain()).join("rect").attr("x", (c) => a(c)).attr("y", 0).attr("width", Math.max(0, a.bandwidth() - 1)).attr("height", wt.color.barHeight).attr("class", (c) => c).attr("fill", (c) => c), (!n && e) === "mono" ? a.bandwidth() - 1 : 0;
  }
  destroy() {
    this.chartType === "heatmap" && this.services.events.removeEventListener(x.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
  }
}
class B0 extends Af {
  constructor() {
    super(...arguments), this.type = "meter-title", this.renderType = st.SVG;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !1) {
    const e = T(this.model.getDisplayData(), 0), n = this.getOptions(), i = this.getComponentContainer(), { groupMapsTo: r } = n.data, a = n.locale.translations.meter.title;
    if (T(n, "meter", "proportional"))
      this.displayTotal(), this.displayBreakdownTitle();
    else {
      const h = i.selectAll("text.meter-title").data(a ? [a] : [e[r]]);
      h.enter().append("text").classed("meter-title", !0).merge(h).attr("x", 0).attr("y", "1em").text((d) => d), h.exit().remove(), this.appendPercentage();
    }
    this.displayStatus();
    const c = this.getMaxTitleWidth(), l = _.appendOrSelect(i, "text.meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  displayBreakdownTitle() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = this.model.getMaximumDomain(
      this.model.getDisplayData()
    ), i = T(e, "meter", "proportional", "total"), r = T(e, "meter", "proportional", "unit") ? T(e, "meter", "proportional", "unit") : "";
    let a;
    if (n === i)
      a = null;
    else {
      const h = i !== null ? i - n : n, d = T(e, "meter", "proportional", "breakdownFormatter"), { code: u, number: p } = T(e, "locale");
      a = d !== null ? d({
        datasetsTotal: n,
        total: i
      }) : `${p(n, u)} ${r} used (${p(h, u)} ${r} available)`;
    }
    const o = t.selectAll("text.proportional-meter-title").data([a]);
    o.enter().append("text").classed("proportional-meter-title", !0).merge(o).attr("x", 0).attr("y", "1em").text((h) => h), o.exit().remove();
    const c = this.getMaxTitleWidth(), l = _.appendOrSelect(t, "text.proportional-meter-title");
    c > 0 && l.node().getComputedTextLength() > c && this.truncateTitle(l, c);
  }
  // show the total for prop meter
  displayTotal() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = T(e, "meter", "proportional", "total"), i = n ? T(e, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData()), r = T(e, "meter", "proportional", "unit") ? T(e, "meter", "proportional", "unit") : "", a = T(e, "meter", "proportional", "totalFormatter"), { code: o, number: c } = T(e, "locale"), l = a !== null ? a(i) : `${c(n, o)} ${r} total`, h = _.getHTMLElementSize(this.parent.node()).width, d = t.selectAll("text.proportional-meter-total").data([l]);
    d.enter().append("text").classed("proportional-meter-total", !0).merge(d).attr(
      "x",
      this.model.getStatus() && typeof h != "string" ? h - _t.total.paddingRight : h
    ).attr("y", "1em").attr("text-anchor", "end").text((u) => u), d.exit().remove();
  }
  /**
   * Appends the corresponding status based on the value and the peak.
   */
  displayStatus() {
    const t = this, e = this.getComponentContainer(), n = _.getHTMLElementSize(this.parent.node()).width || 0, i = this.model.getStatus(), r = _t.status.indicatorSize / 2, a = _.appendOrSelect(e, "g.status-indicator").attr("class", i !== null ? `status-indicator status--${i}` : "").attr("transform", `translate(${n - r}, 0)`), o = i ? [i] : [], c = a.selectAll("circle.status").data(o);
    c.enter().append("circle").merge(c).attr("class", "status").attr("r", r).attr("cx", 0).attr("cy", 8);
    const l = a.selectAll("path.innerFill").data(o);
    l.enter().append("path").merge(l).attr("d", t.getStatusIconPathString(i)).attr("transform", `translate(-${r}, 0)`).attr("class", "innerFill"), l.exit().remove(), c.exit().remove();
  }
  /**
   * Appends the associated percentage to the end of the title
   */
  appendPercentage() {
    const t = T(this.model.getDisplayData(), 0, "value"), { code: e, number: n } = T(this.getOptions(), "locale"), i = this.getComponentContainer(), r = _.appendOrSelect(i, "text.meter-title"), a = T(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === !0 ? [t] : [], o = i.selectAll("text.percent-value").data(a), c = _t.statusBar.paddingRight;
    o.enter().append("text").classed("percent-value", !0).merge(o).text((l) => `${l != null ? n(l, e) : 0}%`).attr("x", +r.attr("x") + r.node().getComputedTextLength() + c).attr("y", r.attr("y")), o.exit().remove();
  }
  /**
   * Uses the parent class truncate logic
   * @param title d3 selection of title element that will be truncated
   * @param maxWidth the max width the title can take
   */
  truncateTitle(t, e) {
    super.truncateTitle(t, e);
    const n = _.appendOrSelect(this.parent, "tspan"), i = _t.statusBar.paddingRight, r = Math.ceil(n.node().getComputedTextLength());
    _.appendOrSelect(this.parent, "text.percent-value").attr(
      "x",
      +t.attr("x") + t.node().getComputedTextLength() + r + i
    );
  }
  // computes the maximum space a title can take
  getMaxTitleWidth() {
    const t = T(this.getOptions(), "meter", "proportional"), e = _.getHTMLElementSize(this.parent.node()).width;
    if (t !== null) {
      const n = _.appendOrSelect(this.parent, "text.proportional-meter-total").node(), i = _.getSVGElementSize(n, {
        useBBox: !0
      }).width;
      return e - i - _t.total.paddingLeft;
    } else {
      const n = _.appendOrSelect(this.parent, "text.percent-value"), i = _t.statusBar.paddingRight, r = n.node().getComputedTextLength(), a = _.appendOrSelect(this.parent, "g.status-indicator").node(), o = _.getSVGElementSize(a, { useBBox: !0 }).width + _t.status.paddingLeft;
      return e - r - i - o;
    }
  }
  /**
   * Get the associated status icon for the data
   * @param status the active status for the meter chart
   */
  getStatusIconPathString(t) {
    switch (t) {
      case Ws.SUCCESS:
        return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
      case Ws.DANGER:
        return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
      case Ws.WARNING:
        return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
    }
  }
}
class br extends ot {
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions();
    if (t.bars.width)
      return t.bars.width;
    const e = this.model.getDisplayData().length, n = this.services.cartesianScales.getMainXScale(), i = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width;
    if (!n.step) {
      const r = T(t, "bars", "spacingFactor");
      return Math.min(t.bars.maxWidth, i * r / e);
    }
    return Math.min(t.bars.maxWidth, n.step() / 2);
  }
  isOutsideZoomedDomain(t, e) {
    if (this.model.getDisplayData().length <= 1)
      return !1;
    const i = this.model.get("zoomDomain");
    if (i !== void 0) {
      const r = this.services.cartesianScales.getDomainScale();
      return t < r(i[0]) || e > r(i[1]);
    }
    return !1;
  }
}
class G0 extends ot {
  constructor() {
    super(...arguments), this.type = "circle-pack", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-circlepack"
        })
      ).attr("opacity", (n) => n.data.dataGroupName === e.datum().name ? 1 : un.circles.fillOpacity);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-circlepack"
        })
      ).attr("opacity", 1);
    };
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), { width: n, height: i } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || i < 1)
      return;
    let r = this.model.getDisplayData();
    const a = this.model.hasParentNode(), o = this.model.getHierarchyLevel(), c = this.getOptions(), l = T(c, "canvasZoom", "enabled");
    a && T(r, 0, "children") && (r = T(r, 0, "children"));
    const h = Pn({ children: r }).sum((g) => g.value).sort((g, m) => m.value - g.value), u = dd().size([n, i]).padding((g) => g.depth >= 1 ? un.padding.children + 3 : un.padding.mainGroup + 3)(h).descendants().splice(1).filter((g) => g.depth <= o), p = e.selectAll("circle.node").data(u);
    p.exit().attr("width", 0).attr("height", 0).remove();
    const f = p.enter().append("circle").classed("node", !0);
    f.merge(p).attr("class", (g) => {
      const m = l && o === 3 ? this.getZoomClass(g) : "";
      return this.model.getColorClassName({
        classNameTypes: [tt.FILL, tt.STROKE],
        dataGroupName: g.data.dataGroupName,
        originalClassName: g.children ? `node ${m}` : `node node-leaf ${m}`
      });
    }).style("fill", (g) => this.model.getFillColor(g.data.dataGroupName, null, g.data)).style("stroke", (g) => this.model.getFillColor(g.data.dataGroupName, null, g.data)).attr("cx", (g) => g.x).attr("cy", (g) => g.y).transition("circlepack-leaf-update-enter").call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "circlepack-leaf-update-enter"
      })
    ).attr("r", (g) => g.r).attr("opacity", 1).attr("fill-opacity", un.circles.fillOpacity), l === !0 && this.focal && (this.services.canvasZoom.zoomIn(this.focal, f, Gn), this.setBackgroundListeners()), a || this.addLegendListeners(), this.addEventListeners();
  }
  // turn off the highlight class on children circles
  unhighlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((i) => i === n.data) && n.depth > 1).style("stroke", (n) => this.model.getFillColor(n.data.dataGroupName, null, n.data));
  }
  // highlight the children circles with a stroke
  highlightChildren(t) {
    const e = t.map((n) => n.data);
    this.parent.selectAll("circle.node").filter((n) => e.some((i) => i === n.data) && n.depth > 1).style("stroke", un.circles.hover.stroke);
  }
  getZoomClass(t) {
    return this.model.getHierarchyLevel() === 3 && this.focal && (t.data === this.focal.data || this.focal.children.some((e) => e.data === t.data)) ? "focal" : "non-focal";
  }
  addLegendListeners() {
    const { events: t } = this.services;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  removeBackgroundListeners() {
    R(this.services.domUtils.getMainContainer()).on("click", () => null);
  }
  setBackgroundListeners() {
    const t = R(this.services.domUtils.getMainContainer()), e = this, n = this.parent.selectAll("circle.node");
    t.on("click", () => {
      e.focal = null, e.model.updateHierarchyLevel(2), t.classed("zoomed-in", !1), e.services.canvasZoom.zoomOut(n, Gn);
    });
  }
  // Zoom icon to be appended to the label in the tooltip
  getZoomIcon() {
    return `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">
			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>
			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>
		</svg>`;
  }
  // add event listeners for tooltip on the circles
  addEventListeners() {
    const t = this;
    this.parent.selectAll("circle.node").on("mouseover", function(e, n) {
      const i = R(this);
      i.classed("hovered", !0);
      const r = t.model.getHierarchyLevel(), a = r > 2 && !i.classed("focal"), o = T(t.model.getOptions(), "canvasZoom", "enabled");
      let c = !1;
      if (!a) {
        let l = [], h = [], d = null;
        if (n.children) {
          n.depth > 1 && o && (c = !0, i.classed("clickable", !0)), l = n.children.map((f) => {
            if (f !== null)
              return typeof f.data.value == "number" ? {
                label: f.data.name,
                value: f.data.value
              } : {
                label: f.data.name,
                labelIcon: o && r <= 2 ? t.getZoomIcon() : null,
                value: f.value
              };
          });
          const p = t.model.getOptions();
          h = [
            {
              label: yt(p, "locale.translations.total") || yt(p, "tooltip.totalLabel") || "Total",
              value: n.value,
              bold: !0
            }
          ], t.highlightChildren(n.children);
        } else
          d = n.value;
        const u = getComputedStyle(this, null).getPropertyValue("fill");
        t.services.events.dispatchEvent(x.Tooltip.SHOW, {
          event: e,
          hoveredElement: i,
          items: [
            {
              color: u,
              label: n.data.name,
              labelIcon: c && o && r <= 2 ? t.getZoomIcon() : null,
              value: d
            },
            ...l,
            ...h
          ]
        });
      }
      t.services.events.dispatchEvent(x.CirclePack.CIRCLE_MOUSEOVER, {
        event: e,
        element: i,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.CirclePack.CIRCLE_MOUSEMOVE, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: e
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      i.classed("hovered", !1), n.children && t.unhighlightChildren(n.children), t.services.events.dispatchEvent(x.CirclePack.CIRCLE_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: i
      });
    }).on("click", function(e, n) {
      const i = R(this), r = i.classed("non-focal"), a = T(t.model.getOptions(), "canvasZoom", "enabled");
      if (a && t.model.getHierarchyLevel() > 2) {
        const o = t.parent.selectAll("circle.node");
        R(t.services.domUtils.getMainContainer()).classed("zoomed-in", !1), t.focal = null, t.model.updateHierarchyLevel(2), t.services.canvasZoom.zoomOut(o, Gn);
      } else if (n.depth === 2 && n.children && !r && a) {
        const o = t.parent.selectAll("circle.node");
        R(t.services.domUtils.getMainContainer()).classed("zoomed-in", !0), t.focal = n, t.model.updateHierarchyLevel(3), t.services.canvasZoom.zoomIn(n, o, Gn), e.stopPropagation();
      }
      t.services.events.dispatchEvent(x.CirclePack.CIRCLE_CLICK, {
        event: e,
        element: i,
        datum: n
      });
    });
  }
  destroy() {
    this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), this.removeBackgroundListeners();
  }
}
function og(s, t) {
  const e = yo(this._current, s);
  return (n) => (this._current = e(n), t(this._current));
}
class lg extends ot {
  constructor() {
    super(...arguments), this.type = "pie", this.renderType = st.SVG, this.isRendering = !1, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.slice").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr(
        "opacity",
        (i) => i.data[n] !== e.datum().name ? 0.3 : 1
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getInnerRadius() {
    return vt.innerRadius;
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer(), i = this.getOptions(), { groupMapsTo: r } = i.data, { valueMapsTo: a } = i.pie;
    this.isRendering = !0;
    const o = this.model.getDisplayData().filter((A) => A[a] > 0), c = this.computeRadius();
    this.arc = Dn().innerRadius(this.getInnerRadius()).outerRadius(c), this.hoverArc = Dn().innerRadius(this.getInnerRadius()).outerRadius(c + vt.hoverArc.outerRadiusOffset);
    const h = Dd().value((A) => A[a]).sort(T(i, "pie", "sortFunction")).padAngle(vt.padAngle)(o), u = _.appendOrSelect(n, "g.slices").attr("role", it.GROUP).attr("data-name", "slices").selectAll("path.slice").data(h, (A) => A.data[r]);
    u.exit().attr("opacity", 0).remove(), u.enter().append("path").classed("slice", !0).attr("opacity", 0).merge(u).attr(
      "class",
      (A) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: A.data[r],
        originalClassName: "slice"
      })
    ).style("fill", (A) => e.model.getFillColor(A.data[r], null, A.data)).attr("d", this.arc).transition().call(
      (A) => this.services.transitions.setupTransition({
        transition: A,
        name: "pie_slice_enter_update",
        animate: t
      })
    ).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr(
      "aria-label",
      (A) => `${A[a]}, ${Us(A.data[a], o, a) + "%"}`
    ).attrTween("d", function(A) {
      return og.bind(this)(A, e.arc);
    }).on("end", () => {
      e.isRendering = !1;
    });
    const { code: g, number: m } = T(i, "locale"), E = i.pie.labels.enabled, y = E ? h.filter((A) => A.data[a] > 0) : [], S = _.appendOrSelect(n, "g.labels").attr("role", it.GROUP).attr("data-name", "labels").selectAll("text.pie-label").data(y, (A) => A.data[r]);
    S.exit().attr("opacity", 0).remove();
    const b = S.enter().append("text").classed("pie-label", !0), O = [];
    b.merge(S).style("text-anchor", "middle").text((A) => i.pie.labels.formatter ? i.pie.labels.formatter({
      ...A,
      percentageValue: Us(
        A.data[a],
        o,
        a,
        !0
      )
    }) : m(
      Us(A.data[a], o, a),
      g
    ) + "%").datum(function(A) {
      const w = c + 7, V = (A.endAngle - A.startAngle) / 2 + A.startAngle, N = V / Math.PI * 180, P = this.getComputedTextLength();
      return A.textOffsetX = P / 2, A.textOffsetY = N > 90 && N < 270 ? 10 : 0, A.xPosition = (A.textOffsetX + w) * Math.sin(V), A.yPosition = (A.textOffsetY + w) * -Math.cos(V), A;
    }).attr("transform", function(A, w) {
      const V = y.length, N = (A.endAngle - A.startAngle) * (180 / Math.PI);
      if (w >= V - 2 && N < vt.callout.minSliceDegree) {
        let P, $;
        return A.index === V - 1 ? (P = A.xPosition + vt.callout.offsetX + vt.callout.textMargin + A.textOffsetX, $ = A.yPosition - vt.callout.offsetY, A.direction = Xs.RIGHT, O.push(A)) : (P = A.xPosition - vt.callout.offsetX - A.textOffsetX - vt.callout.textMargin, $ = A.yPosition - vt.callout.offsetY, A.direction = Xs.LEFT, O.push(A)), `translate(${P}, ${$})`;
      }
      return `translate(${A.xPosition}, ${A.yPosition})`;
    }), this.renderCallouts(O);
    const I = T(i, "donut") ? "donut" : "pie", k = T(i, I, "alignment"), { width: G } = _.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    }), C = E ? vt.xOffset : 0, L = E ? vt.yOffset : 0;
    let B = c + C;
    k === Jt.CENTER ? B = G / 2 : k === Jt.RIGHT && (B = G - c - vt.xOffset);
    let D = c + L;
    O.length > 0 && (D += vt.yOffsetCallout), n.attr("x", B + 7).attr("y", D), this.addEventListeners();
  }
  renderCallouts(t) {
    const e = _.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", it.GROUP).attr("data-name", "callouts"), n = e.selectAll("g.callout").data(t);
    n.exit().remove();
    const i = n.enter().append("g").classed("callout", !0).attr("role", it.GROUP).attr("aria-roledescription", "label callout");
    i.merge(n).datum(function(o) {
      const { xPosition: c, yPosition: l, direction: h } = o;
      return h === Xs.RIGHT ? (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c + vt.callout.offsetX,
        y: l - vt.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x - vt.callout.horizontalLineLength) : (o.startPos = {
        x: c,
        y: l + o.textOffsetY
      }, o.endPos = {
        x: c - vt.callout.offsetX,
        y: l - vt.callout.offsetY + o.textOffsetY
      }, o.intersectPointX = o.endPos.x + vt.callout.horizontalLineLength), o;
    }), i.append("line").classed("vertical-line", !0).merge(e.selectAll("line.vertical-line")).datum(function() {
      return R(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.startPos.x).attr("y1", (o) => o.startPos.y).attr("x2", (o) => o.intersectPointX).attr("y2", (o) => o.endPos.y), i.append("line").classed("horizontal-line", !0).merge(e.selectAll("line.horizontal-line")).datum(function() {
      return R(this.parentNode).datum();
    }).style("stroke-width", "1px").attr("x1", (o) => o.intersectPointX).attr("y1", (o) => o.endPos.y).attr("x2", (o) => o.endPos.x).attr("y2", (o) => o.endPos.y);
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.slice").on("mouseover", function(e, n) {
      const i = R(this);
      t.isRendering || i.classed("hovered", !0).transition("pie_slice_mouseover").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "pie_slice_mouseover"
        })
      ).attr("d", t.hoverArc), t.services.events.dispatchEvent(x.Pie.SLICE_MOUSEOVER, {
        event: e,
        element: R(this),
        datum: n
      });
      const { groupMapsTo: r } = t.getOptions().data, { valueMapsTo: a } = t.getOptions().pie;
      t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: e,
        hoveredElement: i,
        items: [
          {
            label: n.data[r],
            value: n.data[a]
          }
        ]
      });
    }).on("mousemove", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.Pie.SLICE_MOUSEMOVE, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(x.Pie.SLICE_CLICK, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      nu(() => {
        t.isRendering || i.classed("hovered", !1).transition("pie_slice_mouseout").call(
          (r) => t.services.transitions.setupTransition({
            transition: r,
            name: "pie_slice_mouseout"
          })
        ).attr("d", t.arc);
      }, 100), t.services.events.dispatchEvent(x.Pie.SLICE_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  // Helper functions
  computeRadius() {
    const { width: t, height: e } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    }), n = this.getOptions(), i = Math.min(t, e) / 2;
    return n.pie.labels.enabled ? i + vt.radiusOffset : i;
  }
}
class H0 extends lg {
  constructor() {
    super(...arguments), this.type = "donut", this.renderType = st.SVG;
  }
  render(t = !0) {
    super.render(t);
    const e = this;
    if (this.model.isDataEmpty()) {
      this.getComponentContainer().select("g.center").remove();
      return;
    }
    const n = _.appendOrSelect(this.getComponentContainer(), "g.center"), i = this.getOptions(), r = this.computeRadius(), a = T(i, "donut", "center", "label");
    _.appendOrSelect(n, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", () => a === null || a === "" ? "central" : "initial").style("font-size", () => i.donut.center.numberFontSize(r)).transition().call(
      (o) => this.services.transitions.setupTransition({
        transition: o,
        name: "donut-figure-enter-update",
        animate: t
      })
    ).tween("text", function() {
      return e.centerNumberTween(R(this));
    }), a !== null && a !== "" && _.appendOrSelect(n, "text.donut-title").attr("text-anchor", "middle").style("font-size", () => i.donut.center.titleFontSize(r)).attr("y", i.donut.center.titleYPosition(r)).text(a);
  }
  getInnerRadius() {
    return this.computeRadius() * (3 / 4);
  }
  centerNumberTween(t) {
    const e = this.getOptions();
    let n = T(e, "donut", "center", "number");
    n === null && (n = this.model.getDisplayData().reduce((o, c) => o + c[e.pie.valueMapsTo], 0));
    const i = parseInt(t.text().replace(/[, ]+/g, ""), 10) || 0;
    let r;
    i % 1 === 0 && n % 1 === 0 ? r = Jl : r = So;
    const a = r(i, n);
    return (o) => {
      const { numberFormatter: c } = e.donut.center;
      if (c)
        t.text(c(a(o)));
      else {
        const { code: l, number: h } = T(e, "locale");
        t.text(h(Math.floor(a(o)), l));
      }
    };
  }
}
const lo = "4,10 8,6 12,10", co = "12,6 8,10 4,6";
class U0 extends ot {
  constructor() {
    super(...arguments), this.type = "gauge", this.renderType = st.SVG;
  }
  getValue() {
    var n;
    return ((n = this.model.getData().find((i) => i.group === "value")) == null ? void 0 : n.value) ?? null;
  }
  getValueRatio() {
    return $o(this.getValue(), 0, 100) / 100;
  }
  getDelta() {
    var n;
    return ((n = this.model.getData().find((i) => i.group === "delta")) == null ? void 0 : n.value) ?? null;
  }
  getArcRatio() {
    const t = this.getOptions();
    return T(t, "gauge", "type") === Un.FULL ? 1 : 0.5;
  }
  getArcSize() {
    return this.getArcRatio() * Math.PI * 2;
  }
  getStartAngle() {
    const t = this.getArcSize();
    return t === 2 * Math.PI ? 0 : -t / 2;
  }
  // use provided arrow direction or default to using the delta
  getArrow(t) {
    const e = this.getOptions();
    switch (T(e, "gauge", "deltaArrow", "direction")) {
      case qr.UP:
        return lo;
      case qr.DOWN:
        return co;
      default:
        return t > 0 ? lo : co;
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), n = this.getOptions(), i = this.getValue(), r = this.getValueRatio(), a = this.getArcSize(), o = this.getStartAngle(), c = r * a, l = o + c, h = o + a, d = this.computeRadius(), u = this.getInnerRadius();
    this.backgroundArc = Dn().innerRadius(u).outerRadius(d).startAngle(l).endAngle(h), this.arc = Dn().innerRadius(u).outerRadius(d).startAngle(o).endAngle(l), _.appendOrSelect(e, "path.arc-background").attr("d", this.backgroundArc);
    const p = e.selectAll("path.arc-foreground").data([i]);
    p.enter().append("path").merge(p).attr(
      "class",
      this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: "value",
        originalClassName: "arc-foreground"
      })
    ).style("fill", () => T(this.getOptions(), "color", "scale", "value")).attr("d", this.arc).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (y) => y), this.drawValueNumber(), this.drawDelta(), p.exit().remove();
    const g = T(n, "gauge", "alignment"), { width: m } = _.getSVGElementSize(this.getParent(), {
      useAttrs: !0
    });
    let E = d;
    g === Jt.CENTER ? E = m / 2 : g === Jt.RIGHT && (E = m - d), e.attr("x", E).attr("y", d), this.addEventListeners();
  }
  /**
   * draws the value number associated with the Gauge component in the center
   */
  drawValueNumber() {
    const t = this.getComponentContainer(), e = this.getOptions(), n = T(e, "gauge", "type"), i = this.getValue(), r = this.getDelta(), a = this.computeRadius(), o = T(e, "gauge", "valueFontSize"), c = T(e, "gauge", "deltaFontSize"), l = T(e, "gauge", "numberSpacing"), h = T(e, "gauge", "showPercentageSymbol");
    let d = 0;
    n === Un.FULL && !r ? d = c(a) : n === Un.SEMI && r && (d = -(c(a) + l));
    const u = _.appendOrSelect(t, "g.gauge-numbers").attr(
      "transform",
      `translate(0, ${d})`
    ), p = o(a), f = _.appendOrSelect(u, "g.gauge-value-number"), { code: g, number: m } = T(e, "locale"), E = T(e, "gauge", "numberFormatter"), y = f.selectAll("text.gauge-value-number").data([i]);
    y.enter().append("text").attr("class", "gauge-value-number").merge(y).style("font-size", `${p}px`).attr("text-anchor", "middle").text((G) => {
      let C;
      return G != null ? C = Number(G.toFixed(2)) % 1 !== 0 ? G.toFixed(2) : G.toFixed() : C = 0, E ? E(C) : m(Number(C), g);
    });
    const { width: v } = _.getSVGElementSize(
      _.appendOrSelect(t, "text.gauge-value-number"),
      { useBBox: !0 }
    ), S = p / 2, b = h ? "%" : "", O = _.appendOrSelect(f, "text.gauge-value-symbol").style("font-size", `${S}px`).attr("x", v / 2).text(b), { width: I, height: k } = _.getSVGElementSize(O, {
      useBBox: !0
    });
    O.attr("y", `-${k / 2}px`), f.attr("transform", `translate(-${I / 2}, 0)`);
  }
  /**
   * adds the delta number for the gauge
   */
  drawDelta() {
    const t = this, e = this.getComponentContainer(), n = this.getOptions(), i = this.getDelta(), { code: r, number: a } = T(n, "locale");
    if (i) {
      const o = this.computeRadius(), c = i ? T(n, "gauge", "deltaFontSize") : () => 0, l = i ? T(n, "gauge", "numberFormatter") : () => null, h = T(n, "gauge", "deltaArrow", "size"), d = T(n, "gauge", "numberSpacing"), u = T(n, "gauge", "showPercentageSymbol"), p = _.appendOrSelect(e, "g.gauge-numbers"), f = _.appendOrSelect(p, "g.gauge-delta").attr(
        "transform",
        `translate(0, ${c(o) + d})`
      ), g = _.appendOrSelect(f, "text.gauge-delta-number"), m = u ? "%" : "";
      g.data(i === null ? [] : [i]), g.enter().append("text").classed("gauge-delta-number", !0).merge(g).attr("text-anchor", "middle").style("font-size", `${c(o)}px`).text((S) => {
        let b;
        return S != null ? b = Number(S.toFixed(2)) % 1 !== 0 ? S.toFixed(2) : S.toFixed() : b = 0, l ? `${l(b)}${m}` : `${a(Number(b), r)}${m}`;
      });
      const { width: E } = _.getSVGElementSize(
        _.appendOrSelect(e, ".gauge-delta-number"),
        { useBBox: !0 }
      ), y = T(n, "gauge", "deltaArrow", "enabled"), v = f.selectAll("svg.gauge-delta-arrow").data(i !== null && y ? [i] : []);
      v.enter().append("svg").merge(v).attr("class", "gauge-delta-arrow").attr("x", -h(o) - E / 2).attr("y", -h(o) / 2 - c(o) * 0.35).attr("width", h(o)).attr("height", h(o)).attr("viewBox", "0 0 16 16").each(function() {
        const S = R(this);
        _.appendOrSelect(S, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
        const b = T(n, "gauge", "status");
        _.appendOrSelect(S, "polygon.gauge-delta-arrow").attr("class", b !== null ? `gauge-delta-arrow status--${b}` : "").attr("points", t.getArrow(i));
      }), v.exit().remove(), g.exit().remove();
    } else {
      const o = e.select("g.gauge-delta");
      o.empty() || o.remove();
    }
  }
  getInnerRadius() {
    const t = this.computeRadius(), e = T(this.getOptions(), "gauge", "arcWidth");
    return t - e;
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.arc-foreground").on("mouseover", function(e, n) {
      t.services.events.dispatchEvent(x.Gauge.ARC_MOUSEOVER, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.Gauge.ARC_MOUSEMOVE, {
        event: e,
        element: i,
        datum: n
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(x.Gauge.ARC_CLICK, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.Gauge.ARC_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      });
    });
  }
  // Helper functions
  computeRadius() {
    const t = this.getOptions(), e = T(t, "gauge", "type"), { width: n, height: i } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    return e === Un.SEMI ? Math.min(n / 2, i) : Math.min(n / 2, i / 2);
  }
}
class z0 extends br {
  constructor() {
    super(...arguments), this.type = "grouped-bar", this.renderType = st.SVG, this.padding = 5, this.defaultStepFactor = 70, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.model.getDisplayData(this.configs.groups), n = this.getOptions(), { groupMapsTo: i } = n.data;
    this.setGroupScale();
    const r = this.getComponentContainer({ withinChartClip: !0 }), a = Ql(
      e.map((u) => {
        const p = this.services.cartesianScales.getDomainIdentifier(u);
        return u[p] && typeof u[p].toString == "function" ? u[p].toString() : u[p];
      })
    ), o = r.selectAll("g.bars").data(a, (u) => u);
    o.exit().attr("opacity", 0).remove();
    const l = o.enter().append("g").classed("bars", !0).attr("role", it.GROUP).attr("data-name", "bars").merge(o);
    l.transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-group-update-enter",
        animate: t
      })
    ).attr("transform", (u) => {
      const f = this.services.cartesianScales.getDomainValue(u) - this.getGroupWidth() / 2;
      return this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? `translate(${f}, 0)` : `translate(0, ${f})`;
    });
    const h = l.selectAll("path.bar").data(
      (u) => this.getDataCorrespondingToLabel(u),
      (u) => u[i]
    );
    h.exit().attr("opacity", 0).remove(), h.enter().append("path").attr("opacity", 0).merge(h).classed("bar", !0).transition().call(
      (u) => this.services.transitions.setupTransition({
        transition: u,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (u) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: u[i],
        originalClassName: "bar"
      })
    ).style("fill", (u) => {
      const p = this.services.cartesianScales.getDomainIdentifier(u);
      return this.model.getFillColor(u[i], u[p], u);
    }).attr("d", (u) => {
      const p = this.groupScale(u[i]), f = this.getBarWidth(), g = p, m = p + f, E = this.services.cartesianScales.getRangeAxisPosition({ datum: u }), y = this.services.cartesianScales.getDomainLowerBound(E), v = this.services.cartesianScales.getValueThroughAxisPosition(E, y), S = this.services.cartesianScales.getRangeValue(u), b = this.services.cartesianScales.getDomainValue(u) - f / 2, O = b + f;
      if (!this.isOutsideZoomedDomain(b, O))
        return $t(
          { x0: g, x1: m, y0: v, y1: S },
          this.services.cartesianScales.getOrientation()
        );
    }).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (u) => u.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(e, n) {
      const i = R(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOVER, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: e,
        hoveredElement: i,
        data: [n]
      });
    }).on("mousemove", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.Bar.BAR_MOUSEMOVE, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(x.Bar.BAR_CLICK, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  getDataCorrespondingToLabel(t) {
    return this.model.getDisplayData(this.configs.groups).filter((n) => {
      const i = this.services.cartesianScales.getDomainIdentifier(n);
      return n[i].toString() === t;
    });
  }
  getGroupWidth() {
    const t = this.model.getGroupedData(this.configs.groups), e = this.getTotalGroupPadding();
    return this.getBarWidth() * t.length + e;
  }
  getDomainScaleStep() {
    const t = this.services.cartesianScales.getDomainScale(), e = this.model.getGroupedData(this.configs.groups);
    let n = this.defaultStepFactor;
    if (typeof t.step == "function")
      n = t.step();
    else if (e.length > 0) {
      const i = e.find((r) => {
        var a;
        return ((a = r.data) == null ? void 0 : a.length) > 1;
      });
      if (i) {
        const r = this.services.cartesianScales.getDomainIdentifier(i.data[0]);
        n = Math.abs(
          t(i.data[1][r]) - t(i.data[0][r])
        );
      }
    }
    return n;
  }
  getTotalGroupPadding() {
    const t = this.model.getGroupedData(this.configs.groups);
    return t.length === 1 ? 0 : Math.min(5, 5 * (this.getDomainScaleStep() / this.defaultStepFactor)) * (t.length - 1);
  }
  // Gets the correct width for bars based on options & configurations
  getBarWidth() {
    const t = this.getOptions(), e = T(t, "bars", "width"), n = T(t, "bars", "maxWidth");
    if (e !== null && (n === null || e <= n))
      return e;
    const r = this.model.getGroupedData(this.configs.groups).length, a = this.getTotalGroupPadding();
    return Math.min(
      n,
      (this.getDomainScaleStep() - a) / r
    );
  }
  setGroupScale() {
    const t = this.model.getActiveDataGroupNames(this.configs.groups);
    this.groupScale = cr().domain(t).rangeRound([0, this.getGroupWidth()]);
  }
}
class F0 extends ot {
  constructor() {
    super(...arguments), this.type = "heatmap", this.renderType = st.SVG, this.matrix = {}, this.xBandwidth = 0, this.yBandwidth = 0, this.translationUnits = {
      x: 0,
      y: 0
    }, this.handleAxisOnHover = (t) => {
      const { detail: e } = t, { datum: n } = e, i = this.model.getUniqueRanges(), r = this.model.getUniqueDomain(), a = this.services.cartesianScales.getDomainLabel(), o = this.services.cartesianScales.getRangeLabel(), c = this.services.cartesianScales.getMainXScale(), l = this.services.cartesianScales.getMainYScale();
      let h = "", d = null, u = null, p = null;
      this.matrix[n] !== void 0 ? (h = a, i.forEach((f) => {
        if (typeof this.matrix[n][f].value == "number") {
          const g = this.matrix[n][f].value;
          if (d === null) {
            d = g, u = g, p = g;
            return;
          }
          d += g, u = g < u ? g : u, p = g > p ? g : p;
        }
      })) : (h = o, r.forEach((f) => {
        if (typeof this.matrix[f][n].value == "number") {
          const g = this.matrix[f][n].value;
          if (d === null) {
            d = g, u = g, p = g;
            return;
          }
          d += g, u = g < u ? g : u, p = g > p ? g : p;
        }
      })), c(n) !== void 0 ? this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${c(n)}, ${Si(l.range())})`) : l(n) !== void 0 && this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", !1).attr("transform", `translate(${Si(c.range())},${l(n)})`), this.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: e.event,
        hoveredElement: R(t.detail.element),
        items: [
          {
            label: h,
            value: n,
            bold: !0
          },
          {
            label: "Min",
            value: u !== null ? u : "-"
          },
          {
            label: "Max",
            value: p !== null ? p : "-"
          },
          {
            label: "Average",
            value: d !== null ? d / r.length : "-"
          }
        ]
      });
    }, this.handleAxisMouseOut = (t) => {
      this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", !0), this.services.events.dispatchEvent(x.Tooltip.HIDE, {
        event: t
      });
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover), t.addEventListener(x.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut), t.addEventListener(x.Axis.LABEL_FOCUS, this.handleAxisOnHover), t.addEventListener(x.Axis.LABEL_BLUR, this.handleAxisMouseOut);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 });
    e.lower();
    const { cartesianScales: n } = this.services;
    if (this.matrix = this.model.getMatrix(), e.html(""), T(this.getOptions(), "data", "loading"))
      return;
    const i = n.getMainXScale(), r = n.getMainYScale(), a = n.getDomainIdentifier(), o = n.getRangeIdentifier(), c = this.model.getUniqueDomain(), l = this.model.getUniqueRanges(), h = this.model.getMatrixAsArray(), d = i.range(), u = r.range();
    this.xBandwidth = Math.abs((d[1] - d[0]) / c.length), this.yBandwidth = Math.abs((u[1] - u[0]) / l.length);
    const p = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
    e.append("defs").append("pattern").attr("id", p).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", !0).attr("width", 0.5).attr("height", 8);
    const f = e.selectAll().data(h).enter().append("g").attr("class", (g) => `heat-${g.index}`).classed("cell", !0).attr(
      "transform",
      (g) => `translate(${i(g[a])}, ${r(g[o])})`
    ).append("rect").attr(
      "class",
      (g) => this.model.getColorClassName({
        value: g.value,
        originalClassName: `heat-${g.index}`
      })
    ).classed("heat", !0).classed("null-state", (g) => g.index === -1 || g.value === null).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", (g) => {
      const m = this.services.cartesianScales.getDomainIdentifier(g);
      return g.index === -1 || g.value === null ? `url(#${p})` : this.model.getFillColor(Number(g.value), g[m], g);
    }).attr("aria-label", (g) => g.value);
    this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth), this.createOuterBox(
      "g.multi-cell.column-highlight",
      this.xBandwidth,
      Math.abs(u[1] - u[0])
    ), this.createOuterBox(
      "g.multi-cell.row-highlight",
      Math.abs(d[1] - d[0]),
      this.yBandwidth
    ), this.determineDividerStatus() && (f.style("stroke-width", "1px"), this.parent.select("g.cell-highlight").classed("cell-2", !0)), this.addEventListener();
  }
  /**
   * Generates a box using lines to create a hover effect
   * The lines have drop shadow in their respective direction
   * @param parentTag - tag name
   * @param xBandwidth - X length
   * @param yBandwidth - y length
   */
  createOuterBox(t, e, n) {
    const i = _.appendOrSelect(this.parent, t).classed("shadows", !0).classed("highlighter-hidden", !0);
    _.appendOrSelect(i, "line.top").attr("x1", -1).attr("x2", e + 1), _.appendOrSelect(i, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", n + 1), _.appendOrSelect(i, "line.down").attr("x1", -1).attr("x2", e + 1).attr("y1", n).attr("y2", n), _.appendOrSelect(i, "line.right").attr("x1", e).attr("x2", e).attr("y1", -1).attr("y2", n + 1);
  }
  determineDividerStatus() {
    const t = T(this.getOptions(), "heatmap", "divider", "state");
    return t !== js.OFF && (t === js.AUTO && Xr.minCellDividerDimension <= this.xBandwidth && Xr.minCellDividerDimension <= this.yBandwidth || t === js.ON);
  }
  addEventListener() {
    const t = this, { cartesianScales: e } = this.services, n = this.getOptions(), i = yt(n, "locale.translations.total") || yt(n, "tooltip.totalLabel") || "Total", r = e.getDomainIdentifier(), a = e.getRangeIdentifier(), o = e.getDomainLabel(), c = e.getRangeLabel();
    this.parent.selectAll("g.cell").on("mouseover", function(l, h) {
      const d = R(this), u = d.select("rect.heat");
      if (!u.classed("null-state")) {
        const f = mn(d.attr("transform"));
        t.parent.select("g.cell-highlight").attr(
          "transform",
          `translate(${f.x + t.translationUnits.x}, ${f.y + t.translationUnits.y})`
        ).classed("highlighter-hidden", !1), t.services.events.dispatchEvent(x.Heatmap.HEATMAP_MOUSEOVER, {
          event: l,
          element: u,
          datum: h
        }), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
          event: l,
          items: [
            {
              label: o,
              value: h[r]
            },
            {
              label: c,
              value: h[a]
            },
            {
              label: i,
              value: h.value,
              color: u.style("fill")
            }
          ]
        });
      }
    }).on("mousemove", function(l, h) {
      t.services.events.dispatchEvent(x.Heatmap.HEATMAP_MOUSEMOVE, {
        event: l,
        element: R(this),
        datum: h
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: l
      });
    }).on("click", function(l, h) {
      t.services.events.dispatchEvent(x.Heatmap.HEATMAP_CLICK, {
        event: l,
        element: R(this),
        datum: h
      });
    }).on("mouseout", function(l, h) {
      const u = R(this).select("rect.heat"), p = u.classed("null-state");
      t.parent.select("g.cell-highlight").classed("highlighter-hidden", !0), p || (t.services.events.dispatchEvent(x.Heatmap.HEATMAP_MOUSEOUT, {
        event: l,
        element: u,
        datum: h
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        event: l,
        hoveredElement: u
      }));
    });
  }
  // Remove event listeners
  destroy() {
    this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleAxisOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
  }
}
class W0 extends ot {
  constructor() {
    super(...arguments), this.type = "histogram", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: i } = n.data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (r) => r[i] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer(), n = this.model.getOptions(), { groupIdentifier: i } = n, { groupMapsTo: r } = n.data, a = this.model.getBinnedStackedData(), o = this.services.cartesianScales.getMainXScale(), c = e.selectAll("g.bars").data(a, (h) => yt(h, `0.${r}`));
    c.exit().attr("opacity", 0).remove(), c.enter().append("g").classed("bars", !0).attr("role", it.GROUP);
    const l = e.selectAll("g.bars").selectAll("path.bar").data((h) => h);
    l.exit().remove(), l.enter().append("path").merge(l).classed("bar", !0).attr(i, (h, d) => d).transition().call(
      (h) => this.services.transitions.setupTransition({
        transition: h,
        name: "histogram-bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (h) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: h[r],
        originalClassName: "bar"
      })
    ).style("fill", (h) => this.model.getFillColor(h[r], null, h)).attr("d", (h) => {
      const d = yt(h, "data");
      if (!d)
        return;
      const u = o(d.x1) - o(d.x0) - 1, p = this.services.cartesianScales.getDomainValue(d.x0), f = p + u, g = this.services.cartesianScales.getRangeValue(h[0]);
      let m = this.services.cartesianScales.getRangeValue(h[1]);
      return Math.abs(m - g) > 0 && Math.abs(m - g) > n.bars.dividerSize && (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? m += 1 : m -= 1), $t(
        { x0: p, x1: f, y0: g, y1: m },
        this.services.cartesianScales.getOrientation()
      );
    }).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (h) => T(h, "data", h[r])), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.model.getOptions(), { groupMapsTo: e } = t.data, { code: n, number: i } = T(t, "locale"), r = this;
    this.parent.selectAll("path.bar").on("mouseover", function(a, o) {
      const c = R(this);
      c.classed("hovered", !0);
      const l = i(parseFloat(yt(o, "data.x0")), n), h = i(parseFloat(yt(o, "data.x1")), n), d = r.services.cartesianScales.getRangeAxisPosition(), u = r.services.cartesianScales.getScaleLabel(d);
      r.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: a,
        hoveredElement: c,
        items: [
          {
            label: yt(t, "bins.rangeLabel") || "Range",
            value: `${l} – ${h}`
          },
          {
            label: t.tooltip.groupLabel || "Group",
            value: o[e],
            class: r.model.getColorClassName({
              classNameTypes: [tt.TOOLTIP],
              dataGroupName: o[e]
            })
          },
          {
            label: u,
            value: yt(o, `data.${o[e]}`)
          }
        ]
      });
    }).on("mousemove", function(a) {
      r.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: a
      });
    }).on("mouseout", function() {
      R(this).classed("hovered", !1), r.services.events.dispatchEvent(x.Tooltip.HIDE);
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class X0 extends Sr {
  constructor() {
    super(...arguments), this.type = "lollipop", this.renderType = st.SVG, this.handleScatterOnHover = (t) => {
      const e = t.detail, n = this.getOptions(), { groupMapsTo: i } = n.data;
      this.parent.selectAll("line.line").attr("stroke-width", (r) => r[i] !== e.datum[i] ? ge.weight.unselected : ge.weight.selected);
    }, this.handleScatterOnMouseOut = () => {
      this.parent.selectAll("line.line").attr("stroke-width", ge.weight.unselected);
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: i } = n.data;
      this.parent.selectAll("line.line").transition("legend-hover-line").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-line"
        })
      ).attr("opacity", (r) => r[i] !== e.datum().name ? ge.opacity.unselected : ge.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("line.line").transition("legend-mouseout-line").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-line"
        })
      ).attr("opacity", ge.opacity.selected);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), n = this.model.getOptions(), { groupMapsTo: i } = n.data, { cartesianScales: r } = this.services, a = r.getMainXScale(), o = r.getMainYScale(), c = r.getDomainIdentifier(), l = (E) => r.getDomainValue(E), h = (E) => r.getRangeValue(E), d = r.getOrientation(), [u, p] = ye(
      l,
      h,
      d
    ), f = e.selectAll("line.line").data(
      this.getScatterData(),
      (E) => `${E[i]}-${E[c]}`
    );
    f.exit().attr("opacity", 0).remove();
    const m = f.enter().append("line").attr("opacity", 0).merge(f).classed("line", !0).attr(
      "class",
      (E) => this.model.getColorClassName({
        classNameTypes: [tt.STROKE],
        dataGroupName: E[i],
        originalClassName: "line"
      })
    ).transition().call(
      (E) => this.services.transitions.setupTransition({
        transition: E,
        name: "lollipop-line-update-enter",
        animate: t
      })
    ).style("stroke", (E) => this.model.getFillColor(E[i], E[c], E)).attr("opacity", 1);
    d === Ft.HORIZONTAL ? m.attr("y1", p).attr("y2", p).attr("x1", a.range()[0]).attr("x2", (E) => u(E) - n.points.radius) : m.attr("x1", u).attr("x2", u).attr("y1", o.range()[0]).attr("y2", (E) => p(E) + n.points.radius), this.addScatterPointEventListeners();
  }
  // listen for when individual datapoints are hovered
  addScatterPointEventListeners() {
    this.services.events.addEventListener(
      x.Scatter.SCATTER_MOUSEOVER,
      this.handleScatterOnHover
    ), this.services.events.addEventListener(
      x.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
  destroy() {
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut), t.removeEventListener(x.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover), t.removeEventListener(
      x.Scatter.SCATTER_MOUSEOUT,
      this.handleScatterOnMouseOut
    );
  }
}
class j0 extends ot {
  constructor() {
    super(...arguments), this.type = "meter", this.renderType = st.SVG;
  }
  getStackedBounds(t, e) {
    let n = 0;
    return t.map((r, a) => a !== 0 ? (n += e(r.value), {
      ...r,
      width: Math.abs(e(r.value) - _t.dividerWidth),
      x: n - e(r.value)
    }) : (n = e(r.value), {
      ...r,
      width: Math.abs(e(r.value) - _t.dividerWidth),
      x: 0
    }));
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer(), i = this.getOptions(), r = T(i, "meter", "proportional"), a = this.model.getDisplayData(), o = this.model.getStatus(), { width: c } = _.getSVGElementSize(n, {
      useAttrs: !0
    }), { groupMapsTo: l } = i.data;
    let h;
    if (T(i, "meter", "proportional") === null)
      h = 100;
    else {
      const v = T(i, "meter", "proportional", "total");
      h = v || this.model.getMaximumDomain(this.model.getDisplayData());
    }
    const d = ke().domain([0, h]).range([0, c]), u = this.getStackedBounds(a, d), p = T(i, "meter", "height");
    _.appendOrSelect(n, "rect.container").attr("x", 0).attr("y", 0).attr("width", c).attr(
      "height",
      p || (r ? _t.height.proportional : _t.height.default)
    ), _.appendOrSelect(n, "line.rangeIndicator").attr("x1", c).attr("x2", c).attr("y1", 0).attr(
      "y2",
      p || (r ? _t.height.proportional : _t.height.default)
    );
    const f = n.selectAll("rect.value").data(u), g = o != null && !e.model.isUserProvidedColorScaleValid() && !r ? `value status--${o}` : "value";
    f.enter().append("rect").classed("value", !0).merge(f).attr("x", (v) => v.x).attr("y", 0).attr("height", () => p || (r ? _t.height.proportional : _t.height.default)).attr(
      "class",
      (v) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: v[l],
        originalClassName: g
      })
    ).transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "meter-bar-update",
        animate: t
      })
    ).attr("width", (v) => v.value > h ? d(h) : Math.max(v.width, 2)).style("fill", (v) => e.model.getFillColor(v[l], null, v)).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", (v) => v.value), f.exit().remove();
    const m = T(i, "meter", "peak");
    let E = m;
    m !== null && (m > h ? E = h : m < a[0].value && (E = a[0].value > h ? h : a[0].value));
    const y = n.selectAll("line.peak").data(E == null ? [] : [E]);
    y.enter().append("line").classed("peak", !0).merge(y).attr("y1", 0).attr("y2", () => p || (r ? _t.height.proportional : _t.height.default)).transition().call(
      (v) => this.services.transitions.setupTransition({
        transition: v,
        name: "peak-line-update",
        animate: t
      })
    ).attr("x1", (v) => d(v)).attr("x2", (v) => d(v)).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", (v) => v), y.exit().remove(), this.services.domUtils.setSVGMaxHeight(), this.addEventListeners();
  }
  // add event listeners for tooltips on proportional meter bars
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, i = T(t, "meter", "proportional");
    this.parent.selectAll("rect.value").on("mouseover", function(r, a) {
      const o = R(this);
      n.services.events.dispatchEvent(x.Meter.METER_MOUSEOVER, {
        event: r,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !0), n.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        items: [
          {
            label: a[e],
            value: a.value
          }
        ]
      }));
    }).on("mousemove", function(r, a) {
      const o = R(this);
      n.services.events.dispatchEvent(x.Meter.METER_MOUSEMOVE, {
        event: r,
        element: o,
        datum: a
      }), i && n.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, a) {
      n.services.events.dispatchEvent(x.Meter.METER_CLICK, {
        event: r,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(r, a) {
      const o = R(this);
      n.services.events.dispatchEvent(x.Meter.METER_MOUSEOUT, {
        event: r,
        element: o,
        datum: a
      }), i && (o.classed("hovered", !1), n.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: o
      }));
    });
  }
  destroy() {
    this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
  }
}
class Y0 extends ot {
  constructor() {
    super(...arguments), this.type = "radar", this.renderType = st.SVG, this.getLabelDimensions = (t) => {
      const e = _.appendOrSelect(this.getComponentContainer(), "g.tmp-tick"), n = _.appendOrSelect(e, "text").text(t), { width: i, height: r } = _.getSVGElementSize(n.node(), { useBBox: !0 });
      return e.remove(), { width: i, height: r };
    }, this.normalizeFlatData = (t) => {
      const e = this.getOptions(), { angle: n, value: i } = T(e, "radar", "axes"), r = T(e, "data", "groupMapsTo"), a = au(
        this.uniqueKeys.map((o) => this.uniqueGroups.map((c) => ({
          [n]: o,
          [r]: c,
          [i]: null
        })))
      );
      return tn(a, t);
    }, this.normalizeGroupedData = (t) => {
      const e = this.getOptions(), { angle: n, value: i } = T(e, "radar", "axes"), r = T(e, "data", "groupMapsTo");
      return t.map(({ name: a, data: o }) => {
        const c = this.uniqueKeys.map((l) => ({
          [r]: a,
          [n]: l,
          [i]: null
        }));
        return { name: a, data: tn(c, o) };
      });
    }, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-blob"
        })
      ).style("fill-opacity", (n) => n.name !== e.datum().name ? Te.opacity.unselected : Te.opacity.selected).style("stroke-opacity", (n) => n.name !== e.datum().name ? Te.opacity.unselected : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-blob"
        })
      ).style("fill-opacity", Te.opacity.selected).style("stroke-opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer(), { width: n, height: i } = _.getSVGElementSize(e, {
      useAttrs: !0
    }), r = this.model.getData(), a = this.model.getGroupedData(), o = this.getOptions(), c = T(o, "data", "groupMapsTo"), l = T(o, "radar", "axes", "value"), { angle: h, value: d } = T(o, "radar", "axes"), { xLabelPadding: u, yLabelPadding: p, yTicksNumber: f, minRange: g, xAxisRectHeight: m } = Te;
    this.uniqueKeys = Array.from(new Set(r.map((H) => H[h]))), this.uniqueGroups = Array.from(new Set(r.map((H) => H[c]))), this.fullDataNormalized = this.normalizeFlatData(r), this.groupedDataNormalized = this.normalizeGroupedData(a);
    const y = 2 * (this.getLabelDimensions(this.uniqueKeys[0]).height + p), b = (Math.min(n, i) - y) / 2;
    if (b <= 0)
      return;
    const O = cr().domain(this.fullDataNormalized.map((H) => H[h])).range([0, 2 * Math.PI].map((H) => H - Math.PI / 2)), I = Si(this.fullDataNormalized.map((H) => H[d])), k = ke().domain([
      I >= 0 ? 0 : I,
      jr(this.fullDataNormalized.map((H) => H[d]))
    ]).range([g, b]).nice(f), G = k.ticks(f), C = (H, U, W) => this.model.getFillColor(H, U, W), L = $d().angle((H) => O(H[h]) + Math.PI / 2).radius((H) => k(H[d])).curve(ac), B = this.uniqueKeys.map((H) => {
      const U = this.getLabelDimensions(H).width, W = oc(
        O(H),
        b
      );
      return U + W;
    }), A = {
      x: jr(B) + u,
      y: i / 2
    }, V = _.appendOrSelect(e, "g.y-axes").attr("role", it.GROUP).selectAll("path").data(G, (H) => H), N = (H) => this.uniqueKeys.map((U) => ({ [h]: U, [d]: H }));
    V.join(
      (H) => H.append("path").attr("opacity", 0).attr("transform", `translate(${A.x}, ${A.y})`).attr("fill", "none").call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("d", (W) => L(N(W)))
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${A.x}, ${A.y})`).attr("d", (W) => L(N(W)))
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_axes_exit",
            animate: t
          })
        ).attr("d", (W) => L(N(W))).attr("opacity", 0).remove()
      )
    ), _.appendOrSelect(e, "g.x-axes").attr("role", it.GROUP).selectAll("line").data(this.uniqueKeys, (H) => H).join(
      (H) => H.append("line").attr("opacity", 0).attr("class", (U) => `x-axis-${He(U)}`).attr("stroke-dasharray", "0").attr("x1", (U) => bt(O(U), 0, A).x).attr("y1", (U) => bt(O(U), 0, A).y).attr("x2", (U) => bt(O(U), 0, A).x).attr("y2", (U) => bt(O(U), 0, A).y).call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_axes_enter",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (W) => bt(O(W), k.range()[0], A).x).attr("y1", (W) => bt(O(W), k.range()[0], A).y).attr("x2", (W) => bt(O(W), k.range()[1], A).x).attr("y2", (W) => bt(O(W), k.range()[1], A).y)
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_axes_update",
            animate: t
          })
        ).attr("opacity", 1).attr("x1", (W) => bt(O(W), k.range()[0], A).x).attr("y1", (W) => bt(O(W), k.range()[0], A).y).attr("x2", (W) => bt(O(W), k.range()[1], A).x).attr("y2", (W) => bt(O(W), k.range()[1], A).y)
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_axes_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), _.appendOrSelect(e, "g.x-labels").attr("role", it.GROUP).selectAll("text").data(this.uniqueKeys).join(
      (H) => H.append("text").text((U) => U).attr("opacity", 0).attr(
        "x",
        (U) => bt(O(U), k.range()[1] + u, A).x
      ).attr(
        "y",
        (U) => bt(O(U), k.range()[1] + u, A).y
      ).style("text-anchor", (U) => ea(O(U)).textAnchor).style(
        "dominant-baseline",
        (U) => ea(O(U)).dominantBaseline
      ).call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_labels_update",
            animate: t
          })
        ).attr("opacity", 1).attr(
          "x",
          (W) => bt(O(W), k.range()[1] + u, A).x
        ).attr(
          "y",
          (W) => bt(O(W), k.range()[1] + u, A).y
        ).end().finally(() => {
          const W = T(o, "radar", "alignment"), zt = this.getAlignmentXOffset(W, e, this.getParent());
          e.attr("x", zt);
        })
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_x_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), _.appendOrSelect(e, "g.blobs").attr("role", it.GROUP).selectAll("path").data(this.groupedDataNormalized, (H) => H.name).join(
      (H) => H.append("path").attr(
        "class",
        (U) => this.model.getColorClassName({
          classNameTypes: [tt.FILL, tt.STROKE],
          dataGroupName: U.name,
          originalClassName: "blob"
        })
      ).attr("role", it.GRAPHICS_SYMBOL).attr("aria-label", (U) => U.name).attr("opacity", 0).attr(
        "transform",
        t ? () => `translate(${A.x}, ${A.y}) scale(${1 + Math.random() * 0.35})` : `translate(${A.x}, ${A.y})`
      ).style("fill", (U) => C(U.name, null, U.data)).style("fill-opacity", Te.opacity.selected).style("stroke", (U) => C(U.name, null, U.data)).call((U) => {
        const W = U.transition().call(
          (zt) => this.services.transitions.setupTransition({
            transition: zt,
            name: "radar_blobs_enter",
            animate: t
          })
        );
        t && W.delay(() => Math.random() * 30).attr("transform", `translate(${A.x}, ${A.y})`), W.attr("opacity", 1).attr("d", (zt) => L(zt.data));
      }),
      (H) => (H.attr(
        "class",
        (U) => this.model.getColorClassName({
          classNameTypes: [tt.FILL, tt.STROKE],
          dataGroupName: U.name,
          originalClassName: "blob"
        })
      ).style("fill", (U) => C(U.name, null, U.data)).style("stroke", (U) => C(U.name, null, U.data)), H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_blobs_update",
            animate: t
          })
        ).attr("opacity", 1).attr("transform", `translate(${A.x}, ${A.y})`).attr("d", (W) => L(W.data))
      ), H),
      (H) => H.call((U) => {
        const W = U.transition().call(
          (zt) => this.services.transitions.setupTransition({
            transition: zt,
            name: "radar_blobs_exit",
            animate: t
          })
        );
        t && W.delay(() => Math.random() * 30).attr(
          "transform",
          () => `translate(${A.x}, ${A.y}) scale(${1 + Math.random() * 0.35})`
        ), W.attr("opacity", 0).remove();
      })
    ), _.appendOrSelect(e, "g.dots").attr("role", it.GROUP).selectAll("circle").data(this.fullDataNormalized.filter((H) => T(H, d) !== null)).join(
      (H) => H.append("circle").attr("role", it.GRAPHICS_SYMBOL).attr("aria-label", (U) => U[l]),
      (H) => H,
      (H) => H.remove()
    ).attr(
      "class",
      (H) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: H[c],
        originalClassName: He(H[h])
      })
    ).attr("cx", (H) => bt(O(H[h]), k(H[d]), A).x).attr("cy", (H) => bt(O(H[h]), k(H[d]), A).y).attr("r", 0).attr("opacity", 0).style("fill", (H) => C(H[c])), _.appendOrSelect(e, "g.x-axes-rect").attr("role", it.GROUP).selectAll("rect").data(this.uniqueKeys).join(
      (H) => H.append("rect"),
      (H) => H,
      (H) => H.remove()
    ).attr("x", A.x).attr("y", A.y - m / 2).attr("width", k.range()[1]).attr("height", m).style("fill", "red").style("fill-opacity", 0).attr("transform", (H) => `rotate(${lc(O(H))}, ${A.x}, ${A.y})`);
    const { code: ut, number: ht } = T(o, "locale");
    _.appendOrSelect(e, "g.y-labels").attr("role", it.GROUP).selectAll("text").data(ks(G)).join(
      (H) => H.append("text").attr("opacity", 0).text((U) => ht(U, ut)).attr(
        "x",
        (U) => bt(-Math.PI / 2, k(U), A).x + p
      ).attr("y", (U) => bt(-Math.PI / 2, k(U), A).y).style("text-anchor", "start").style("dominant-baseline", "middle").call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_labels_enter",
            animate: t
          })
        ).attr("opacity", 1)
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_labels_update",
            animate: t
          })
        ).text((W) => W).attr("opacity", 1).attr(
          "x",
          (W) => bt(-Math.PI / 2, k(W), A).x + p
        ).attr("y", (W) => bt(-Math.PI / 2, k(W), A).y)
      ),
      (H) => H.call(
        (U) => U.transition().call(
          (W) => this.services.transitions.setupTransition({
            transition: W,
            name: "radar_y_labels_exit",
            animate: t
          })
        ).attr("opacity", 0).remove()
      )
    ), this.addEventListeners();
  }
  getAlignmentXOffset(t, e, n) {
    const i = _.getSVGElementSize(e, {
      useBBox: !0
    }), { width: r } = _.getSVGElementSize(n, {
      useAttrs: !0
    });
    let a = 0;
    return t === Jt.CENTER ? a = Math.floor((r - i.width) / 2) : t === Jt.RIGHT && (a = r - i.width), a;
  }
  destroy() {
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  addEventListeners() {
    const t = this, {
      axes: { angle: e }
    } = T(this.getOptions(), "radar");
    this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(n, i) {
      const r = R(this);
      t.services.events.dispatchEvent(x.Radar.X_AXIS_MOUSEOVER, {
        event: n,
        element: r,
        datum: i
      });
      const a = t.parent.select(`.x-axes .x-axis-${He(i)}`), o = t.parent.selectAll(`.dots circle.${He(i)}`), c = t.model.getActiveDataGroupNames(), l = t.getOptions(), { groupMapsTo: h } = l.data, d = T(l, "radar", "axes", "value");
      a.classed("hovered", !0).attr("stroke-dasharray", "4 4"), o.classed("hovered", !0).attr(
        "opacity",
        (p) => c.indexOf(p[h]) !== -1 ? 1 : 0
      ).attr("r", Te.dotsRadius);
      const u = t.fullDataNormalized.filter(
        (p) => p[e] === i && c.indexOf(p[h]) !== -1
      );
      t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: n,
        hoveredElement: r,
        items: u.filter((p) => typeof p[d] == "number").map((p) => ({
          label: p[h],
          value: p[d],
          color: t.model.getFillColor(p[h], null, p),
          class: t.model.getColorClassName({
            classNameTypes: [tt.TOOLTIP],
            dataGroupName: p[h]
          })
        }))
      });
    }).on("mousemove", function(n, i) {
      const r = R(this);
      t.services.events.dispatchEvent(x.Radar.X_AXIS_MOUSEMOVE, {
        event: n,
        element: r,
        datum: i
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: n
      });
    }).on("click", function(n, i) {
      t.services.events.dispatchEvent(x.Radar.X_AXIS_CLICK, {
        event: n,
        element: R(this),
        datum: i
      });
    }).on("mouseout", function(n, i) {
      const r = R(this), a = t.parent.select(`.x-axes .x-axis-${He(i)}`), o = t.parent.selectAll(`.dots circle.${He(i)}`);
      a.classed("hovered", !1).attr("stroke-dasharray", "0"), o.classed("hovered", !1).attr("opacity", 0).attr("r", 0), t.services.events.dispatchEvent(x.Radar.X_AXIS_MOUSEOUT, {
        event: n,
        element: r,
        datum: i
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE);
    });
  }
}
class q0 extends br {
  constructor() {
    super(...arguments), this.type = "simple-bar", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-simple-bar"
        })
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-simple-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getOptions(), { groupMapsTo: n } = e.data, i = this.getComponentContainer({ withinChartClip: !0 }), r = this.model.getDisplayData(this.configs.groups), a = this.services.cartesianScales.getOrientation(), o = i.selectAll("path.bar").data(r, (l) => l[n]);
    o.exit().attr("opacity", 0).remove(), o.enter().append("path").attr("opacity", 0).merge(o).classed("bar", !0).attr("width", this.getBarWidth.bind(this)).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: l[n],
        originalClassName: "bar"
      })
    ).style("fill", (l) => {
      const h = this.services.cartesianScales.getDomainIdentifier(l);
      return this.model.getFillColor(l[n], l[h], l);
    }).attr("d", (l) => {
      const h = this.services.cartesianScales.getRangeIdentifier(), d = this.getBarWidth(), u = l[h], p = this.services.cartesianScales.getDomainValue(l) - d / 2, f = p + d;
      let g, m;
      if (Array.isArray(u) && u.length === 2)
        g = this.services.cartesianScales.getRangeValue(u[0]), m = this.services.cartesianScales.getRangeValue(u[1]);
      else {
        const v = this.services.cartesianScales.getRangeScale().domain()[0];
        g = this.services.cartesianScales.getRangeValue(Math.max(0, v)), m = this.services.cartesianScales.getRangeValue(l);
      }
      const E = Math.abs(m - g);
      if (E !== 0 && E < 2 && (u > 0 && a === Ft.VERTICAL || u < 0 && a === Ft.HORIZONTAL ? m = g - 2 : m = g + 2), !this.isOutsideZoomedDomain(p, f))
        return $t({ x0: p, x1: f, y0: g, y1: m }, a);
    }).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l.value), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("path.bar").on("mouseover", function(e, n) {
      const i = R(this);
      i.classed("hovered", !0), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOVER, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: e,
        hoveredElement: i,
        data: [n]
      });
    }).on("mousemove", function(e, n) {
      t.services.events.dispatchEvent(x.Bar.BAR_MOUSEMOVE, {
        event: e,
        element: R(this),
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(x.Bar.BAR_CLICK, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      i.classed("hovered", !1), t.services.events.dispatchEvent(x.Bar.BAR_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Z0 extends Jf {
  constructor() {
    super(...arguments), this.type = "skeleton-lines";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = T(this.getOptions(), "data", "loading"), n = !T(this.getOptions(), "grid", "x", "enabled") && !T(this.getOptions(), "grid", "y", "enabled") && !T(this.getOptions(), "axes", "bottom", "visible") && !T(this.getOptions(), "axes", "left", "visible");
    e && !n ? super.renderGridSkeleton(e) : e && n ? this.renderSparklineSkeleton(e) : this.removeSkeleton();
  }
  renderSparklineSkeleton(t) {
    this.setScales(), this.drawBackdrop(t), this.drawSparkline(t), this.updateBackdropStyle(), t && this.setShimmerEffect("shimmer-lines");
  }
  drawSparkline(t) {
    const e = this.backdrop.attr("width"), n = [100], i = _.appendOrSelect(this.backdrop, "g.y.skeleton"), r = i.selectAll("line").data(n);
    r.enter().append("line").merge(r).attr("x1", 0).attr("x2", e).attr("y1", (a) => a).attr("y2", (a) => a), i.selectAll("line").classed("shimmer-effect-lines", t).classed("empty-state-lines", !t).style(
      "stroke",
      t ? `url(#${this.services.domUtils.generateElementIDString("shimmer-lines")})` : null
    );
  }
  updateBackdropStyle() {
    const t = this.parent;
    this.backdrop = _.appendOrSelect(t, "svg.chart-skeleton.DAII"), _.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop").classed("shimmer-effect-lines", !1).classed("shimmer-effect-sparkline", !0).style("stroke", null);
  }
}
class K0 extends ot {
  constructor() {
    super(...arguments), this.type = "area-stacked", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, n = this.getOptions(), { groupMapsTo: i } = n.data;
      this.parent.selectAll("path.area").transition("legend-hover-area").call(
        (r) => this.services.transitions.setupTransition({
          transition: r,
          name: "legend-hover-area"
        })
      ).attr("opacity", (r) => T(r, 0, i) !== e.datum().name ? me.opacity.unselected : me.opacity.selected);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.area").transition("legend-mouseout-area").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-area"
        })
      ).attr("opacity", me.opacity.selected);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), n = this, i = this.getOptions(), { groupMapsTo: r } = i.data, a = Object.keys(i.axes).some((f) => i.axes[f].percentage), o = this.model.getStackedData({
      percentage: a,
      groups: this.configs.groups
    }), c = T(o, 0, 0), l = this.services.cartesianScales.getDomainAxisPosition({ datum: c }), h = this.services.cartesianScales.getRangeAxisPosition({ datum: c }), d = this.services.cartesianScales.getScaleByPosition(h), u = e.selectAll("path.area").data(o, (f) => T(f, 0, r));
    this.areaGenerator = yr().x(
      (f) => this.services.cartesianScales.getValueThroughAxisPosition(
        l,
        f.data.sharedStackKey
      )
    ).y0((f) => d(f[0])).y1((f) => d(f[1])).curve(this.services.curves.getD3Curve()), u.exit().attr("opacity", 0).remove(), u.enter().append("path").attr("opacity", 0).merge(u).data(o, (f) => T(f, 0, r)).attr("class", "area").attr(
      "class",
      (f) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: T(f, 0, r),
        originalClassName: "area"
      })
    ).style("fill", (f) => n.model.getFillColor(T(f, 0, r), null, f)).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", (f) => T(f, 0, r)).transition().call(
      (f) => this.services.transitions.setupTransition({
        transition: f,
        name: "area-update-enter",
        animate: t
      })
    ).attr("opacity", me.opacity.selected).attr("d", this.areaGenerator);
  }
}
class J0 extends br {
  constructor() {
    super(...arguments), this.type = "stacked-bar", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.model.getOptions().data;
      this.parent.selectAll("path.bar").transition("legend-hover-bar").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-bar"
        })
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-bar"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t) {
    const e = this.getComponentContainer({ withinChartClip: !0 }), n = this.getOptions(), { groupMapsTo: i } = n.data, r = this.model.getStackedData({
      groups: this.configs.groups,
      divergent: !0
    }), a = this.model.getActiveDataGroupNames(), o = e.selectAll("g.bars").data(r, (l) => T(l, 0, i));
    o.exit().attr("opacity", 0).remove(), o.enter().append("g").classed("bars", !0).attr("role", it.GROUP).attr("data-name", "bars");
    const c = e.selectAll("g.bars").selectAll("path.bar").data(
      (l) => l,
      (l) => l.data.sharedStackKey
    );
    c.exit().remove(), c.enter().append("path").merge(c).classed("bar", !0).transition().call(
      (l) => this.services.transitions.setupTransition({
        transition: l,
        name: "bar-update-enter",
        animate: t
      })
    ).attr(
      "class",
      (l) => this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: l[i],
        originalClassName: "bar"
      })
    ).style(
      "fill",
      (l) => this.model.getFillColor(l[i], l.data.sharedStackKey, l.data)
    ).attr("d", (l) => {
      const h = l.data.sharedStackKey, d = this.getBarWidth(), u = this.services.cartesianScales.getDomainValue(h) - d / 2, p = u + d, f = this.services.cartesianScales.getRangeValue(l[0]);
      let g = this.services.cartesianScales.getRangeValue(l[1]);
      if (!this.isOutsideZoomedDomain(u, p)) {
        if (Math.abs(g - f) > 0 && Math.abs(g - f) > n.bars.dividerSize) {
          const m = l[0] < 0 && l[1] <= 0;
          m && a.length > 1 ? this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += l[1] === 0 ? 2 : 1 : g -= 1 : m || (this.services.cartesianScales.getOrientation() === Ft.VERTICAL ? g += 1 : g -= 1);
        }
        return $t(
          { x0: u, x1: p, y0: f, y1: g },
          this.services.cartesianScales.getOrientation()
        );
      }
    }).attr("opacity", 1).attr("role", it.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", (l) => l[1] - l[0]), this.addEventListeners();
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this;
    this.parent.selectAll("path.bar").on("mouseover", function(i, r) {
      const a = R(this);
      a.classed("hovered", !0), n.services.events.dispatchEvent(x.Bar.BAR_MOUSEOVER, {
        event: i,
        element: a,
        datum: r
      });
      let c = n.model.getDisplayData(n.configs.groups).find((l) => {
        const h = n.services.cartesianScales.getDomainIdentifier(l), d = n.services.cartesianScales.getRangeIdentifier(l);
        return l[d] === r.data[r[e]] && l[h].toString() === r.data.sharedStackKey && l[e] === r[e];
      });
      if (c === void 0) {
        const l = n.services.cartesianScales.getDomainIdentifier(), h = n.services.cartesianScales.getRangeIdentifier();
        c = {
          [l]: r.data.sharedStackKey,
          [h]: r.data[r[e]],
          [e]: r[e]
        };
      }
      n.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: i,
        hoveredElement: a,
        data: [c]
      });
    }).on("mousemove", function(i, r) {
      const a = R(this);
      n.services.events.dispatchEvent(x.Bar.BAR_MOUSEMOVE, {
        event: i,
        element: a,
        datum: r
      }), n.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: i
      });
    }).on("click", function(i, r) {
      n.services.events.dispatchEvent(x.Bar.BAR_CLICK, {
        event: i,
        element: R(this),
        datum: r
      });
    }).on("mouseout", function(i, r) {
      const a = R(this);
      a.classed("hovered", !1), n.services.events.dispatchEvent(x.Bar.BAR_MOUSEOUT, {
        event: i,
        element: a,
        datum: r
      }), n.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: a
      });
    });
  }
  getBarWidth() {
    const t = this.getOptions();
    if (T(t, "bars", "width"))
      return t.bars.width;
    const e = this.services.cartesianScales.getMainXScale(), n = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    }).width, i = this.model.getStackKeys().length, r = T(t, "bars", "spacingFactor");
    return e.step ? Math.min(t.bars.maxWidth, e.step() / 2) : Math.min(t.bars.maxWidth, n * r / i);
  }
  destroy() {
    this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
    const t = this.services.events;
    t.removeEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.removeEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
}
class Q0 extends Sr {
  constructor() {
    super(...arguments), this.type = "scatter-stacked", this.renderType = st.SVG;
  }
  render(t) {
    if (!T(this.getOptions(), "points", "enabled"))
      return;
    const n = this.getComponentContainer({ withinChartClip: !0 }), i = this.getOptions(), { groupMapsTo: r } = i.data, a = Object.keys(i.axes).some((p) => i.axes[p].percentage), o = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: a
    }), c = n.selectAll("g.dots").data(o, (p) => T(p, 0, r));
    c.exit().attr("opacity", 0).remove();
    const h = c.enter().append("g").classed("dots", !0).attr("role", it.GROUP).merge(c).selectAll("circle.dot").data((p) => p);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("circle").classed("dot", !0).attr("opacity", 0).merge(h).datum((p) => {
      const f = p[r], g = this.services.cartesianScales.getDomainIdentifier(p), m = this.services.cartesianScales.getRangeIdentifier(p);
      return {
        [r]: f,
        [g]: p.data.sharedStackKey,
        [m]: p[1]
      };
    });
    this.styleCircles(u, t), this.addEventListeners();
  }
  getTooltipData(t, e) {
    const n = this.getOptions(), { groupMapsTo: i } = n.data, r = Object.keys(n.axes).some((c) => n.axes[c].percentage), a = this.model.getStackedData({
      groups: this.configs.groups,
      percentage: r
    }), o = [];
    return a.forEach((c, l) => {
      c.forEach((h, d) => {
        const u = h[i], p = h.data.sharedStackKey;
        let f = h.data[u];
        const g = h[1], m = this.services.cartesianScales.getDomainIdentifier(h), E = this.services.cartesianScales.getRangeIdentifier(h);
        f != null && t === this.services.cartesianScales.getDomainValue(p) && e === this.services.cartesianScales.getRangeValue(g) && (r && (f = this.model.getStackedData({
          groups: this.configs.groups
        })[l][d].data[u]), f !== null && o.push({
          [i]: u,
          [m]: p,
          [E]: f
        }));
      });
    }), this.model.getDisplayData(this.configs.groups).filter((c) => {
      const l = this.services.cartesianScales.getDomainIdentifier(c), h = this.services.cartesianScales.getRangeIdentifier(c);
      return o.find((d) => d[i] == c[i] && d[l] == c[l] && d[h] == c[h]) !== void 0;
    });
  }
}
const We = 6;
class ty extends ot {
  constructor() {
    super(...arguments), this.type = "tree", this.renderType = st.SVG;
  }
  getLongestLabel(t) {
    let e = "";
    return t.forEach((n) => {
      const i = n.children ? this.getLongestLabel(n.children) : "";
      (i.length > e.length || n.name.length > e.length) && (e = i.length > n.name.length ? i : n.name);
    }), e;
  }
  getMockLabelWidth(t, e) {
    const n = t.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(e), { width: i } = _.getSVGElementSize(n.node(), {
      useBBox: !0
    });
    return n.remove(), i;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    const e = this.getComponentContainer();
    e.html("");
    const { width: n, height: i } = _.getSVGElementSize(this.parent, {
      useAttrs: !0
    });
    if (n < 1 || i < 1)
      return;
    const r = this.model.getOptions(), a = this.model.getDisplayData(), o = T(r, "tree", "rootTitle") || "Tree", c = this.getMockLabelWidth(e, o), l = this.getLongestLabel(a), h = this.getMockLabelWidth(e, l), d = {
      top: 0,
      right: 0,
      bottom: 0,
      left: c > 0 ? c + We : 30 - We
    }, u = Pn({
      name: o,
      children: a
    }), p = 10, f = n / 6, g = (O) => {
      const I = u.descendants().reverse(), k = u.links();
      let G = u, C = u;
      u.eachBefore((P) => {
        P.x < G.x && (G = P), P.x > C.x && (C = P);
      });
      const L = C.x - G.x, B = e.transition().call(
        (P) => this.services.transitions.setupTransition({
          transition: P,
          name: "tree-update-viewbox",
          animate: !0
        })
      ).attr("viewBox", [-d.left, G.x, n, L].join(" ")), D = b.selectAll("g").data(I, (P) => P.id), A = this, w = D.enter().append("g").attr("transform", () => `translate(${O.y0},${O.x0})`).attr(
        "class",
        (P) => P.depth !== 0 && P.children && P.children.length > 0 ? "clickable" : null
      ).on("mouseover", function(P, $) {
        A.services.events.dispatchEvent(x.Tree.NODE_MOUSEOVER, {
          event: P,
          element: R(this),
          datum: $
        });
      }).on("click", function(P, $) {
        $.depth !== 0 && ($.children = $.children ? null : $._children, g($)), A.services.events.dispatchEvent(x.Tree.NODE_CLICK, {
          event: P,
          element: R(this),
          datum: $
        });
      }).on("mouseout", function(P, $) {
        A.services.events.dispatchEvent(x.Tree.NODE_MOUSEOUT, {
          event: P,
          element: R(this),
          datum: $
        });
      });
      w.append("circle").attr("r", 2.5).attr("class", (P) => P._children ? "parent" : "child").attr("stroke-width", 10), w.append("text").attr("dy", "0.31em").attr("x", (P) => P._children ? -We : We).attr("text-anchor", (P) => P._children ? "end" : "start").text((P) => P.data.name).clone(!0).attr("class", "text-stroke").lower(), D.merge(w).transition(B).attr("transform", (P) => `translate(${P.y},${P.x})`).attr("fill-opacity", 1).attr("stroke-opacity", 1), D.exit().transition(B).remove().attr("transform", () => `translate(${O.y},${O.x})`).attr("fill-opacity", 0).attr("stroke-opacity", 0);
      const V = S.selectAll("path").data(k, (P) => P.target.id), N = V.enter().append("path").attr("d", () => {
        const P = { x: O.x0, y: O.y0 };
        return v({ source: P, target: P });
      });
      V.merge(N).transition(B).attr("d", v), V.exit().transition(B).remove().attr("d", () => {
        const P = { x: O.x, y: O.y };
        return v({ source: P, target: P });
      }), u.eachBefore((P) => {
        P.x0 = P.x, P.y0 = P.y;
      });
    }, m = u.descendants(), E = m[m.length - 1].depth, y = T(r, "tree", "type") === nc.DENDROGRAM ? Ih().size([
      i,
      n - h - E * We - c
    ]) : Sd().nodeSize([p, f]).size([
      i,
      n - h - E * We - c
    ]), v = zd().x((O) => O.y).y((O) => O.x);
    u.x0 = f / 2, u.y0 = 0, u.descendants().forEach((O, I) => {
      O.id = I, O._children = O.children;
    }), y(u), e.attr("viewBox", [-d.left, -d.top, n, p]).style("user-select", "none");
    const S = e.append("g").attr("class", "links"), b = e.append("g").attr("class", "nodes");
    g(u);
  }
}
var cg = "#000000", ug = "#ffffff", hg = "#fcf4d6", dg = "#fddc69", pg = "#f1c21b", fg = "#d2a106", gg = "#b28600", mg = "#8e6a00", vg = "#684e00", yg = "#483700", Eg = "#302400", Sg = "#1c1500", xg = {
  10: hg,
  20: dg,
  30: pg,
  40: fg,
  50: gg,
  60: mg,
  70: vg,
  80: yg,
  90: Eg,
  100: Sg
}, bg = "#fff2e8", Tg = "#ffd9be", Og = "#ffb784", wg = "#ff832b", Lg = "#eb6200", Ag = "#ba4e00", Mg = "#8a3800", _g = "#5e2900", Cg = "#3e1a00", kg = "#231000", Rg = {
  10: bg,
  20: Tg,
  30: Og,
  40: wg,
  50: Lg,
  60: Ag,
  70: Mg,
  80: _g,
  90: Cg,
  100: kg
}, Ig = "#fff1f1", Dg = "#ffd7d9", Pg = "#ffb3b8", Ng = "#ff8389", $g = "#fa4d56", Vg = "#da1e28", Bg = "#a2191f", Gg = "#750e13", Hg = "#520408", Ug = "#2d0709", zg = {
  10: Ig,
  20: Dg,
  30: Pg,
  40: Ng,
  50: $g,
  60: Vg,
  70: Bg,
  80: Gg,
  90: Hg,
  100: Ug
}, Fg = "#fff0f7", Wg = "#ffd6e8", Xg = "#ffafd2", jg = "#ff7eb6", Yg = "#ee5396", qg = "#d02670", Zg = "#9f1853", Kg = "#740937", Jg = "#510224", Qg = "#2a0a18", tm = {
  10: Fg,
  20: Wg,
  30: Xg,
  40: jg,
  50: Yg,
  60: qg,
  70: Zg,
  80: Kg,
  90: Jg,
  100: Qg
}, em = "#f6f2ff", nm = "#e8daff", sm = "#d4bbff", im = "#be95ff", rm = "#a56eff", am = "#8a3ffc", om = "#6929c4", lm = "#491d8b", cm = "#31135e", um = "#1c0f30", hm = {
  10: em,
  20: nm,
  30: sm,
  40: im,
  50: rm,
  60: am,
  70: om,
  80: lm,
  90: cm,
  100: um
}, dm = "#edf5ff", pm = "#d0e2ff", fm = "#a6c8ff", gm = "#78a9ff", mm = "#4589ff", vm = "#0f62fe", ym = "#0043ce", Em = "#002d9c", Sm = "#001d6c", xm = "#001141", bm = {
  10: dm,
  20: pm,
  30: fm,
  40: gm,
  50: mm,
  60: vm,
  70: ym,
  80: Em,
  90: Sm,
  100: xm
}, Tm = "#e5f6ff", Om = "#bae6ff", wm = "#82cfff", Lm = "#33b1ff", Am = "#1192e8", Mm = "#0072c3", _m = "#00539a", Cm = "#003a6d", km = "#012749", Rm = "#061727", Im = {
  10: Tm,
  20: Om,
  30: wm,
  40: Lm,
  50: Am,
  60: Mm,
  70: _m,
  80: Cm,
  90: km,
  100: Rm
}, Dm = "#d9fbfb", Pm = "#9ef0f0", Nm = "#3ddbd9", $m = "#08bdba", Vm = "#009d9a", Bm = "#007d79", Gm = "#005d5d", Hm = "#004144", Um = "#022b30", zm = "#081a1c", Fm = {
  10: Dm,
  20: Pm,
  30: Nm,
  40: $m,
  50: Vm,
  60: Bm,
  70: Gm,
  80: Hm,
  90: Um,
  100: zm
}, Wm = "#defbe6", Xm = "#a7f0ba", jm = "#6fdc8c", Ym = "#42be65", qm = "#24a148", Zm = "#198038", Km = "#0e6027", Jm = "#044317", Qm = "#022d0d", tv = "#071908", ev = {
  10: Wm,
  20: Xm,
  30: jm,
  40: Ym,
  50: qm,
  60: Zm,
  70: Km,
  80: Jm,
  90: Qm,
  100: tv
}, nv = "#f2f4f8", sv = "#dde1e6", iv = "#c1c7cd", rv = "#a2a9b0", av = "#878d96", ov = "#697077", lv = "#4d5358", cv = "#343a3f", uv = "#21272a", hv = "#121619", dv = {
  10: nv,
  20: sv,
  30: iv,
  40: rv,
  50: av,
  60: ov,
  70: lv,
  80: cv,
  90: uv,
  100: hv
}, pv = "#f4f4f4", fv = "#e0e0e0", gv = "#c6c6c6", mv = "#a8a8a8", vv = "#8d8d8d", yv = "#6f6f6f", Ev = "#525252", Sv = "#393939", xv = "#262626", bv = "#161616", Tv = {
  10: pv,
  20: fv,
  30: gv,
  40: mv,
  50: vv,
  60: yv,
  70: Ev,
  80: Sv,
  90: xv,
  100: bv
}, Ov = "#f7f3f2", wv = "#e5e0df", Lv = "#cac5c4", Av = "#ada8a8", Mv = "#8f8b8b", _v = "#726e6e", Cv = "#565151", kv = "#3c3838", Rv = "#272525", Iv = "#171414", Dv = {
  10: Ov,
  20: wv,
  30: Lv,
  40: Av,
  50: Mv,
  60: _v,
  70: Cv,
  80: kv,
  90: Rv,
  100: Iv
}, uo = {
  black: {
    100: cg
  },
  blue: bm,
  coolGray: dv,
  cyan: Im,
  gray: Tv,
  green: ev,
  magenta: tm,
  orange: Rg,
  purple: hm,
  red: zg,
  teal: Fm,
  warmGray: Dv,
  white: {
    0: ug
  },
  yellow: xg
};
const Pv = (s) => {
  if (!s)
    return null;
  for (const t of Object.keys(uo)) {
    const e = uo[t];
    for (const n of Object.keys(e))
      if (e[+n] === s)
        return n;
  }
  return null;
}, ho = function() {
  const s = R(this.parentNode).select("rect.leaf"), t = getComputedStyle(s.node(), null).getPropertyValue(
    "fill"
  ), e = bo(t);
  let n;
  if (e && (n = Pv(e ? e.hex() : null)), n == null) {
    const i = xo(e).l;
    n = Math.abs(i * 100 - 100);
  }
  return n > 50 ? "white" : "black";
};
let Nv = 0;
class ey extends ot {
  constructor() {
    super(...arguments), this.type = "treemap", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail;
      this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(
        (n) => this.services.transitions.setupTransition({
          transition: n,
          name: "legend-hover-treemap"
        })
      ).attr(
        "opacity",
        (n) => n.parent.data.name === e.datum().name ? 1 : 0.3
      );
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-treemap"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const { events: t } = this.services;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this.getComponentContainer();
    this.model.getData();
    const n = this.model.getDisplayData(), i = this.model.getOptions(), r = T(window, "location"), { width: a, height: o } = _.getSVGElementSize(e, {
      useAttrs: !0
    }), c = Pn({
      name: i.title || "Treemap",
      children: n
    }).sum((g) => g.value).sort((g, m) => m.value - g.value), l = wd().size([a, o]).paddingInner(1).paddingOuter(0).round(!0)(
      c
    ), h = e.selectAll("g[data-name='leaf']").data(l.leaves(), (g) => g.data.name);
    h.exit().attr("opacity", 0).remove();
    const u = h.enter().append("g").attr("data-name", "leaf").attr("data-uid", () => Nv++).merge(h);
    u.attr("data-name", "leaf").transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "treemap-group-update",
        animate: t
      })
    ).attr("transform", (g) => `translate(${g.x0},${g.y0})`);
    const p = u.selectAll("rect.leaf").data((g) => [g]);
    p.exit().attr("width", 0).attr("height", 0).remove(), p.enter().append("rect").classed("leaf", !0).merge(p).attr("width", 0).attr("height", 0).attr("id", function() {
      const g = R(this.parentNode).attr("data-uid");
      return `${i.style.prefix}-leaf-${g}`;
    }).attr("class", (g) => {
      for (; g.depth > 1; ) g = g.parent;
      return this.model.getColorClassName({
        classNameTypes: [tt.FILL],
        dataGroupName: g.data.name,
        originalClassName: "leaf"
      });
    }).transition().call(
      (g) => this.services.transitions.setupTransition({
        transition: g,
        name: "treemap-leaf-update-enter",
        animate: t
      })
    ).attr("width", (g) => g.x1 - g.x0).attr("height", (g) => g.y1 - g.y0).style("fill", (g) => {
      for (; g.depth > 1; ) g = g.parent;
      return this.model.getFillColor(g.data.name, null, g.data);
    }), u.selectAll("clipPath").data(
      (g) => g.data.showLabel !== !0 ? [] : [1],
      (g) => g
    ).join(
      (g) => g.append("clipPath").attr("id", function() {
        const m = R(this.parentNode).attr("data-uid");
        return `${i.style.prefix}-clip-${m}`;
      }).append("use").attr("xlink:href", function() {
        const m = R(this.parentNode.parentNode).attr("data-uid"), E = `${i.style.prefix}-leaf-${m}`;
        return new URL(`#${E}`, r) + "";
      }),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (g) => null,
      (g) => g.remove()
    ), u.selectAll("text").data(
      (g) => {
        if (g.data.showLabel !== !0)
          return [];
        let m = g;
        for (; m.depth > 1; ) m = m.parent;
        const E = xo(this.model.getFillColor(m.data.name));
        return [
          {
            text: g.data.name,
            color: E.l < 0.5 ? "white" : "black"
          }
        ];
      },
      (g) => g
    ).join(
      (g) => {
        const m = g.append("text").text((E) => E.text).style("fill", ho).attr("x", 7).attr("y", 18);
        return r && m.attr("clip-path", function() {
          const E = R(this.parentNode).attr("data-uid"), y = `${i.style.prefix}-clip-${E}`;
          return `url(${new URL(`#${y}`, r) + ""})`;
        }), m;
      },
      (g) => g.text((m) => m.text).style("fill", ho),
      (g) => g.remove()
    ), this.addEventListeners();
  }
  addEventListeners() {
    const t = this;
    this.parent.selectAll("rect.leaf").on("mouseover", function(e, n) {
      const i = R(this);
      let r = getComputedStyle(this, null).getPropertyValue("fill"), a = n;
      for (; a.depth > 1; ) a = a.parent;
      i.transition("graph_element_mouseover_fill_update").call(
        (o) => t.services.transitions.setupTransition({
          transition: o,
          name: "graph_element_mouseover_fill_update"
        })
      ).style("fill", (o) => {
        const c = t.model.getFillColor(o.parent.data.name, null, o.data);
        return c && (r = c), bo(r).darker(0.7).toString();
      }), t.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: e,
        hoveredElement: i,
        items: [
          {
            color: r,
            label: a.data.name,
            bold: !0
          },
          {
            label: n.data.name,
            value: n.data.value
          }
        ]
      }), t.services.events.dispatchEvent(x.Treemap.LEAF_MOUSEOVER, {
        event: e,
        element: i,
        datum: n
      });
    }).on("mousemove", function(e, n) {
      const i = R(this);
      t.services.events.dispatchEvent(x.Treemap.LEAF_MOUSEMOVE, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: e
      });
    }).on("click", function(e, n) {
      t.services.events.dispatchEvent(x.Treemap.LEAF_CLICK, {
        event: e,
        element: R(this),
        datum: n
      });
    }).on("mouseout", function(e, n) {
      const i = R(this);
      i.classed("hovered", !1);
      let r = n;
      for (; r.depth > 1; ) r = r.parent;
      i.transition().call(
        (a) => t.services.transitions.setupTransition({
          transition: a,
          name: "graph_element_mouseout_fill_update"
        })
      ).style("fill", (a) => t.model.getFillColor(a.parent.data.name, null, a.data)), t.services.events.dispatchEvent(x.Treemap.LEAF_MOUSEOUT, {
        event: e,
        element: i,
        datum: n
      }), t.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: i
      });
    });
  }
}
var $v = { value: function() {
} };
function Cl() {
  for (var s = 0, t = arguments.length, e = {}, n; s < t; ++s) {
    if (!(n = arguments[s] + "") || n in e || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    e[n] = [];
  }
  return new us(e);
}
function us(s) {
  this._ = s;
}
function Vv(s, t) {
  return s.trim().split(/^|\s+/).map(function(e) {
    var n = "", i = e.indexOf(".");
    if (i >= 0 && (n = e.slice(i + 1), e = e.slice(0, i)), e && !t.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    return { type: e, name: n };
  });
}
us.prototype = Cl.prototype = {
  constructor: us,
  on: function(s, t) {
    var e = this._, n = Vv(s + "", e), i, r = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++r < a; ) if ((i = (s = n[r]).type) && (i = Bv(e[i], s.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++r < a; )
      if (i = (s = n[r]).type) e[i] = po(e[i], s.name, t);
      else if (t == null) for (i in e) e[i] = po(e[i], s.name, null);
    return this;
  },
  copy: function() {
    var s = {}, t = this._;
    for (var e in t) s[e] = t[e].slice();
    return new us(s);
  },
  call: function(s, t) {
    if ((i = arguments.length - 2) > 0) for (var e = new Array(i), n = 0, i, r; n < i; ++n) e[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(s)) throw new Error("unknown type: " + s);
    for (r = this._[s], n = 0, i = r.length; n < i; ++n) r[n].value.apply(t, e);
  },
  apply: function(s, t, e) {
    if (!this._.hasOwnProperty(s)) throw new Error("unknown type: " + s);
    for (var n = this._[s], i = 0, r = n.length; i < r; ++i) n[i].value.apply(t, e);
  }
};
function Bv(s, t) {
  for (var e = 0, n = s.length, i; e < n; ++e)
    if ((i = s[e]).name === t)
      return i.value;
}
function po(s, t, e) {
  for (var n = 0, i = s.length; n < i; ++n)
    if (s[n].name === t) {
      s[n] = $v, s = s.slice(0, n).concat(s.slice(n + 1));
      break;
    }
  return e != null && s.push({ name: t, value: e }), s;
}
const Gv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispatch: Cl
}, Symbol.toStringTag, { value: "Module" })), Hv = /* @__PURE__ */ of(Gv), Uv = Hv.dispatch, vi = Math.PI / 180, zv = {
  archimedean: kl,
  rectangular: t0
}, wn = 64, hs = 2048;
var Fv = function() {
  var s = [256, 256], t = Wv, e = Xv, n = jv, i = fo, r = fo, a = Yv, o = qv, c = kl, l = [], h = 1 / 0, d = Uv("word", "end"), u = null, p = Math.random, f = {}, g = n0;
  f.canvas = function(y) {
    return arguments.length ? (g = xe(y), f) : g;
  }, f.start = function() {
    var y = m(g()), v = e0((s[0] >> 5) * s[1]), S = null, b = l.length, O = -1, I = [], k = l.map(function(C, L) {
      return C.text = t.call(this, C, L), C.font = e.call(this, C, L), C.style = i.call(this, C, L), C.weight = r.call(this, C, L), C.rotate = a.call(this, C, L), C.size = ~~n.call(this, C, L), C.padding = o.call(this, C, L), C;
    }).sort(function(C, L) {
      return L.size - C.size;
    });
    return u && clearInterval(u), u = setInterval(G, 0), G(), f;
    function G() {
      for (var C = Date.now(); Date.now() - C < h && ++O < b && u; ) {
        var L = k[O];
        L.x = s[0] * (p() + 0.5) >> 1, L.y = s[1] * (p() + 0.5) >> 1, Zv(y, L, k, O), L.hasText && E(v, L, S) && (I.push(L), d.call("word", f, L), S ? Jv(S, L) : S = [{ x: L.x + L.x0, y: L.y + L.y0 }, { x: L.x + L.x1, y: L.y + L.y1 }], L.x -= s[0] >> 1, L.y -= s[1] >> 1);
      }
      O >= b && (f.stop(), d.call("end", f, I, S));
    }
  }, f.stop = function() {
    u && (clearInterval(u), u = null);
    for (const y of l)
      delete y.sprite;
    return f;
  };
  function m(y) {
    const v = y.getContext("2d", { willReadFrequently: !0 });
    y.width = y.height = 1;
    const S = Math.sqrt(v.getImageData(0, 0, 1, 1).data.length >> 2);
    return y.width = (wn << 5) / S, y.height = hs / S, v.fillStyle = v.strokeStyle = "red", { context: v, ratio: S };
  }
  function E(y, v, S) {
    s[0], s[1];
    for (var b = v.x, O = v.y, I = Math.sqrt(s[0] * s[0] + s[1] * s[1]), k = c(s), G = p() < 0.5 ? 1 : -1, C = -G, L, B, D; (L = k(C += G)) && (B = ~~L[0], D = ~~L[1], !(Math.min(Math.abs(B), Math.abs(D)) >= I)); )
      if (v.x = b + B, v.y = O + D, !(v.x + v.x0 < 0 || v.y + v.y0 < 0 || v.x + v.x1 > s[0] || v.y + v.y1 > s[1]) && (!S || Qv(v, S)) && !Kv(v, y, s[0])) {
        for (var A = v.sprite, w = v.width >> 5, V = s[0] >> 5, N = v.x - (w << 4), P = N & 127, $ = 32 - P, X = v.y1 - v.y0, F = (v.y + v.y0) * V + (N >> 5), et, J = 0; J < X; J++) {
          et = 0;
          for (var ct = 0; ct <= w; ct++)
            y[F + ct] |= et << $ | (ct < w ? (et = A[J * w + ct]) >>> P : 0);
          F += V;
        }
        return !0;
      }
    return !1;
  }
  return f.timeInterval = function(y) {
    return arguments.length ? (h = y ?? 1 / 0, f) : h;
  }, f.words = function(y) {
    return arguments.length ? (l = y, f) : l;
  }, f.size = function(y) {
    return arguments.length ? (s = [+y[0], +y[1]], f) : s;
  }, f.font = function(y) {
    return arguments.length ? (e = xe(y), f) : e;
  }, f.fontStyle = function(y) {
    return arguments.length ? (i = xe(y), f) : i;
  }, f.fontWeight = function(y) {
    return arguments.length ? (r = xe(y), f) : r;
  }, f.rotate = function(y) {
    return arguments.length ? (a = xe(y), f) : a;
  }, f.text = function(y) {
    return arguments.length ? (t = xe(y), f) : t;
  }, f.spiral = function(y) {
    return arguments.length ? (c = zv[y] || y, f) : c;
  }, f.fontSize = function(y) {
    return arguments.length ? (n = xe(y), f) : n;
  }, f.padding = function(y) {
    return arguments.length ? (o = xe(y), f) : o;
  }, f.random = function(y) {
    return arguments.length ? (p = y, f) : p;
  }, f.on = function() {
    var y = d.on.apply(d, arguments);
    return y === d ? f : y;
  }, f;
};
function Wv(s) {
  return s.text;
}
function Xv() {
  return "serif";
}
function fo() {
  return "normal";
}
function jv(s) {
  return Math.sqrt(s.value);
}
function Yv() {
  return (~~(random() * 6) - 3) * 30;
}
function qv() {
  return 1;
}
function Zv(s, t, e, n) {
  if (!t.sprite) {
    var i = s.context, r = s.ratio;
    i.clearRect(0, 0, (wn << 5) / r, hs / r);
    var a = 0, o = 0, c = 0, l = e.length;
    for (--n; ++n < l; ) {
      t = e[n], i.save(), i.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / r) + "px " + t.font;
      const L = i.measureText(t.text), B = -Math.floor(L.width / 2);
      let D = (L.width + 1) * r, A = t.size << 1;
      if (t.rotate) {
        var h = Math.sin(t.rotate * vi), d = Math.cos(t.rotate * vi), u = D * d, p = D * h, f = A * d, g = A * h;
        D = Math.max(Math.abs(u + g), Math.abs(u - g)) + 31 >> 5 << 5, A = ~~Math.max(Math.abs(p + f), Math.abs(p - f));
      } else
        D = D + 31 >> 5 << 5;
      if (A > c && (c = A), a + D >= wn << 5 && (a = 0, o += c, c = 0), o + A >= hs) break;
      i.translate((a + (D >> 1)) / r, (o + (A >> 1)) / r), t.rotate && i.rotate(t.rotate * vi), i.fillText(t.text, B, 0), t.padding && (i.lineWidth = 2 * t.padding, i.strokeText(t.text, B, 0)), i.restore(), t.width = D, t.height = A, t.xoff = a, t.yoff = o, t.x1 = D >> 1, t.y1 = A >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, a += D;
    }
    for (var m = i.getImageData(0, 0, (wn << 5) / r, hs / r).data, E = []; --n >= 0; )
      if (t = e[n], !!t.hasText) {
        for (var y = t.width, v = y >> 5, S = t.y1 - t.y0, b = 0; b < S * v; b++) E[b] = 0;
        if (a = t.xoff, a == null) return;
        o = t.yoff;
        for (var O = 0, I = -1, k = 0; k < S; k++) {
          for (var b = 0; b < y; b++) {
            var G = v * k + (b >> 5), C = m[(o + k) * (wn << 5) + (a + b) << 2] ? 1 << 31 - b % 32 : 0;
            E[G] |= C, O |= C;
          }
          O ? I = k : (t.y0++, S--, k--, o++);
        }
        t.y1 = t.y0 + I, t.sprite = E.slice(0, (t.y1 - t.y0) * v);
      }
  }
}
function Kv(s, t, e) {
  e >>= 5;
  for (var n = s.sprite, i = s.width >> 5, r = s.x - (i << 4), a = r & 127, o = 32 - a, c = s.y1 - s.y0, l = (s.y + s.y0) * e + (r >> 5), h, d = 0; d < c; d++) {
    h = 0;
    for (var u = 0; u <= i; u++)
      if ((h << o | (u < i ? (h = n[d * i + u]) >>> a : 0)) & t[l + u]) return !0;
    l += e;
  }
  return !1;
}
function Jv(s, t) {
  var e = s[0], n = s[1];
  t.x + t.x0 < e.x && (e.x = t.x + t.x0), t.y + t.y0 < e.y && (e.y = t.y + t.y0), t.x + t.x1 > n.x && (n.x = t.x + t.x1), t.y + t.y1 > n.y && (n.y = t.y + t.y1);
}
function Qv(s, t) {
  return s.x + s.x1 > t[0].x && s.x + s.x0 < t[1].x && s.y + s.y1 > t[0].y && s.y + s.y0 < t[1].y;
}
function kl(s) {
  var t = s[0] / s[1];
  return function(e) {
    return [t * (e *= 0.1) * Math.cos(e), e * Math.sin(e)];
  };
}
function t0(s) {
  var t = 4, e = t * s[0] / s[1], n = 0, i = 0;
  return function(r) {
    var a = r < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * a * r) - a & 3) {
      case 0:
        n += e;
        break;
      case 1:
        i += t;
        break;
      case 2:
        n -= e;
        break;
      default:
        i -= t;
        break;
    }
    return [n, i];
  };
}
function e0(s) {
  for (var t = [], e = -1; ++e < s; ) t[e] = 0;
  return t;
}
function n0() {
  return document.createElement("canvas");
}
function xe(s) {
  return typeof s == "function" ? s : function() {
    return s;
  };
}
const s0 = /* @__PURE__ */ Ol(Fv);
class ny extends ot {
  constructor() {
    super(...arguments), this.type = "wordcloud", this.renderType = st.SVG, this.handleLegendOnHover = (t) => {
      const { hoveredElement: e } = t.detail, { groupMapsTo: n } = this.getOptions().data;
      this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(
        (i) => this.services.transitions.setupTransition({
          transition: i,
          name: "legend-hover-wordcloud"
        })
      ).attr("opacity", (i) => i[n] !== e.datum().name ? 0.3 : 1);
    }, this.handleLegendMouseOut = () => {
      this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(
        (t) => this.services.transitions.setupTransition({
          transition: t,
          name: "legend-mouseout-wordcloud"
        })
      ).attr("opacity", 1);
    };
  }
  init() {
    const t = this.services.events;
    t.addEventListener(x.Legend.ITEM_HOVER, this.handleLegendOnHover), t.addEventListener(x.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
  }
  render(t = !0) {
    const e = this, n = this.getComponentContainer().attr("width", "100%").attr("height", "100%"), i = this.model.getDisplayData(), r = this.getFontSizeScale(i), a = this.getOptions(), { fontSizeMapsTo: o, wordMapsTo: c } = a.wordCloud, { groupMapsTo: l } = a.data, { width: h, height: d } = _.getSVGElementSize(n, {
      useAttrs: !0
    });
    if (h === 0 || d === 0)
      return;
    const u = s0().size([h, d]).words(
      i.map(function(f) {
        const g = f[o];
        if (typeof f[o] != "number")
          throw Error(
            "Badly formatted WordCloud data. `value` should only be an integer or float"
          );
        return {
          [l]: f[l],
          text: f[c],
          size: g,
          value: g
        };
      })
    ).padding(5).rotate(0).fontSize((f) => r(f.size)).on("end", p);
    u.start();
    function p(f) {
      const g = _.appendOrSelect(n, "g.words");
      g.attr("transform", `translate(${u.size()[0] / 2}, ${u.size()[1] / 2})`);
      const m = g.selectAll("text").data(f, (y) => `${y[l]}-${y.text}`);
      m.exit().attr("opacity", 0).remove(), m.enter().append("text").attr("opacity", 0).merge(m).style("font-size", (y) => `${y.size}px`).text(function(y) {
        return y.text;
      }).attr(
        "class",
        (y) => e.model.getColorClassName({
          classNameTypes: [tt.FILL],
          dataGroupName: y[l],
          originalClassName: `word ${y.size > 32 ? "light" : ""}`
        })
      ).style("fill", (y) => e.model.getFillColor(y[l], y.text, y)).attr("text-anchor", "middle").transition().call(
        (y) => e.services.transitions.setupTransition({
          transition: y,
          name: "wordcloud-text-update-enter",
          animate: t
        })
      ).attr("transform", (y) => `translate(${y.x}, ${y.y})`).attr("opacity", 1);
    }
    this.addEventListeners();
  }
  getFontSizeScale(t) {
    const e = this.getOptions(), { fontSizeMapsTo: n } = e.wordCloud, i = t.map((c) => c[n]).filter((c) => c), r = _.getHTMLElementSize(this.services.domUtils.getMainContainer()), a = i.length > 0, o = a ? ks(i) : [1, 1];
    return ke().domain(o).range(a ? e.wordCloud.fontSizeRange(r, t) : [4, 4]);
  }
  addEventListeners() {
    const t = this.getOptions(), { groupMapsTo: e } = t.data, n = this, i = xi((r) => {
      const a = n.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(
        (o) => n.services.transitions.setupTransition({
          transition: o,
          name: "wordcloud-word-mouse-highlight"
        })
      );
      r === null ? a.attr("opacity", 1) : a.attr("opacity", function() {
        return r === this ? 1 : 0.3;
      });
    }, 6);
    this.parent.selectAll("text.word").on("mouseover", function(r, a) {
      const o = this;
      i(o), n.services.events.dispatchEvent(x.WordCloud.WORD_MOUSEOVER, {
        event: r,
        element: R(this),
        datum: a
      }), n.services.events.dispatchEvent(x.Tooltip.SHOW, {
        event: r,
        hoveredElement: o,
        items: [
          {
            label: t.tooltip.wordLabel,
            value: a.text
          },
          {
            label: t.tooltip.valueLabel,
            value: a.value
          },
          {
            label: yt(t, "locale.translations.group") || yt(t, "tooltip.groupLabel") || "Group",
            value: a[e],
            class: n.model.getColorClassName({
              classNameTypes: [tt.TOOLTIP],
              dataGroupName: a[e]
            })
          }
        ]
      });
    }).on("mousemove", function(r, a) {
      const o = R(this);
      n.services.events.dispatchEvent(x.WordCloud.WORD_MOUSEMOVE, {
        element: o,
        datum: a
      }), n.services.events.dispatchEvent(x.Tooltip.MOVE, {
        event: r
      });
    }).on("click", function(r, a) {
      n.services.events.dispatchEvent(x.WordCloud.WORD_CLICK, {
        event: r,
        element: R(this),
        datum: a
      });
    }).on("mouseout", function(r, a) {
      const o = R(this);
      i(null), n.services.events.dispatchEvent(x.WordCloud.WORD_MOUSEOUT, {
        event: r,
        element: o,
        datum: a
      }), n.services.events.dispatchEvent(x.Tooltip.HIDE, {
        hoveredElement: o
      });
    });
  }
}
class i0 extends ot {
  constructor() {
    super(...arguments), this.type = "geo", this.renderType = st.SVG;
  }
  render() {
    const t = this.getComponentContainer({ withinChartClip: !0 }), { width: e, height: n } = _.getSVGElementSize(t, {
      useAttrs: !0
    });
    if (e < 1 || n < 1)
      return;
    const i = this.getProjection(), r = T(this.getOptions(), "geoData"), a = this.model.getCombinedData(), o = {}, c = {};
    Object.keys(a).forEach((E) => {
      typeof a[E].value == "number" ? o[E] = a[E] : c[E] = a[E];
    });
    const l = rg(r, Object.values(c)), h = ng(r, {
      // We need to specify that we are converting geometry collections
      type: "GeometryCollection",
      geometries: Object.values(o)
    }), d = i.fitSize([e, n], h), u = rh().projection(d);
    _.appendOrSelect(t, "g.geo").selectAll("path").data(h.features).join("path").attr("d", u);
    const f = this.services.domUtils.generateElementIDString("geo-pattern-stripes"), g = _.appendOrSelect(t, "defs");
    _.appendOrSelect(g, "pattern").attr("id", f).attr("width", 5).attr("height", 10).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("path").classed("pattern-fill", !0).attr(
      "d",
      Nn()([
        [0, 0],
        [0, 10]
      ])
    );
    const m = _.appendOrSelect(t, "g.missing-data");
    _.appendOrSelect(m, "path").datum(l).attr("d", u).style("fill", `url(#${f})`);
  }
  /**
   * Retrieves the D3 geographic projection based on the options provided.
   *
   * This method selects a geographic projection from the available D3 projections
   * based on the `projection` property in the `thematic` options. If the projection
   * is not supported or is missing, an error is thrown.
   *
   * @returns {d3.GeoProjection} - The D3 geographic projection corresponding to the selected option.
   * @throws {Error} If the projection is not supported or is missing.
   */
  getProjection() {
    let t = null;
    switch (T(this.getOptions(), "thematic", "projection")) {
      case we.geoEqualEarth:
        t = Oh();
        break;
      case we.geoAlbers:
        t = vh();
        break;
      case we.geoConicEqualArea:
        t = cl();
        break;
      case we.geoConicEquidistant:
        t = bh();
        break;
      case we.geoEquirectangular:
        t = Sh();
        break;
      case we.geoMercator:
        t = yh();
        break;
      case we.geoNaturalEarth1:
        t = wh();
        break;
      default:
        throw new Error("Projection is not supported.");
    }
    return t;
  }
}
class sy extends i0 {
  constructor() {
    super(...arguments), this.type = "choropleth";
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(t = !0) {
    super.render();
    const e = this.model.getCombinedData();
    this.getComponentContainer({ withinChartClip: !0 }).select("g.geo").selectAll("path").classed("border", !0).attr("class", (r) => this.model.getColorClassName({
      value: e[r.properties.NAME].value,
      originalClassName: "border"
    })), this.addCountryAreaEventListener();
  }
  addCountryAreaEventListener() {
    const t = this, e = this.model.getCombinedData();
    this.parent.selectAll("path.border").on("mouseover", function(n, i) {
      const r = R(this);
      t.services.events.dispatchEvent(zn.CHOROPLETH_MOUSEOVER, {
        event: n,
        element: r,
        datum: e[i.properties.NAME]
      }), t.services.events.dispatchEvent(Ys.SHOW, {
        event: n,
        hoveredElement: r,
        items: [
          {
            label: i.properties.NAME,
            value: e[i.properties.NAME].value
          }
        ]
      });
    }).on("mousemove", function(n, i) {
      t.services.events.dispatchEvent(zn.CHOROPLETH_MOUSEMOVE, {
        event: n,
        element: R(this),
        datum: e[i.properties.NAME]
      }), t.services.events.dispatchEvent(Ys.MOVE, {
        event: n
      });
    }).on("click", function(n, i) {
      t.services.events.dispatchEvent(zn.CHOROPLETH_CLICK, {
        event: n,
        element: R(this),
        datum: e[i.properties.NAME]
      });
    }).on("mouseout", function(n, i) {
      const r = R(this);
      t.services.events.dispatchEvent(zn.CHOROPLETH_MOUSEOUT, {
        event: n,
        element: r,
        datum: e[i.properties.NAME]
      }), t.services.events.dispatchEvent(Ys.HIDE, {
        event: n,
        hoveredElement: r
      });
    });
  }
}
export {
  I0 as $,
  v0 as A,
  T0 as B,
  p0 as C,
  H0 as D,
  F0 as E,
  A0 as F,
  E0 as G,
  m0 as H,
  W0 as I,
  Z0 as J,
  X0 as K,
  Mf as L,
  d0 as M,
  B0 as N,
  j0 as O,
  lg as P,
  Y0 as Q,
  Ml as R,
  h0 as S,
  Af as T,
  ty as U,
  ey as V,
  ny as W,
  _l as X,
  Kf as Y,
  f0 as Z,
  R0 as _,
  Xa as a,
  k0 as a0,
  C0 as a1,
  _0 as a2,
  D0 as a3,
  P0 as a4,
  N0 as a5,
  $0 as a6,
  i0 as a7,
  br as a8,
  ot as a9,
  ja as b,
  Jc as c,
  Cf as d,
  _f as e,
  Qa as f,
  g0 as g,
  y0 as h,
  b0 as i,
  x0 as j,
  S0 as k,
  Sr as l,
  Jf as m,
  O0 as n,
  w0 as o,
  L0 as p,
  V0 as q,
  sy as r,
  G0 as s,
  K0 as t,
  Q0 as u,
  M0 as v,
  q0 as w,
  z0 as x,
  J0 as y,
  U0 as z
};
//# sourceMappingURL=choropleth-DQ5VXBbs.mjs.map
